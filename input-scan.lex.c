#line 2 "input-scan.lex.c"
/* input-scan.lex.c */
/* A lexical scanner generated by smflex. */
/* DO NOT EDIT MANUALLY. */

#include "input-scan.lex.h"     /* input_scan_lexer_t */

#include <assert.h>          /* assert */
#include <limits.h>          /* INT_MAX */
#include <stdlib.h>          /* malloc, free, realloc, exit */
#include <string.h>          /* strlen, memcpy */

/* Defined within a generated scanner. */
#define SMFLEX_SCANNER

/* Version of smflex used to generate this scanner. */
#define YY_SMFLEX_MAJOR_VERSION 1
#define YY_SMFLEX_MINOR_VERSION 0


/* Returned value from input_scan_lex() upon end-of-file.  This macro is used
 * to make the occurrences more readily identifiable; the value must
 * be specifically 0 because that is what the documentation uses. */
#define YY_EOF_TOKEN_CODE 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition. */
#define YY_SET_START_CONDITION(s) (yy_lexer->yy_start_state = 1 + 2 * (s))

/* Translate the current start state into a value that can be later handed
 * to YY_SET_START_CONDITION to return to the state. */
#define YY_GET_START_CONDITION() ((yy_lexer->yy_start_state - 1) / 2)

/* Action number for EOF rule of a given start condition. */
#define YY_STATE_EOF(cond) (YY_END_OF_BUFFER + (cond) + 1)

/* Two copies of this character are placed into the read buffer,
 * right after the data that was read from the input.  This is used
 * to signal the state machine logic that it has reached the end of
 * the buffered data, so it must stop and read more. */
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_DEFAULT_BUF_ALLOC_SIZE 16384

/* Define a macro that, when enabled, causes certain printouts to go
 * to stdout.  The intent is to use this as part of tests in order to
 * be able to see what some of the internals are doing when there is
 * not a less intrusive method available.  The symbol
 * 'YY_ENABLE_DEBUG_LOG_CALL' must be passed as a -D argument on the
 * compiler command line to activate this. */
#ifdef YY_ENABLE_DEBUG_LOG_CALL
#  define YY_DEBUG_LOG_CALL(call, val) \
     printf("[%s: %d]\n", call, (int)(val))
#else
#  define YY_DEBUG_LOG_CALL(str, val) ((void)0)
#endif

/* A switch to control memory-related debug logs. */
#ifdef YY_ENABLE_DEBUG_LOG_MEM
#  define YY_DEBUG_LOG_MEM(str, val) \
     printf("[%s: %d]\n", str, (int)(val))
#else
#  define YY_DEBUG_LOG_MEM(str, val) ((void)0)
#endif

/* This macro is meant to be used for a label that the code generator
 * emits but is not sure will be used.  Its purpose is to suppress any
 * warnings about the label in case it is, in fact, unused. */
#ifndef YY_POSSIBLY_UNUSED_LABEL
#  ifdef __GNUC__
#    define YY_POSSIBLY_UNUSED_LABEL(label) \
       label: __attribute__((__unused__));
#  else
#    define YY_POSSIBLY_UNUSED_LABEL(label) label:
#  endif
#endif

/* This macro is placed in front of the declarations of functions that
 * may or may not be used, depending on what the user's actions do. */
#ifndef YY_POSSIBLY_UNUSED_FUNCTION
#  ifdef __GNUC__
#    define YY_POSSIBLY_UNUSED_FUNCTION __attribute__((__unused__))
#  else
#    define YY_POSSIBLY_UNUSED_FUNCTION /*nothing*/
#  endif
#endif

/* This is used for internal integrity checks that do not have a
 * significant impact on performance, so should be fine to leave
 * enabled in production usage.  If YY_ASSERT fails, it means there
 * is a bug in smflex or the API has been misused. */
#ifndef YY_ASSERT
#  define YY_ASSERT(cond) assert(cond)
#endif

/* Assert something at compile time. */
#ifndef YY_STATIC_ASSERT
#  define YY_STATIC_ASSERT(cond) ((void)(int (*)[((cond)? +1 : -1)])0)
#endif

/* Check an API precondition.  If it fails, call YY_ERROR.  If that
 * returns, the form evaluates to 0; otherwise it evaluates to 1. */
#ifndef YY_API_PRECONDITION
#  define YY_API_PRECONDITION(cond) \
     ((cond)? 1 : (YY_ERROR(input_scan_err_api_misuse, #cond), 0))
#endif

/* C API functions are not static. */
#define STATIC_IF_CPP /*nothing*/

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Return all but the first 'new_yy_leng' matched characters back to the
 * input stream.  This definition only works in section 2 where the
 * local variables 'yy_cp' and 'yy_bp' are present. */
#define YY_LESS_TEXT(new_yy_leng) \
  do { \
    YY_API_PRECONDITION(0 <= new_yy_leng && new_yy_leng <= YY_LENG); \
    /* Undo effects of setting up yy_text. */ \
    *yy_cp = yy_lexer->yy_hold_char; \
    yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + new_yy_leng - YY_MORE_LEN; \
    YY_DO_BEFORE_ACTION; /* set up yy_text again */ \
  } while (0)



/* Possible values of 'yy_buf_status'. */
typedef enum yy_buf_status_enum {
  /* Indicates that the fields of 'input_scan_buffer_state_t' and its
   * 'yy_current_buffer' might be out of sync, and hence need fixing.
   *
   * TODO: This is ugly. */
  YY_BUF_STATUS_NEW,

  /* Normal, steady-state buffer status. */
  YY_BUF_STATUS_NORMAL,

  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_BUF_STATUS_EOF_PENDING, to indicate
   * that we shouldn't try reading from the input source any more.  We
   * might still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via input_scan_restart()), so that the user can continue scanning by
   * just pointing 'yy_input_stream' at a new input file.
   */
  YY_BUF_STATUS_EOF_PENDING
} yy_buf_status_t;


/* This structure contains the buffer state for a particular input
 * source.  By buffering, it allows efficient access to the bytes in
 * that source one at a time; its principal operations are to get the
 * next character and to put a character back. */
struct input_scan_buffer_state_struct {
  /* Source from which we are reading and buffering.  Note that whether
   * we truly use this is up to 'yy_read_function'; the scanner engine
   * merely promises to pass 'yy_input_stream' to that function. */
  input_scan_input_stream_t *yy_input_stream;

  /* Pointer to the beginning of the input buffer.  The allocated
   * space in the buffer is 'yy_buf_alloc_size+2'.  The buffer is owned
   * by this structure if 'yy_is_our_buffer'. */
  char *yy_buffer;

  /* Allocated size of input buffer in bytes, not including room for EOB
   * characters. */
  int yy_buf_alloc_size;

  /* Number of characters read into yy_buffer, not including EOB
   * characters.
   */
  int yy_buf_data_len;

  /* Points to current character in buffer, i.e., the next character
   * to scan.
   *
   * Invariant: yy_buffer <= yy_buf_cur_pos
   * Invariant:              yy_buf_cur_pos <= yy_buffer + yy_buf_data_len + 2
   *
   * I am not sure about being able to reach the +2 location. */
  char *yy_buf_cur_pos;

  /* The relationship among the four preceding fields is summarized in
   * this diagram:
   *
   *   yy_buffer                                yy_buf_alloc_size
   *   |                                                     |
   *   V                                                     V
   *   [ already scanned   yet to scan 0 0   available space 0 0 ]
   *                       ^           ^
   *                       |           |
   *              yy_buf_cur_pos  yy_buf_data_len
   *
   * The "0 0" at yy_buf_data_len must always be there.  The "0 0" at
   * yy_buf_alloc_size is space reserved to put the zeros in when
   * yy_buf_data_len == yy_buf_alloc_size, but otherwise need not be
   * present. */

  /* The following five flags could be combined to save space, but on
   * a 64-bit platform we are committed to another at least one 64-bit
   * word beyond 'yy_buf_cur_pos', so there is no point. */

  /* Whether we're considered to be at the beginning of a line.  If so,
   * '^' rules will be active on the next match, otherwise not.
   *
   * This should be first among the flags because it is the one that is
   * accessed most frequently, so should require the fewest instructions
   * to access. */
  unsigned char /*bool*/ yy_at_bol;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can reallocate it to grow it, and should free() it to
   * delete it. */
  unsigned char /*bool*/ yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, we read
   * one character at a time to make sure we stop fetching input after
   * each newline. */
  unsigned char /*bool*/ yy_is_interactive;

  /* Whether to try to fill the input buffer when we reach the
   * end of it. */
  unsigned char /*bool*/ yy_fill_buffer;

  /* Indicates the synchronization status between 'yy_current_buffer'
   * and the fields within our own structure that track them. */
  unsigned char /*yy_buf_status_t*/ yy_buf_status;
};

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER (yy_lexer->yy_current_buffer)


#define YY_FLUSH_CURRENT_BUFFER input_scan_flush_buffer(yy_lexer, yy_lexer->yy_current_buffer)


/* Throughout this file, we use 'int' for sizes of objects.  That is
 * because the objects in question are expected to be buffers with
 * size on the order of 10s of KiB, such that the usual range of 'int'
 * suffices.
 *
 * Going up to 'size_t' would require making some of the fields in the
 * structures larger, which would not be a major problem but is deemed
 * unnecessary and wasteful at this time. */
static void *yy_flex_alloc(int);
static void yy_flex_free(void *);




/* Forward static declarations. */
static void yy_load_current_buffer_state(input_scan_lexer_t *yy_lexer);
static void input_scan_init_buffer(input_scan_lexer_t *yy_lexer, input_scan_buffer_state_t *b,
                           input_scan_input_stream_t *file);


/* If 'yy_lexer' does not have a current buffer, create one.
 * Return false if allocation failed.*/
static int yy_create_buffer_if_needed(input_scan_lexer_t *yy_lexer)
{
  if (!yy_lexer->yy_current_buffer) {
    yy_lexer->yy_current_buffer =
      input_scan_create_buffer(yy_lexer, yy_lexer->yy_input_stream, YY_DEFAULT_BUF_ALLOC_SIZE);
    if (!yy_lexer->yy_current_buffer) {
      return 0;
    }
  }
  return 1;
}


STATIC_IF_CPP void input_scan_set_interactive(input_scan_lexer_t *yy_lexer, int is_interactive)
{
  if (!yy_create_buffer_if_needed(yy_lexer)) {
    return;
  }
  YY_DEBUG_LOG_CALL("setting yy_is_interactive due to input_scan_set_interactive", is_interactive);
  yy_lexer->yy_current_buffer->yy_is_interactive = !!is_interactive;
}



STATIC_IF_CPP int input_scan_get_bol(input_scan_lexer_t const *yy_lexer)
{
  if (!yy_lexer->yy_current_buffer) {
    /* When we start reading, BOL will be true. */
    return 1;
  }
  else {
    return yy_lexer->yy_current_buffer->yy_at_bol;
  }
}




STATIC_IF_CPP void input_scan_set_bol(input_scan_lexer_t *yy_lexer, int at_bol)
{
  if (!yy_create_buffer_if_needed(yy_lexer)) {
    return;
  }
  yy_lexer->yy_current_buffer->yy_at_bol = !!at_bol;
}





typedef unsigned char YY_CHAR;

static input_scan_state_type_t yy_get_previous_state(input_scan_lexer_t *yy_lexer);
static input_scan_state_type_t yy_try_NUL_trans(input_scan_lexer_t *yy_lexer, input_scan_state_type_t current_state);
static int yy_get_next_buffer(input_scan_lexer_t *yy_lexer);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yy_text. */
#define YY_DO_BEFORE_ACTION                              \
  yy_lexer->yy_text = yy_bp;                             \
  yy_lexer->yy_leng = (int) (yy_cp - yy_bp);             \
  yy_lexer->yy_hold_char = *yy_cp;                       \
  *yy_cp = '\0';                                         \
  yy_lexer->yy_buf_cur_pos = yy_cp;

#define YY_NUM_RULES 154
#define YY_END_OF_BUFFER 155
static const short int yy_accept[681] =
    {   0,
        0,    0,    0,    0,   78,   78,  152,  152,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,  155,  153,
        9,   16,  153,  153,   15,    1,  153,   13,  153,   14,
       99,   91,   92,   99,   84,   99,   98,   99,   99,   99,
       98,   90,   80,   99,   99,   82,   83,   78,   79,   78,
       77,   76,   77,   77,  152,  152,   26,   27,   26,   26,
       26,   26,   29,   28,   30,   29,  104,  100,  101,  103,
      105,  132,  133,  132,  130,  129,  131,  106,  108,  106,

      107,  106,  111,  111,  111,  111,  113,  115,  113,  113,
      113,  113,  114,  140,  144,  140,  143,  145,  145,  141,
      138,  139,  153,   73,  153,   19,   20,   19,   18,  146,
      148,  146,  149,  150,  136,  136,  137,  136,  136,  136,
      136,  136,   72,   32,   31,   72,   72,   72,   72,   33,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   24,   21,
       24,   22,    9,   16,    0,    0,    4,   15,    1,    2,
        0,    0,    0,    0,   10,    0,    6,    7,    0,    0,
       14,   91,   92,    0,    0,    0,   86,    0,    0,   96,

       96,    0,  151,  151,  151,   85,    0,   90,   80,    0,
        0,    0,   82,   83,   95,   81,    0,   78,   79,   77,
       76,   76,   74,   75,  152,  152,   26,   27,   26,   26,
       29,   28,   30,  102,  103,  133,  129,  108,    0,  109,
      110,  115,  112,  140,  144,    0,  142,    0,  135,  141,
        0,   73,    0,   19,   20,   19,   17,  146,  148,  147,
      136,  136,  136,  137,  134,  136,   32,   31,    0,   71,
        0,    0,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   34,   72,   72,
       72,   72,   72,   72,   72,   72,    0,   23,   22,    0,

       10,    0,    6,    6,    7,    0,    8,    0,    0,    3,
        0,   87,    0,   88,    0,    0,   96,   96,    0,   96,
       96,   96,  151,  151,    0,   97,   81,   89,    0,   95,
        0,   74,   75,   26,   25,   26,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,  134,  134,
        0,    0,   72,   72,   72,   40,   72,   72,   72,   45,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,    0,
        0,    6,    6,    7,    0,   96,   96,   96,   96,   96,
       96,  151,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,   35,   36,   72,
       72,   72,   72,   72,   72,   46,   72,   48,   72,   72,
       51,   72,   72,   72,   72,   54,   72,   72,   72,   58,
       72,   72,   72,   72,   72,   72,   72,    0,    0,    6,
        0,   96,   96,   96,   96,   96,   96,    0,    0,  128,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   37,   72,   39,   72,   72,   72,   43,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   56,   72,
       72,   72,   72,   72,   72,   72,   72,    5,    0,    6,
        0,   96,   96,   96,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,    0,    0,   38,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       67,   55,   72,   72,   72,   72,   72,   72,   72,   60,
       11,    6,   94,    0,   93,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,   72,   72,   41,
       72,   44,   72,   72,   72,   72,   66,   72,   57,   72,
       72,   72,   72,   68,   72,    0,   93,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,   72,
       72,   42,   72,   72,   50,   52,   72,   72,   72,   72,
       72,   72,   59,    0,    0,   12,    0,  116,  117,  118,

      119,  120,  121,  122,  123,  124,  125,  126,    0,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
      127,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   47,   49,   53,   69,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   63,   72,
       72,   72,   72,   72,   64,   62,   72,   72,   72,   72,
       72,   72,   72,   72,   70,   61,   72,   72,   65,    0
    } ;

static const int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    5,    6,    7,    8,    1,    9,   10,
       10,   11,   12,   13,   14,   10,   15,   16,   16,   16,
       16,   16,   16,   16,   17,   18,   19,   20,    1,   21,
       22,   23,   10,    1,   31,   32,   33,   34,   35,   36,
       37,   38,   39,   40,   41,   42,   43,   44,   45,   46,
       47,   48,   49,   50,   51,   52,   53,   54,   55,   47,
       26,   27,   28,   29,   30,    1,   31,   32,   33,   34,

       35,   36,   37,   38,   39,   40,   41,   42,   43,   44,
       45,   46,   47,   48,   49,   50,   51,   52,   53,   54,
       55,   47,   56,   57,   58,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static const int yy_meta[59] =
    {   0,
        1,    1,    2,    1,    3,    1,    1,    1,    4,    1,
        5,    6,    1,    7,    4,    8,    8,    8,    8,    1,
        1,    1,    1,    9,   10,    1,   11,   12,    1,   13,
       14,   14,   14,   14,   14,   14,   15,   15,   15,   15,
       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
       15,   15,   15,   15,   15,    4,    1,   16
    } ;

static const short int yy_base[767] =
    {   0,
        0,   58,  115,  172,  120,  129, 2539, 2538,  230, 2532,
      136,  141,  288,    0, 2510, 2509,  144,  151,  185,  191,
      178,  188,  344,  347,  375,    0,  125,  131,  147,  216,
      431,  434,  461,    0,  519,    0,  205,  349, 2537, 2543,
      438, 2543, 2533, 2524,    0,  441,  144,  570,  138,    0,
     2543,  577, 2543, 2531, 2543,  353, 2543, 2512,  139,  566,
      430,  584, 2543, 2529,  144, 2510, 2543,    0, 2543, 2527,
        0, 2527, 2525,  155, 2524, 2543,    0, 2543, 2523, 2543,
        0, 2467,    0, 2522, 2543, 2520, 2543, 2543, 2493,    0,
     2543, 2543, 2543, 2518, 2543,  577, 2543, 2543, 2543, 2517,

     2543,  573, 2543, 2499,  581,  164, 2543, 2543, 2515,    0,
     2497,  584, 2543,    0, 2543, 2513, 2543,  176, 2504,    0,
     2543, 2543,  222, 2543,  356,  359, 2543,  447, 2499,    0,
     2543, 2510, 2543,    0,    0,  452, 2543, 2509, 2453, 2543,
     2499,    0, 2543, 2507, 2543, 2505, 2502, 2474, 2473, 2543,
     2462, 2472,  185, 2467, 2468,  560,    0, 2456, 2468,  318,
     2453, 2446,  568, 2461, 2445, 2459, 2462, 2437, 2543, 2543,
     2486,  590,  627, 2543, 2487, 2478, 2543,    0,  641, 2543,
     2485,  444,  608, 2448,    0, 2440, 2442,    0,  614,  618,
        0,  644, 2543, 2481, 2427,  629, 2543, 2479, 2446,  610,

      631,  623, 2543,  637,    0, 2543, 2422,  657, 2543, 2476,
     2422, 2466, 2455, 2543,    0, 2543, 2440,    0, 2543,    0,
        0, 2472,    0,    0, 2470, 2543,    0, 2543,    0,  714,
        0, 2470, 2543, 2543,    0, 2543,  650, 2543,  742, 2543,
     2543, 2543, 2543,    0, 2543,  646, 2543,    0, 2543,    0,
      659, 2543,  667,  671, 2543,  676, 2543,    0, 2543, 2543,
        0,  674, 2413, 2543,  796,    0, 2468, 2543, 2464, 2543,
     2429, 2428,    0, 2427,  631, 2453, 2415,  651, 2414, 2413,
     2426, 2418, 2409, 2425, 2418, 2406,    0, 2543, 2405, 2406,
     2418,  583, 2421, 2403, 2402,  655, 2444, 2543,  673, 2404,

        0, 2397,    0, 2410,    0,  690, 2543,  692,  696, 2543,
      699, 2543,  701, 2543,  703, 2400,  682,  760,  839,  893,
      842,  936,  694,    0, 2386, 2543, 2543, 2543, 2408,    0,
     2397,    0,    0,    0, 2543,    0,  972, 2421,  757,  837,
      584,  841,  564,  840,  955,  842,  843,  758,    0, 1030,
     2390, 2389, 2401, 2396, 2403,    0, 2400, 2383, 2402,    0,
     2382, 2377, 2388, 2394, 2383, 2383, 2395, 2389, 2388, 2387,
     2388, 2386, 2387, 2387, 2374,  822, 2375, 2377, 2370, 2379,
     2374,    0, 2370,    0, 2375, 1065,  849, 1105, 2390,  865,
     1126, 2543, 2364, 2372,    0, 2379,  963,  763,  946,  977,

      852,  988,  857,  605,  982, 1034,  984, 2543, 2543, 2362,
     2354, 2366,  991, 2366, 2351,    0, 2387,    0, 2352, 2367,
        0, 2384, 2358, 2382, 2356,    0, 2361, 2352, 2347,    0,
     2356, 2355, 2326, 2309, 2321, 2302, 2297, 2342, 2298, 2301,
     2303, 2253,  994, 1147,  930,  686,  755, 2236, 2241, 2543,
      870, 1035, 1040, 1043, 1042, 1046, 1041, 1049,  854,  992,
     1044, 1045,    0, 2217,    0,  746, 2193, 2193,    0, 2181,
     2189, 2188, 2153, 2162, 2154, 2142, 2135, 2138,    0, 2136,
     2130, 2149, 2146, 2122, 2113, 2126, 2113, 2122, 2079, 2050,
     2077,  989,  763,  938, 2076, 2071, 1051, 1047, 1054, 1105,

     1106, 1108, 1107, 1134, 1147, 1048, 1128, 1110,    0, 2049,
     2057, 2046, 2038, 2036, 2035, 2046, 2015, 2022, 2019, 2013,
        0,    0, 2012, 2016, 2009, 1998, 2003, 1986, 1959,    0,
     2543, 1985, 2543, 1948, 2543, 1935, 1919, 1903, 1897, 1896,
     1890, 1889, 1888, 1887, 1870, 1864, 1148, 1825, 1777,    0,
     1771,    0, 1771, 1763, 1752, 1731,    0, 1729,    0,  840,
     1744, 1741, 1723,    0, 1704, 1129, 2543, 1720, 1714, 1713,
     1712, 1709, 1708, 1704, 1701, 1685, 1678, 1670, 1677, 1649,
     1611,    0, 1613, 1601,    0,    0, 1591, 1604, 1599, 1596,
     1102, 1594,    0, 1015, 1170, 2543, 1149, 2543, 2543, 2543,

     2543, 2543, 2543, 2543, 2543, 2543, 2543, 2543, 1594, 1568,
     1557, 1560, 1538, 1523, 1523, 1517, 1521,  971, 1508, 1527,
     2543, 1505, 1503, 1499, 1511, 1464, 1463, 1451, 1446, 1440,
     1408, 1394, 1404, 1397, 1389,    0,    0,    0,    0, 1384,
     1148, 1159, 1159, 1154, 1154, 1141, 1138, 1154, 1157, 1152,
     1137, 1141, 1146, 1136, 1100, 1035, 1044, 1027,    0, 1035,
     1022,  972,  926,  909,    0,    0,  847,  649,  409,  417,
      336,  315,  158,  109,    0,    0,  121,   73,    0, 2543,
     1198, 1214, 1230, 1246, 1262, 1278, 1294, 1310, 1326, 1342,
     1358, 1374, 1390, 1406, 1416, 1425, 1440, 1456, 1465, 1480,

     1496, 1512, 1528, 1544, 1554, 1569, 1579, 1594, 1610, 1626,
     1638, 1648, 1663, 1679, 1695, 1711, 1727, 1737, 1752, 1763,
     1155, 1778, 1794, 1802, 1809, 1824, 1840, 1856, 1872, 1888,
     1897, 1905, 1921, 1937, 1953, 1969, 1985, 2001, 2017, 2033,
     2043, 2058, 2068, 2075, 2090, 2102, 2112, 2127, 2143, 2159,
     2175, 2185, 2200, 2211, 2226, 2242, 2252, 2261, 2276, 2292,
     2308, 2324, 2333, 2341, 2357, 2373
    } ;

static const short int yy_def[767] =
    {   0,
      680,  680,  681,  681,  682,  683,  684,  684,  680,    9,
      685,  685,  680,   13,  686,  686,  687,  687,  688,  688,
      689,  689,  690,  690,  680,   25,  691,  691,  692,  692,
      693,  693,  680,   33,  680,   35,  694,  694,  680,  680,
      680,  680,  680,  680,  695,  680,  680,  680,  680,  696,
      680,  680,  680,  680,  680,  680,  680,  680,  697,  698,
      699,  680,  680,  680,  680,  680,  680,  700,  680,  700,
      701,  702,  701,  701,  703,  680,  704,  680,  704,  680,
      705,  704,  706,  680,  680,  706,  680,  680,  680,  707,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,

      680,  698,  680,  680,  698,  708,  680,  680,  680,  709,
      680,  698,  680,  710,  680,  710,  680,  711,  680,  712,
      680,  680,  713,  680,  713,  714,  680,  714,  680,  715,
      680,  715,  680,  716,  717,  717,  680,  717,  717,  680,
      717,  718,  680,  680,  680,  680,  719,  680,  680,  680,
      720,  720,  720,  720,  720,  720,  720,  720,  720,  720,
      721,  720,  720,  720,  720,  720,  720,  720,  680,  680,
      722,  680,  680,  680,  680,  680,  680,  695,  680,  680,
      680,  680,  680,  680,  723,  680,  724,  725,  726,  727,
      696,  680,  680,  680,  680,  728,  680,  680,  680,  729,

      729,  730,  680,  680,  731,  680,  732,  680,  680,  680,
      680,  680,  680,  680,  733,  680,  680,  734,  680,  735,
      736,  736,  737,  738,  739,  680,  740,  680,  741,  680,
      742,  680,  680,  680,  743,  680,  680,  680,  744,  680,
      680,  680,  680,  745,  680,  746,  680,  746,  680,  747,
      748,  680,  748,  749,  680,  749,  680,  750,  680,  680,
      751,  751,  751,  680,  680,  752,  680,  680,  753,  680,
      680,  680,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  680,  754,  754,
      754,  754,  754,  754,  754,  754,  755,  680,  680,  680,

      756,  680,  757,  757,  758,  759,  680,  759,  760,  680,
      760,  680,  761,  680,  761,  680,  762,  762,  762,  680,
      762,  762,  680,  763,  764,  680,  680,  680,  680,  765,
      680,  737,  738,  230,  680,  230,  230,  744,  744,  744,
      744,  744,  744,  744,  744,  744,  744,  744,  265,  265,
      680,  680,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  680,
      680,  757,  757,  758,  680,  320,  762,  322,  320,  762,
      322,  680,  680,  680,  337,  680,  744,  744,  744,  744,

      744,  744,  744,  744,  744,  744,  744,  680,  680,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  680,  680,  757,
      680,  386,  762,  322,  762,  762,  762,  680,  680,  680,
      744,  744,  744,  744,  744,  744,  744,  744,  744,  744,
      744,  744,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  680,  680,  757,
      680,  762,  762,  762,  680,  680,  744,  744,  744,  744,

      744,  744,  744,  744,  744,  744,  744,  744,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      680,  757,  680,  680,  680,  744,  744,  744,  744,  744,
      744,  744,  744,  744,  744,  744,  744,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  766,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  744,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  766,  766,  680,  766,  680,  680,  680,

      680,  680,  680,  680,  680,  680,  680,  680,  680,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      680,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,  754,
      754,  754,  754,  754,  754,  754,  754,  754,  754,    0,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,

      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680
    } ;

static const short int yy_nxt[2602] =
    {   0,
       40,   41,   42,   43,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   44,   40,   40,   40,   40,   40,
       40,   40,   40,   45,   45,   40,   40,   40,   40,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   40,   40,   40,   40,   46,
       42,   43,   40,   47,   40,   48,   40,   40,   40,   40,
       40,   40,   49,   40,   40,   40,   40,   40,   40,   40,
       40,   50,   50,   40,   40,   40,   40,   50,   50,   50,
       50,   50,   50,   50,   50,   50,   50,   50,   50,   50,

       50,   50,   50,   50,   50,   50,   50,   50,   50,   50,
       50,   50,   50,   40,   40,   40,   52,   53,   54,   55,
      679,   56,   69,   70,   57,   57,   57,  124,  125,   57,
       72,   69,   73,  124,  125,   58,   74,   84,   85,   86,
       59,   60,   84,   85,   86,  183,   93,   94,  177,  127,
      128,  215,  190,   93,   94,  678,   95,  129,  677,   96,
       96,   96,   96,   95,  201,  202,   96,   96,   96,   96,
       61,   57,   57,   62,   63,   64,   55,  241,   56,   65,
       40,   57,   57,   57,  247,  184,   57,   99,  100,  101,
       40,  241,   66,   99,  100,  101,  276,   59,   60,  216,

       67,   97,  248,  104,  105,  676,  106,  170,   97,  171,
      223,  102,  224,  104,  105,  277,  106,  102,  127,  128,
      172,  172,  172,  172,  252,  253,  129,   61,   57,   57,
       77,   77,   78,   79,   77,   77,   77,   77,   77,   77,
       80,   77,   77,   77,   77,   77,   77,   77,   77,   77,
       77,   77,   77,   81,   81,   77,   77,   77,   77,   81,
       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
       81,   81,   81,   81,   81,   77,   77,   77,   87,   87,
       40,   87,   87,   87,   87,   87,   87,   87,   88,   87,

       88,   87,   87,   87,   87,   87,   87,   87,   87,   87,
       89,   90,   90,   87,   87,   87,   87,   90,   90,   90,
       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
       90,   90,   90,   90,   90,   90,   90,   90,   90,   90,
       90,   90,   90,   87,   87,   87,  108,  109,  285,  108,
      109,  170,  286,  171,  197,  197,  198,  110,  252,  253,
      110,  255,  256,  675,  172,  172,  172,  172,  674,  111,
      112,  113,  111,  112,  113,  114,  114,  115,  116,  117,
      114,  114,  114,  118,  114,  114,  114,  114,  114,  119,
      114,  114,  114,  114,  114,  114,  114,  114,  120,  120,

      114,  114,  114,  114,  120,  120,  120,  120,  120,  120,
      120,  120,  120,  120,  120,  120,  120,  120,  120,  120,
      120,  120,  120,  120,  120,  120,  120,  120,  120,  120,
      121,  114,  122,  131,  132,  133,  131,  132,  133,  173,
      174,  175,  179,  180,  181,  206,  206,  206,  206,  255,
      256,  673,  176,  262,  177,  182,  672,  134,  190,  263,
      134,  135,  136,  137,  138,  135,  135,  135,  139,  135,
      135,  140,  135,  135,  135,  141,  135,  135,  135,  135,
      135,  135,  135,  135,  142,  142,  135,  135,  135,  135,
      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,

      142,  142,  142,  142,  142,  142,  142,  142,  142,  142,
      142,  142,  142,  142,  142,  142,  135,  135,  135,  143,
      144,  145,  146,  147,  143,  143,  143,  143,  143,  143,
      143,  143,  143,  143,  143,  148,  149,  143,  143,  143,
      150,  143,  143,  143,  143,  143,  143,  143,  143,  151,
      152,  153,  154,  155,  156,  157,  157,  158,  159,  157,
      157,  160,  161,  162,  163,  157,  164,  165,  157,  157,
      166,  167,  157,  168,  143,  143,  143,  185,  192,  193,
      194,  204,  204,  396,  195,  208,  209,  210,  204,  204,
      280,  211,  237,  237,  237,  237,  204,  204,  212,  204,

      204,  281,  290,  396,  213,  299,  299,  299,  299,  183,
      282,  401,  214,  371,  186,  291,  307,  308,  187,  205,
      310,  311,  372,  188,  396,  189,  205,  399,  173,  174,
      175,  314,  315,  196,  205,  318,  319,  205,  321,  321,
      196,  176,  179,  180,  181,  192,  193,  194,  459,  184,
      320,  195,  323,  323,  247,  182,  318,  319,  208,  209,
      210,  252,  253,  354,  211,  237,  237,  237,  237,  252,
      253,  212,  248,  255,  256,  262,  322,  213,  255,  256,
      355,  263,  358,  582,  376,  214,  359,  377,  299,  299,
      299,  299,  307,  308,  307,  308,  378,  379,  310,  311,

      196,  310,  311,  314,  315,  314,  315,  318,  319,  203,
      203,  318,  319,  196,  334,  334,  335,  336,  334,  334,
      334,  334,  334,  334,  337,  334,  334,  334,  334,  334,
      334,  334,  334,  334,  334,  334,  334,  337,  337,  334,
      334,  334,  334,  337,  337,  337,  337,  337,  337,  337,
      337,  337,  337,  337,  337,  337,  337,  337,  337,  337,
      337,  337,  337,  337,  337,  337,  337,  337,  337,  334,
      334,  334,  339,  340,  341,  342,  396,  396,  343,  386,
      318,  319,  396,  344,  510,  318,  319,  345,  318,  319,
      346,  407,  347,  453,  511,  348,  349,  349,  397,  349,

      349,  349,  349,  349,  349,  349,  350,  349,  349,  349,
      349,  349,  349,  349,  349,  349,  349,  349,  349,  350,
      350,  349,  349,  349,  349,  350,  350,  350,  350,  350,
      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
      350,  350,  350,  350,  350,  350,  350,  350,  350,  350,
      350,  349,  349,  349,  387,  387,  396,  390,  390,  396,
      396,  396,  396,  431,  443,  443,  317,  318,  319,  432,
      433,  396,  434,  396,  318,  319,  396,  671,  398,  400,
      446,  446,  456,  588,  402,  589,  505,  405,  406,  396,
      318,  319,  388,  317,  317,  458,  317,  317,  317,  317,

      317,  317,  317,  317,  317,  317,  317,  317,  317,  317,
      317,  317,  317,  317,  317,  317,  389,  389,  318,  319,
      497,  317,  317,  389,  389,  389,  389,  389,  389,  389,
      389,  389,  389,  389,  389,  389,  389,  389,  389,  389,
      389,  389,  389,  389,  389,  389,  389,  389,  317,  317,
      317,  391,  391,  391,  391,  318,  319,  200,  670,  391,
      669,  318,  319,  318,  319,  396,  391,  391,  391,  391,
      391,  391,  337,  337,  396,  395,  337,  337,  337,  337,
      337,  337,  396,  337,  337,  337,  337,  337,  337,  337,
      337,  337,  337,  337,  337,  454,  396,  337,  337,  337,

      337,  396,  403,  396,  466,  404,  451,  396,  452,  493,
      493,  396,  460,  455,  318,  319,  317,  596,  597,  318,
      319,  630,  462,  668,  506,  631,  467,  337,  337,  337,
      350,  350,  468,  350,  350,  350,  350,  350,  350,  350,
      457,  350,  350,  350,  350,  350,  350,  350,  350,  350,
      350,  350,  350,  396,  396,  350,  350,  350,  350,  396,
      396,  396,  396,  396,  396,  396,  396,  396,  396,  667,
      396,  666,  498,  396,  665,  503,  664,  537,  507,  461,
      501,  508,  545,  499,  663,  350,  350,  350,  442,  442,
      500,  502,  504,  536,  538,  442,  442,  442,  442,  442,

      442,  442,  442,  442,  442,  442,  442,  442,  442,  442,
      442,  442,  442,  442,  442,  442,  442,  442,  442,  442,
      444,  444,  444,  444,  396,  396,  396,  396,  444,  396,
      595,  596,  597,  618,  550,  444,  444,  444,  444,  444,
      444,  447,  447,  447,  447,  541,  539,  396,  547,  447,
      619,  596,  597,  396,  542,  540,  447,  447,  447,  447,
      447,  447,  494,  494,  494,  494,  396,  396,  287,  287,
      494,  595,  596,  597,  662,  546,  661,  494,  494,  494,
      494,  494,  494,  543,  660,  659,  658,  657,  656,  655,
      654,  653,  652,  651,  650,  649,  544,  579,   51,   51,

       51,   51,   51,   51,   51,   51,   51,   51,   51,   51,
       51,   51,   51,   51,   68,   68,   68,   68,   68,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       71,   71,   71,   71,   71,   71,   71,   71,   71,   71,
       71,   71,   71,   71,   71,   71,   75,   75,   75,   75,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
       75,   75,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   40,   40,
       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
       40,   40,   40,   40,   92,   92,   92,   92,   92,   92,

       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
       98,   98,   98,   98,   98,   98,  103,  103,  103,  103,
      103,  103,  103,  103,  103,  103,  103,  103,  103,  103,
      103,  103,  107,  107,  107,  107,  107,  107,  107,  107,
      107,  107,  107,  107,  107,  107,  107,  107,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      130,  130,  130,  130,  130,  130,  130,  130,  130,  130,

      130,  130,  130,  130,  130,  130,  169,  169,  169,  169,
      169,  169,  169,  169,  169,  169,  169,  169,  169,  169,
      169,  169,  178,  178,  178,  178,  648,  647,  178,  178,
      178,  191,  191,  191,  191,  646,  645,  191,  191,  191,
      200,  644,  200,  200,  200,  200,  200,  200,  200,  200,
      200,  200,  200,  200,  200,  200,  203,  643,  203,  203,
      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
      203,  203,  207,  207,  207,  642,  641,  207,  207,  207,
      218,  640,  218,  218,  218,  218,  218,  218,  218,  218,
      218,  218,  218,  218,  218,  218,  220,  639,  220,  220,

      220,  220,  220,  220,  220,  220,  220,  220,  220,  220,
      220,  220,  221,  638,  221,  221,  221,  221,  221,  221,
      221,  221,  221,  221,  221,  221,  221,  221,  225,  225,
      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
      225,  225,  225,  225,  227,  637,  227,  227,  636,  227,
      227,  227,  635,  634,  227,  227,  633,  632,  629,  227,
      229,  229,  229,  229,  628,  627,  229,  229,  229,  231,
      626,  231,  231,  231,  231,  231,  231,  231,  231,  231,
      231,  231,  231,  231,  231,  235,  235,  235,  235,  625,
      624,  235,  235,  235,  240,  623,  240,  240,  240,  240,

      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      243,  622,  243,  243,  243,  243,  243,  243,  243,  243,
      243,  621,  243,  243,  243,  243,  244,  620,  617,  616,
      244,  244,  244,  244,  615,  614,  244,  244,  246,  613,
      246,  246,  246,  246,  246,  246,  246,  246,  246,  246,
      246,  246,  246,  246,  250,  250,  250,  250,  612,  611,
      250,  250,  250,  251,  251,  251,  251,  251,  251,  251,
      251,  251,  251,  251,  251,  251,  251,  251,  251,  254,
      254,  254,  254,  610,  254,  254,  254,  254,  254,  254,
      254,  254,  254,  254,  254,  258,  609,  608,  258,  258,

      258,  258,  258,  258,  258,  607,  258,  258,  258,  258,
      258,  260,  606,  260,  260,  260,  260,  260,  260,  260,
      260,  260,  260,  260,  260,  260,  260,  261,  605,  261,
      261,  604,  261,  261,  261,  603,  602,  261,  261,  601,
      600,  599,  261,  266,  266,  266,  266,  598,  593,  266,
      266,  266,  269,  592,  269,  269,  269,  269,  269,  269,
      269,  269,  269,  269,  269,  269,  269,  269,  273,  273,
      591,  273,  273,  590,  587,  273,  273,  273,  297,  586,
      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
      297,  297,  297,  297,  301,  585,  301,  301,  301,  301,

      301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
      303,  303,  584,  583,  303,  303,  303,  305,  305,  582,
      581,  305,  305,  305,  306,  306,  306,  306,  306,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
      309,  309,  309,  309,  309,  309,  309,  309,  309,  309,
      309,  309,  309,  309,  309,  309,  313,  313,  313,  313,
      313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
      313,  313,  317,  580,  317,  317,  317,  317,  317,  317,
      317,  317,  317,  578,  317,  317,  317,  317,  200,  577,
      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,

      200,  200,  200,  200,  324,  324,  576,  575,  574,  573,
      324,  325,  325,  325,  325,  572,  571,  325,  325,  325,
      325,  330,  570,  330,  330,  330,  330,  330,  330,  330,
      330,  330,  330,  330,  330,  330,  330,  218,  569,  218,
      218,  218,  218,  218,  218,  218,  218,  218,  218,  218,
      218,  218,  218,  220,  568,  220,  220,  220,  220,  220,
      220,  220,  220,  220,  220,  220,  220,  220,  220,  221,
      567,  221,  221,  221,  221,  221,  221,  221,  221,  221,
      221,  221,  221,  221,  221,  332,  566,  332,  332,  332,
      332,  332,  332,  332,  332,  332,  332,  332,  332,  332,

      332,  333,  565,  333,  333,  333,  333,  333,  333,  333,
      333,  333,  333,  333,  333,  333,  333,  225,  225,  225,
      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
      225,  225,  225,  227,  564,  227,  227,  563,  227,  227,
      227,  562,  561,  227,  227,  560,  559,  558,  227,  229,
      229,  229,  229,  557,  556,  229,  229,  229,  231,  555,
      231,  231,  231,  231,  231,  231,  231,  231,  231,  231,
      231,  231,  231,  231,  235,  235,  235,  235,  554,  553,
      235,  235,  235,  338,  338,  552,  551,  550,  338,  338,
      244,  549,  548,  535,  244,  244,  244,  244,  534,  533,

      244,  244,  246,  532,  246,  246,  246,  246,  246,  246,
      246,  246,  246,  246,  246,  246,  246,  246,  250,  250,
      250,  250,  531,  488,  250,  250,  250,  251,  251,  251,
      251,  251,  251,  251,  251,  251,  251,  251,  251,  251,
      251,  251,  251,  254,  254,  254,  254,  530,  254,  254,
      254,  254,  254,  254,  254,  254,  254,  254,  254,  258,
      529,  528,  258,  258,  258,  258,  258,  258,  258,  527,
      258,  258,  258,  258,  258,  261,  526,  261,  261,  525,
      261,  261,  261,  524,  523,  261,  261,  522,  521,  520,
      261,  266,  266,  266,  266,  519,  518,  266,  266,  266,

      269,  517,  269,  269,  269,  269,  269,  269,  269,  269,
      269,  269,  269,  269,  269,  269,  273,  273,  516,  273,
      273,  515,  514,  273,  273,  273,  297,  513,  297,  297,
      297,  297,  297,  297,  297,  297,  297,  297,  297,  297,
      297,  297,  301,  512,  301,  301,  301,  301,  301,  301,
      301,  301,  301,  301,  301,  301,  301,  301,  382,  382,
      382,  382,  509,  496,  382,  382,  382,  384,  384,  384,
      384,  495,  492,  384,  384,  384,  306,  306,  306,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
      306,  306,  309,  309,  309,  309,  309,  309,  309,  309,

      309,  309,  309,  309,  309,  309,  309,  309,  313,  313,
      313,  313,  313,  313,  313,  313,  313,  313,  313,  313,
      313,  313,  313,  313,  317,  491,  317,  317,  317,  317,
      317,  317,  317,  317,  317,  490,  317,  317,  317,  317,
      392,  392,  489,  488,  487,  486,  392,  325,  325,  325,
      325,  485,  484,  325,  325,  325,  325,  330,  483,  330,
      330,  330,  330,  330,  330,  330,  330,  330,  330,  330,
      330,  330,  330,  594,  594,  594,  594,  594,  594,  594,
      594,  594,  594,  594,  594,  594,  594,  594,  594,  482,
      481,  480,  479,  478,  477,  476,  475,  474,  473,  472,

      471,  470,  469,  465,  464,  463,  450,  449,  448,  445,
      441,  440,  439,  438,  437,  436,  435,  430,  429,  428,
      427,  426,  425,  424,  423,  422,  421,  420,  419,  418,
      417,  416,  415,  414,  413,  412,  411,  410,  409,  408,
      396,  394,  393,  326,  385,  383,  381,  380,  298,  375,
      374,  373,  370,  369,  368,  367,  366,  365,  364,  363,
      362,  361,  360,  357,  356,  353,  352,  351,  270,  267,
      265,  232,  226,  222,  331,  329,  328,  327,  209,  326,
      316,  197,  312,  193,  304,  302,  300,  180,  177,  174,
      298,  296,  295,  294,  293,  292,  289,  288,  284,  283,

      279,  278,  275,  274,  272,  271,  270,  268,  267,  249,
      265,  264,  259,  257,  249,  245,  239,  242,  239,  238,
      236,  234,  233,  232,  230,  228,  226,  219,  222,  219,
      217,  209,  199,  193,  177,  174,  680,   91,   91,   82,
       76,   76,   39,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,

      680
    } ;

static const short int yy_chk[2602] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,

        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    3,    3,    3,    3,
      678,    3,    5,    5,    3,    3,    3,   27,   27,    3,
        6,    6,    6,   28,   28,    3,    6,   11,   11,   11,
        3,    3,   12,   12,   12,   47,   17,   17,   49,   29,
       29,   65,   49,   18,   18,  677,   17,   29,  674,   17,
       17,   17,   17,   18,   59,   59,   18,   18,   18,   18,
        3,    3,    3,    4,    4,    4,    4,  106,    4,    4,
       21,    4,    4,    4,  118,   47,    4,   19,   19,   19,
       22,  106,    4,   20,   20,   20,  153,    4,    4,   65,

        4,   17,  118,   21,   21,  673,   21,   37,   18,   37,
       74,   19,   74,   22,   22,  153,   22,   20,   30,   30,
       37,   37,   37,   37,  123,  123,   30,    4,    4,    4,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,

       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   23,   23,  160,   24,
       24,   38,  160,   38,   56,   56,   56,   23,  125,  125,
       24,  126,  126,  672,   38,   38,   38,   38,  671,   23,
       23,   23,   24,   24,   24,   25,   25,   25,   25,   25,
       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,

       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
       25,   25,   25,   25,   25,   25,   25,   25,   25,   25,
       25,   25,   25,   31,   31,   31,   32,   32,   32,   41,
       41,   41,   46,   46,   46,   61,   61,   61,   61,  128,
      128,  670,   41,  136,  182,   46,  669,   31,  182,  136,
       32,   33,   33,   33,   33,   33,   33,   33,   33,   33,
       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,

       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
       33,   33,   33,   33,   33,   33,   33,   33,   33,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   48,   52,   52,
       52,   60,   60,  343,   52,   62,   62,   62,  102,  102,
      156,   62,   96,   96,   96,   96,  105,  105,   62,  112,

      112,  156,  163,  341,   62,  172,  172,  172,  172,  183,
      156,  343,   62,  292,   48,  163,  189,  189,   48,   60,
      190,  190,  292,   48,  404,   48,  102,  341,  173,  173,
      173,  196,  196,   52,  105,  200,  200,  112,  202,  202,
       62,  173,  179,  179,  179,  192,  192,  192,  404,  183,
      201,  192,  204,  204,  246,  179,  201,  201,  208,  208,
      208,  251,  251,  275,  208,  237,  237,  237,  237,  253,
      253,  208,  246,  254,  254,  262,  202,  208,  256,  256,
      275,  262,  278,  668,  296,  208,  278,  296,  299,  299,
      299,  299,  306,  306,  308,  308,  296,  296,  309,  309,

      192,  311,  311,  313,  313,  315,  315,  317,  317,  323,
      323,  446,  446,  208,  230,  230,  230,  230,  230,  230,
      230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
      230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
      230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
      230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
      230,  230,  230,  230,  230,  230,  230,  230,  230,  230,
      230,  230,  239,  239,  239,  239,  339,  348,  239,  318,
      447,  447,  398,  239,  466,  318,  318,  239,  493,  493,
      239,  348,  239,  398,  466,  239,  265,  265,  339,  265,

      265,  265,  265,  265,  265,  265,  265,  265,  265,  265,
      265,  265,  265,  265,  265,  265,  265,  265,  265,  265,
      265,  265,  265,  265,  265,  265,  265,  265,  265,  265,
      265,  265,  265,  265,  265,  265,  265,  265,  265,  265,
      265,  265,  265,  265,  265,  265,  265,  265,  265,  265,
      265,  265,  265,  265,  319,  319,  340,  321,  321,  344,
      342,  346,  347,  376,  387,  387,  319,  321,  321,  376,
      376,  401,  376,  459,  387,  387,  403,  667,  340,  342,
      390,  390,  401,  560,  344,  560,  459,  346,  347,  451,
      390,  390,  319,  320,  320,  403,  320,  320,  320,  320,

      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
      451,  320,  320,  320,  320,  320,  320,  320,  320,  320,
      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
      320,  320,  320,  320,  320,  320,  320,  320,  320,  320,
      320,  322,  322,  322,  322,  445,  445,  445,  664,  322,
      663,  322,  322,  494,  494,  399,  322,  322,  322,  322,
      322,  322,  337,  337,  345,  337,  337,  337,  337,  337,
      337,  337,  397,  337,  337,  337,  337,  337,  337,  337,
      337,  337,  337,  337,  337,  399,  400,  337,  337,  337,

      337,  405,  345,  407,  413,  345,  397,  402,  397,  443,
      443,  460,  405,  400,  492,  492,  492,  594,  594,  443,
      443,  618,  407,  662,  460,  618,  413,  337,  337,  337,
      350,  350,  413,  350,  350,  350,  350,  350,  350,  350,
      402,  350,  350,  350,  350,  350,  350,  350,  350,  350,
      350,  350,  350,  406,  452,  350,  350,  350,  350,  453,
      457,  455,  454,  461,  462,  456,  498,  506,  458,  661,
      497,  660,  452,  499,  658,  457,  657,  498,  461,  406,
      455,  462,  506,  453,  656,  350,  350,  350,  386,  386,
      454,  456,  458,  497,  499,  386,  386,  386,  386,  386,

      386,  386,  386,  386,  386,  386,  386,  386,  386,  386,
      386,  386,  386,  386,  386,  386,  386,  386,  386,  386,
      388,  388,  388,  388,  500,  501,  503,  502,  388,  508,
      566,  566,  566,  591,  655,  388,  388,  388,  388,  388,
      388,  391,  391,  391,  391,  502,  500,  507,  508,  391,
      591,  597,  597,  504,  503,  501,  391,  391,  391,  391,
      391,  391,  444,  444,  444,  444,  505,  547,  721,  721,
      444,  595,  595,  595,  654,  507,  653,  444,  444,  444,
      444,  444,  444,  504,  652,  651,  650,  649,  648,  647,
      646,  645,  644,  643,  642,  641,  505,  547,  681,  681,

      681,  681,  681,  681,  681,  681,  681,  681,  681,  681,
      681,  681,  681,  681,  682,  682,  682,  682,  682,  682,
      682,  682,  682,  682,  682,  682,  682,  682,  682,  682,
      683,  683,  683,  683,  683,  683,  683,  683,  683,  683,
      683,  683,  683,  683,  683,  683,  684,  684,  684,  684,
      684,  684,  684,  684,  684,  684,  684,  684,  684,  684,
      684,  684,  685,  685,  685,  685,  685,  685,  685,  685,
      685,  685,  685,  685,  685,  685,  685,  685,  686,  686,
      686,  686,  686,  686,  686,  686,  686,  686,  686,  686,
      686,  686,  686,  686,  687,  687,  687,  687,  687,  687,

      687,  687,  687,  687,  687,  687,  687,  687,  687,  687,
      688,  688,  688,  688,  688,  688,  688,  688,  688,  688,
      688,  688,  688,  688,  688,  688,  689,  689,  689,  689,
      689,  689,  689,  689,  689,  689,  689,  689,  689,  689,
      689,  689,  690,  690,  690,  690,  690,  690,  690,  690,
      690,  690,  690,  690,  690,  690,  690,  690,  691,  691,
      691,  691,  691,  691,  691,  691,  691,  691,  691,  691,
      691,  691,  691,  691,  692,  692,  692,  692,  692,  692,
      692,  692,  692,  692,  692,  692,  692,  692,  692,  692,
      693,  693,  693,  693,  693,  693,  693,  693,  693,  693,

      693,  693,  693,  693,  693,  693,  694,  694,  694,  694,
      694,  694,  694,  694,  694,  694,  694,  694,  694,  694,
      694,  694,  695,  695,  695,  695,  640,  635,  695,  695,
      695,  696,  696,  696,  696,  634,  633,  696,  696,  696,
      697,  632,  697,  697,  697,  697,  697,  697,  697,  697,
      697,  697,  697,  697,  697,  697,  698,  631,  698,  698,
      698,  698,  698,  698,  698,  698,  698,  698,  698,  698,
      698,  698,  699,  699,  699,  630,  629,  699,  699,  699,
      700,  628,  700,  700,  700,  700,  700,  700,  700,  700,
      700,  700,  700,  700,  700,  700,  701,  627,  701,  701,

      701,  701,  701,  701,  701,  701,  701,  701,  701,  701,
      701,  701,  702,  626,  702,  702,  702,  702,  702,  702,
      702,  702,  702,  702,  702,  702,  702,  702,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  704,  625,  704,  704,  624,  704,
      704,  704,  623,  622,  704,  704,  620,  619,  617,  704,
      705,  705,  705,  705,  616,  615,  705,  705,  705,  706,
      614,  706,  706,  706,  706,  706,  706,  706,  706,  706,
      706,  706,  706,  706,  706,  707,  707,  707,  707,  613,
      612,  707,  707,  707,  708,  611,  708,  708,  708,  708,

      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      709,  610,  709,  709,  709,  709,  709,  709,  709,  709,
      709,  609,  709,  709,  709,  709,  710,  592,  590,  589,
      710,  710,  710,  710,  588,  587,  710,  710,  711,  584,
      711,  711,  711,  711,  711,  711,  711,  711,  711,  711,
      711,  711,  711,  711,  712,  712,  712,  712,  583,  581,
      712,  712,  712,  713,  713,  713,  713,  713,  713,  713,
      713,  713,  713,  713,  713,  713,  713,  713,  713,  714,
      714,  714,  714,  580,  714,  714,  714,  714,  714,  714,
      714,  714,  714,  714,  714,  715,  579,  578,  715,  715,

      715,  715,  715,  715,  715,  577,  715,  715,  715,  715,
      715,  716,  576,  716,  716,  716,  716,  716,  716,  716,
      716,  716,  716,  716,  716,  716,  716,  717,  575,  717,
      717,  574,  717,  717,  717,  573,  572,  717,  717,  571,
      570,  569,  717,  718,  718,  718,  718,  568,  565,  718,
      718,  718,  719,  563,  719,  719,  719,  719,  719,  719,
      719,  719,  719,  719,  719,  719,  719,  719,  720,  720,
      562,  720,  720,  561,  558,  720,  720,  720,  722,  556,
      722,  722,  722,  722,  722,  722,  722,  722,  722,  722,
      722,  722,  722,  722,  723,  555,  723,  723,  723,  723,

      723,  723,  723,  723,  723,  723,  723,  723,  723,  723,
      724,  724,  554,  553,  724,  724,  724,  725,  725,  551,
      549,  725,  725,  725,  726,  726,  726,  726,  726,  726,
      726,  726,  726,  726,  726,  726,  726,  726,  726,  726,
      727,  727,  727,  727,  727,  727,  727,  727,  727,  727,
      727,  727,  727,  727,  727,  727,  728,  728,  728,  728,
      728,  728,  728,  728,  728,  728,  728,  728,  728,  728,
      728,  728,  729,  548,  729,  729,  729,  729,  729,  729,
      729,  729,  729,  546,  729,  729,  729,  729,  730,  545,
      730,  730,  730,  730,  730,  730,  730,  730,  730,  730,

      730,  730,  730,  730,  731,  731,  544,  543,  542,  541,
      731,  732,  732,  732,  732,  540,  539,  732,  732,  732,
      732,  733,  538,  733,  733,  733,  733,  733,  733,  733,
      733,  733,  733,  733,  733,  733,  733,  734,  537,  734,
      734,  734,  734,  734,  734,  734,  734,  734,  734,  734,
      734,  734,  734,  735,  536,  735,  735,  735,  735,  735,
      735,  735,  735,  735,  735,  735,  735,  735,  735,  736,
      534,  736,  736,  736,  736,  736,  736,  736,  736,  736,
      736,  736,  736,  736,  736,  737,  532,  737,  737,  737,
      737,  737,  737,  737,  737,  737,  737,  737,  737,  737,

      737,  738,  529,  738,  738,  738,  738,  738,  738,  738,
      738,  738,  738,  738,  738,  738,  738,  739,  739,  739,
      739,  739,  739,  739,  739,  739,  739,  739,  739,  739,
      739,  739,  739,  740,  528,  740,  740,  527,  740,  740,
      740,  526,  525,  740,  740,  524,  523,  520,  740,  741,
      741,  741,  741,  519,  518,  741,  741,  741,  742,  517,
      742,  742,  742,  742,  742,  742,  742,  742,  742,  742,
      742,  742,  742,  742,  743,  743,  743,  743,  516,  515,
      743,  743,  743,  744,  744,  514,  513,  512,  744,  744,
      745,  511,  510,  496,  745,  745,  745,  745,  495,  491,

      745,  745,  746,  490,  746,  746,  746,  746,  746,  746,
      746,  746,  746,  746,  746,  746,  746,  746,  747,  747,
      747,  747,  489,  488,  747,  747,  747,  748,  748,  748,
      748,  748,  748,  748,  748,  748,  748,  748,  748,  748,
      748,  748,  748,  749,  749,  749,  749,  487,  749,  749,
      749,  749,  749,  749,  749,  749,  749,  749,  749,  750,
      486,  485,  750,  750,  750,  750,  750,  750,  750,  484,
      750,  750,  750,  750,  750,  751,  483,  751,  751,  482,
      751,  751,  751,  481,  480,  751,  751,  478,  477,  476,
      751,  752,  752,  752,  752,  475,  474,  752,  752,  752,

      753,  473,  753,  753,  753,  753,  753,  753,  753,  753,
      753,  753,  753,  753,  753,  753,  754,  754,  472,  754,
      754,  471,  470,  754,  754,  754,  755,  468,  755,  755,
      755,  755,  755,  755,  755,  755,  755,  755,  755,  755,
      755,  755,  756,  467,  756,  756,  756,  756,  756,  756,
      756,  756,  756,  756,  756,  756,  756,  756,  757,  757,
      757,  757,  464,  449,  757,  757,  757,  758,  758,  758,
      758,  448,  442,  758,  758,  758,  759,  759,  759,  759,
      759,  759,  759,  759,  759,  759,  759,  759,  759,  759,
      759,  759,  760,  760,  760,  760,  760,  760,  760,  760,

      760,  760,  760,  760,  760,  760,  760,  760,  761,  761,
      761,  761,  761,  761,  761,  761,  761,  761,  761,  761,
      761,  761,  761,  761,  762,  441,  762,  762,  762,  762,
      762,  762,  762,  762,  762,  440,  762,  762,  762,  762,
      763,  763,  439,  438,  437,  436,  763,  764,  764,  764,
      764,  435,  434,  764,  764,  764,  764,  765,  433,  765,
      765,  765,  765,  765,  765,  765,  765,  765,  765,  765,
      765,  765,  765,  766,  766,  766,  766,  766,  766,  766,
      766,  766,  766,  766,  766,  766,  766,  766,  766,  432,
      431,  429,  428,  427,  425,  424,  423,  422,  420,  419,

      417,  415,  414,  412,  411,  410,  396,  394,  393,  389,
      385,  383,  381,  380,  379,  378,  377,  375,  374,  373,
      372,  371,  370,  369,  368,  367,  366,  365,  364,  363,
      362,  361,  359,  358,  357,  355,  354,  353,  352,  351,
      338,  331,  329,  325,  316,  304,  302,  300,  297,  295,
      294,  293,  291,  290,  289,  286,  285,  284,  283,  282,
      281,  280,  279,  277,  276,  274,  272,  271,  269,  267,
      263,  232,  225,  222,  217,  213,  212,  211,  210,  207,
      199,  198,  195,  194,  187,  186,  184,  181,  176,  175,
      171,  168,  167,  166,  165,  164,  162,  161,  159,  158,

      155,  154,  152,  151,  149,  148,  147,  146,  144,  141,
      139,  138,  132,  129,  119,  116,  111,  109,  104,  100,
       94,   89,   86,   84,   82,   79,   75,   73,   72,   70,
       66,   64,   58,   54,   44,   43,   39,   16,   15,   10,
        8,    7,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,
      680,  680,  680,  680,  680,  680,  680,  680,  680,  680,

      680
    } ;


/* The intent behind this definition is that it'll catch
 * any uses of YY_REJECT which smflex missed. */
#define YY_REJECT YY_REJECT_used_but_option_reject_not_specified

#define YY_MORE_TEXT() YY_MORE_TEXT_used_but_option_yymore_not_specified
#define YY_MORE_LEN 0

#define INITIAL 0
#line 1 "input-scan.lex"
/* input-scan.lex - scanner for smflex input */



#line 6 "input-scan.lex"
/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Vern Paxson.
 *
 * The United States Government has rights in this work pursuant
 * to contract no. DE-AC03-76SF00098 between the United States
 * Department of Energy and the University of California.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided
 * that: (1) source distributions retain this entire copyright notice and
 * comment, and (2) distributions including binaries display the following
 * acknowledgement:  ``This product includes software developed by the
 * University of California, Berkeley and its contributors'' in the
 * documentation or other materials provided with the distribution and in
 * all advertising materials mentioning features or use of this software.
 * Neither the name of the University nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "input-scan.h"                /* this module */

#include "input-parse.h"               /* synerr, format_synerr, yylval */
#include "input-parse.y.h"             /* token codes */
#include "main.h"                      /* sectnum, nmstr */
#include "misc.h"                      /* add_action, myctoi, etc. */
#include "sym.h"                       /* ndinstal, ccllookup, cclinstal */

#include <string.h>                    /* strcpy, strlen, etc. */


#define ACTION_ECHO add_action(YY_TEXT)
#define ACTION_IFDEF(def, should_define) \
  { \
    if (should_define) \
      action_define(def, 1); \
  }

/* Add a newline to the current action text.  This is done when we
 * consume a line of source text but do not otherwise emit anything,
 * since we need to stay synchronized with the #line scope.
 *
 * In general, every time we increment 'linenum', we must either echo
 * the newline we matched, call ADD_ACTION_NL(), or emit a new #line
 * directive. */
#define ADD_ACTION_NL() add_action("\n")

#define MARK_END_OF_PROLOG mark_prolog();

#define RETURNCHAR \
  yylval = (unsigned char) YY_TEXT[0]; \
  return CHAR;

#define RETURNNAME \
  strcpy( nmstr, YY_TEXT ); \
  return NAME;

#define PUT_BACK_STRING(str, start) \
  for (i = strlen(str) - 1; i >= start; --i) \
    YY_UNREAD_CHARACTER((str)[i])



#line 1303 "input-scan.lex.c"
#line 76 "input-scan.lex"
#line 1305 "input-scan.lex.c"
#line 77 "input-scan.lex"
#line 1307 "input-scan.lex.c"
#line 78 "input-scan.lex"
#line 1309 "input-scan.lex.c"
#line 79 "input-scan.lex"

#line 1312 "input-scan.lex.c"
#define SECT2 1
#define SECT2PROLOG 2
#define SECT3 3
#define CODEBLOCK 4
#define PICKUPDEF 5
#define SC 6
#define CARETISBOL 7
#define NUM 8
#define QUOTE 9
#line 81 "input-scan.lex"
#line 1323 "input-scan.lex.c"
#define FIRSTCCL 10
#define CCL 11
#define ACTION 12
#define RECOVER 13
#define COMMENT 14
#define ACTION_STRING 15
#define PERCENT_BRACE_ACTION 16
#line 82 "input-scan.lex"
#line 1332 "input-scan.lex.c"
#define OPTION 17
#define LINEDIR 18
#line 83 "input-scan.lex"


















#line 1354 "input-scan.lex.c"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */


/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#  define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the output stream. */
#ifndef YY_ECHO
#  define YY_ECHO ((void)yy_lexer->yy_write_output_function(yy_lexer, \
                           yy_lexer->yy_text, yy_lexer->yy_leng))
#endif

/* No semi-colon after return; correct usage is to write "YY_TERMINATE();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef YY_TERMINATE
#  define YY_TERMINATE() return YY_EOF_TOKEN_CODE
#endif

/* Number of entries by which start-condition stack grows, on top of
 * doubling every time. */
#ifndef YY_START_STACK_INCR
#  define YY_START_STACK_INCR 25
#endif


/* Report an error.  This may return, in which case the scanner will
 * attempt to return control to the client so it can clean up. */
#define YY_ERROR(code, detail) \
  (yy_call_error_function(yy_lexer, code, detail))

static void yy_call_error_function(input_scan_lexer_t const *yy_lexer,
  input_scan_error_code_t code, char const *detail)
{
  /* Record the error in the lexer object, but only the first one. */
  if (yy_lexer->yy_error_code == input_scan_err_no_error) {
    /* Cast away constness.  I do not want to remove 'const' from the
     * functions that are conceptually just queries, nor do I want to
     * forgo enforcing prerequisites, nor do I want to abandon saving
     * the error code. */
    ((input_scan_lexer_t*)yy_lexer)->yy_error_code = code;
  }

  yy_lexer->yy_error_function(yy_lexer, code, detail);
}


/* Code executed at the beginning of each rule, after yy_text and yy_leng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#  define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#  define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  if ( yy_lexer->yy_leng > 0 ) \
    yy_lexer->yy_current_buffer->yy_at_bol = \
        (yy_lexer->yy_text[yy_lexer->yy_leng - 1] == '\n'); \
  YY_USER_ACTION

int input_scan_lex(input_scan_lexer_t * const yy_lexer  )
{

  input_scan_state_type_t yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

      /* Prepare convenience aliases for important data.
       * These aliases can only be used directly within actions, not
       * in other functions, even those defined in sections 1 or 3. */
#     define YY_TEXT (yy_lexer->yy_text)
#     define YY_LENG (yy_lexer->yy_leng)
#     define YY_GET_BOL() (input_scan_get_bol(yy_lexer))
#     define YY_READ_CHARACTER() (input_scan_read_character(yy_lexer))
#     define YY_UNREAD_CHARACTER(c) input_scan_unread_character(yy_lexer, c)
#     define YY_INPUT_STREAM (yy_lexer->yy_input_stream)
#     define YY_OUTPUT_STREAM (yy_lexer->yy_output_stream)


#line 101 "input-scan.lex"

  static int bracelevel, didadef, indented_code;
  static int doing_rule_action = false;
  static int option_sense;
  static int doing_start_conditions = false;

  int doing_codeblock = false;
  int i;
  Char nmdef[MAXLINE], myesc();


#line 1457 "input-scan.lex.c"

  if (yy_lexer->yy_need_init) {
    yy_lexer->yy_need_init = 0;

    if (!yy_lexer->yy_current_buffer) {
      yy_lexer->yy_current_buffer =
        input_scan_create_buffer(yy_lexer, yy_lexer->yy_input_stream, YY_DEFAULT_BUF_ALLOC_SIZE);
      if (!yy_lexer->yy_current_buffer) {
        /* Error already reported, just try to get out. */
        return 0;
      }
    }

    yy_load_current_buffer_state(yy_lexer);

  }

  /* Loop over all tokens in the input until end-of-file. */
  while (1) {

    yy_cp = yy_lexer->yy_buf_cur_pos;

    /* Support of yy_text. */
    *yy_cp = yy_lexer->yy_hold_char;

    /* yy_bp points to the position in yy_buffer of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yy_lexer->yy_start_state;
    yy_current_state += YY_GET_BOL();
yy_match:
    do
    {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
      {
        yy_lexer->yy_last_accepting_state = yy_current_state;
        yy_lexer->yy_last_accepting_cpos = yy_cp;
      }
      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
      {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 681 )
          yy_c = yy_meta[(unsigned int) yy_c];
      }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      ++yy_cp;
    }
    while ( yy_current_state != 680 );
    yy_cp = yy_lexer->yy_last_accepting_cpos;
    yy_current_state = yy_lexer->yy_last_accepting_state;

yy_find_action:
    yy_act = yy_accept[yy_current_state];

    YY_DO_BEFORE_ACTION;


do_action:      /* This label is used only to access EOF actions. */


    switch (yy_act) { /* beginning of action switch */

      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yy_lexer->yy_hold_char;
      yy_cp = yy_lexer->yy_last_accepting_cpos;
      yy_current_state = yy_lexer->yy_last_accepting_state;
      goto yy_find_action;


case 1:
YY_RULE_SETUP
#line 113 "input-scan.lex"
{
                          check_smflex_version_specified();
                          indented_code = true;
                          YY_SET_START_CONDITION(CODEBLOCK);
                        }
#line 1539 "input-scan.lex.c"
  YY_BREAK
case 2:
YY_RULE_SETUP
#line 118 "input-scan.lex"
{
                          /* This is allowed before %smflex. */
                          ++linenum;
                          add_action("\n");
                        }
#line 1549 "input-scan.lex.c"
  YY_BREAK
case 3:
YY_RULE_SETUP
#line 123 "input-scan.lex"
{
                          /* This is allowed before %smflex. */
                          ++linenum;
                          ACTION_ECHO;
                        }
#line 1559 "input-scan.lex.c"
  YY_BREAK
case 4:
YY_RULE_SETUP
#line 128 "input-scan.lex"
{
                          /* This is allowed before %smflex. */
                          ACTION_ECHO;
                          yy_push_start_condition(yy_lexer, COMMENT);
                        }
#line 1569 "input-scan.lex.c"
  YY_BREAK
case 5:
YY_RULE_SETUP
#line 133 "input-scan.lex"
{
                          /* This is allowed before %smflex. */
                          yy_push_start_condition(yy_lexer, LINEDIR);
                        }
#line 1578 "input-scan.lex.c"
  YY_BREAK
case 6:
YY_RULE_SETUP
#line 137 "input-scan.lex"
{
                          /* About to emit SC #defines, which must be
                           * in output file context. */
                          check_smflex_version_specified();
                          add_action(yy_output_file_line_directive);
                          doing_start_conditions = true;
                          return SCDECL;
                        }
#line 1591 "input-scan.lex.c"
  YY_BREAK
case 7:
YY_RULE_SETUP
#line 145 "input-scan.lex"
{
                          check_smflex_version_specified();
                          add_action(yy_output_file_line_directive);
                          doing_start_conditions = true;
                          return XSCDECL;
                        }
#line 1602 "input-scan.lex.c"
  YY_BREAK
case 8:
YY_RULE_SETUP
#line 151 "input-scan.lex"
{
                          check_smflex_version_specified();
                          ++ linenum;
                          line_directive_out_src();
                          indented_code = false;
                          YY_SET_START_CONDITION(CODEBLOCK);
                        }
#line 1614 "input-scan.lex.c"
  YY_BREAK

case 9:
YY_RULE_SETUP
#line 159 "input-scan.lex"
/* discard */
#line 1621 "input-scan.lex.c"
  YY_BREAK

case 10:
YY_RULE_SETUP
#line 161 "input-scan.lex"
{
                          check_smflex_version_specified();
                          sectnum = 2;
                          bracelevel = 0;
                          mark_defs1();
                          line_directive_out_src();
                          YY_SET_START_CONDITION(SECT2PROLOG);
                          return SECTEND;
                        }
#line 1636 "input-scan.lex.c"
  YY_BREAK

case 11:
YY_RULE_SETUP
#line 171 "input-scan.lex"
{
                          check_smflex_version_specified();

                          /* We could emit lots or nothing while
                           * processing options.  It has to be treated
                           * as non-source. */
                          add_action(yy_output_file_line_directive);
                          YY_SET_START_CONDITION(OPTION);
                          return OPTION_OP;
                        }
#line 1652 "input-scan.lex.c"
  YY_BREAK

case 12:
YY_RULE_SETUP
#line 182 "input-scan.lex"
{
                          parse_smflex_version(YY_TEXT+8);
                          ++linenum;
                          add_action("\n");
                        }
#line 1663 "input-scan.lex.c"
  YY_BREAK

case 13:
YY_RULE_SETUP
#line 188 "input-scan.lex"
{
                          synerr( _( "unrecognized '%' directive" ) );
                          YY_SET_START_CONDITION(RECOVER);
                        }
#line 1673 "input-scan.lex.c"
  YY_BREAK

case 14:
YY_RULE_SETUP
#line 193 "input-scan.lex"
{
                          check_smflex_version_specified();
                          strcpy(nmstr, YY_TEXT);
                          didadef = false;
                          YY_SET_START_CONDITION(PICKUPDEF);
                        }
#line 1685 "input-scan.lex.c"
  YY_BREAK

case 15:
YY_RULE_SETUP
#line 200 "input-scan.lex"
RETURNNAME;
#line 1692 "input-scan.lex.c"
  YY_BREAK
case 16:
YY_RULE_SETUP
#line 201 "input-scan.lex"
{
                          ++linenum;
                          if (doing_start_conditions) {
                            /* We switched to output #line scope when we
                             * started processing these.  Return to
                             * input file scope. */
                            line_directive_out_src();
                            doing_start_conditions = false;
                          }
                          else {
                            ACTION_ECHO;
                          }
                        }
#line 1710 "input-scan.lex.c"
  YY_BREAK




case 17:
YY_RULE_SETUP
#line 218 "input-scan.lex"
ACTION_ECHO; yy_pop_start_condition(yy_lexer);
#line 1720 "input-scan.lex.c"
  YY_BREAK
case 18:
YY_RULE_SETUP
#line 219 "input-scan.lex"
ACTION_ECHO;
#line 1726 "input-scan.lex.c"
  YY_BREAK
case 19:
YY_RULE_SETUP
#line 220 "input-scan.lex"
ACTION_ECHO;
#line 1732 "input-scan.lex.c"
  YY_BREAK
case 20:
YY_RULE_SETUP
#line 221 "input-scan.lex"
++linenum; ACTION_ECHO;
#line 1738 "input-scan.lex.c"
  YY_BREAK



case 21:
YY_RULE_SETUP
#line 225 "input-scan.lex"
yy_pop_start_condition(yy_lexer);
#line 1747 "input-scan.lex.c"
  YY_BREAK
case 22:
YY_RULE_SETUP
#line 226 "input-scan.lex"
linenum = myctoi( YY_TEXT );
#line 1753 "input-scan.lex.c"
  YY_BREAK

case 23:
YY_RULE_SETUP
#line 228 "input-scan.lex"
{
                          flex_free((void *) infilename);
                          infilename = copy_string(YY_TEXT + 1);
                          infilename[strlen(infilename) - 1] = '\0';
                        }
#line 1764 "input-scan.lex.c"
  YY_BREAK
case 24:
YY_RULE_SETUP
#line 233 "input-scan.lex"
/* ignore spurious characters */
#line 1770 "input-scan.lex.c"
  YY_BREAK



case 25:
YY_RULE_SETUP
#line 237 "input-scan.lex"
{
                          ++linenum;
                          ADD_ACTION_NL();
                          YY_SET_START_CONDITION(INITIAL);
                        }
#line 1783 "input-scan.lex.c"
  YY_BREAK

case 26:
YY_RULE_SETUP
#line 243 "input-scan.lex"
ACTION_ECHO;
#line 1790 "input-scan.lex.c"
  YY_BREAK

case 27:
YY_RULE_SETUP
#line 245 "input-scan.lex"
{
                          ++linenum;
                          ACTION_ECHO;
                          if (indented_code)
                            YY_SET_START_CONDITION(INITIAL);
                        }
#line 1802 "input-scan.lex.c"
  YY_BREAK




case 28:
YY_RULE_SETUP
#line 255 "input-scan.lex"
/* separates name and definition */
#line 1812 "input-scan.lex.c"
  YY_BREAK

case 29:
YY_RULE_SETUP
#line 257 "input-scan.lex"
{
                          strcpy((char *) nmdef, YY_TEXT);

                          /* Skip trailing whitespace. */
                          for (i = strlen((char *) nmdef) - 1;
                               i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t'); --i);

                          nmdef[i + 1] = '\0';

                          ndinstal(nmstr, nmdef);
                          didadef = true;
                        }
#line 1830 "input-scan.lex.c"
  YY_BREAK

case 30:
YY_RULE_SETUP
#line 270 "input-scan.lex"
{
                          if (!didadef)
                            synerr(_("incomplete name definition"));
                          YY_SET_START_CONDITION(INITIAL);
                          ++linenum;
                          ADD_ACTION_NL();
                        }
#line 1843 "input-scan.lex.c"
  YY_BREAK




case 31:
YY_RULE_SETUP
#line 281 "input-scan.lex"
{
                          ++linenum;

                          /* Return to source context after processing
                           * a line of options. */
                          line_directive_out_src();
                          YY_SET_START_CONDITION(INITIAL);
                        }
#line 1860 "input-scan.lex.c"
  YY_BREAK
case 32:
YY_RULE_SETUP
#line 289 "input-scan.lex"
option_sense = true;
#line 1866 "input-scan.lex.c"
  YY_BREAK

case 33:
YY_RULE_SETUP
#line 291 "input-scan.lex"
return '=';
#line 1873 "input-scan.lex.c"
  YY_BREAK

case 34:
YY_RULE_SETUP
#line 293 "input-scan.lex"
option_sense = ! option_sense;
#line 1880 "input-scan.lex.c"
  YY_BREAK

case 35:
YY_RULE_SETUP
#line 295 "input-scan.lex"
csize = option_sense ? 128 : 256;
#line 1887 "input-scan.lex.c"
  YY_BREAK
case 36:
YY_RULE_SETUP
#line 296 "input-scan.lex"
csize = option_sense ? 256 : 128;
#line 1893 "input-scan.lex.c"
  YY_BREAK

case 37:
YY_RULE_SETUP
#line 298 "input-scan.lex"
long_align = option_sense;
#line 1900 "input-scan.lex.c"
  YY_BREAK
case 38:
YY_RULE_SETUP
#line 299 "input-scan.lex"
backing_up_report = option_sense;
#line 1906 "input-scan.lex.c"
  YY_BREAK
case 39:
YY_RULE_SETUP
#line 300 "input-scan.lex"
interactive = ! option_sense;
#line 1912 "input-scan.lex.c"
  YY_BREAK
case 40:
YY_RULE_SETUP
#line 301 "input-scan.lex"
cpp_interface = option_sense;
#line 1918 "input-scan.lex.c"
  YY_BREAK
case 41:
YY_RULE_SETUP
#line 302 "input-scan.lex"
caseins = ! option_sense;
#line 1924 "input-scan.lex.c"
  YY_BREAK
case 42:
YY_RULE_SETUP
#line 303 "input-scan.lex"
caseins = option_sense;
#line 1930 "input-scan.lex.c"
  YY_BREAK
case 43:
YY_RULE_SETUP
#line 304 "input-scan.lex"
option_debug = option_sense;
#line 1936 "input-scan.lex.c"
  YY_BREAK
case 44:
YY_RULE_SETUP
#line 305 "input-scan.lex"
option_suppress_default_rule = ! option_sense;
#line 1942 "input-scan.lex.c"
  YY_BREAK
case 45:
YY_RULE_SETUP
#line 306 "input-scan.lex"
useecs = option_sense;
#line 1948 "input-scan.lex.c"
  YY_BREAK
case 46:
YY_RULE_SETUP
#line 307 "input-scan.lex"
synerr(_("\"fast\" has been renamed to \"jacobson\""));
#line 1954 "input-scan.lex.c"
  YY_BREAK
case 47:
YY_RULE_SETUP
#line 308 "input-scan.lex"
option_flex_compat = option_sense;
#line 1960 "input-scan.lex.c"
  YY_BREAK
case 48:
YY_RULE_SETUP
#line 309 "input-scan.lex"
{
                          useecs = usemecs = false;
                          fulltbl = true;
                        }
#line 1969 "input-scan.lex.c"
  YY_BREAK
case 49:
YY_RULE_SETUP
#line 313 "input-scan.lex"
interactive = option_sense;
#line 1975 "input-scan.lex.c"
  YY_BREAK
case 50:
YY_RULE_SETUP
#line 314 "input-scan.lex"
{
                          useecs = usemecs = false;
                          jacobson = true;
                        }
#line 1984 "input-scan.lex.c"
  YY_BREAK
case 51:
YY_RULE_SETUP
#line 318 "input-scan.lex"
option_main = option_sense;
#line 1990 "input-scan.lex.c"
  YY_BREAK
case 52:
YY_RULE_SETUP
#line 319 "input-scan.lex"
usemecs = option_sense;
#line 1996 "input-scan.lex.c"
  YY_BREAK
case 53:
YY_RULE_SETUP
#line 320 "input-scan.lex"
performance_report += option_sense ? 1 : -1;
#line 2002 "input-scan.lex.c"
  YY_BREAK
case 54:
YY_RULE_SETUP
#line 321 "input-scan.lex"
use_read = option_sense;
#line 2008 "input-scan.lex.c"
  YY_BREAK
case 55:
YY_RULE_SETUP
#line 322 "input-scan.lex"
option_reject = option_sense;
#line 2014 "input-scan.lex.c"
  YY_BREAK
case 56:
YY_RULE_SETUP
#line 323 "input-scan.lex"
option_stack = option_sense;
#line 2020 "input-scan.lex.c"
  YY_BREAK
case 57:
YY_RULE_SETUP
#line 324 "input-scan.lex"
printstats = option_sense;
#line 2026 "input-scan.lex.c"
  YY_BREAK
case 58:
YY_RULE_SETUP
#line 325 "input-scan.lex"
nowarn = ! option_sense;
#line 2032 "input-scan.lex.c"
  YY_BREAK
case 59:
YY_RULE_SETUP
#line 326 "input-scan.lex"
option_yylineno = option_sense;
#line 2038 "input-scan.lex.c"
  YY_BREAK
case 60:
YY_RULE_SETUP
#line 327 "input-scan.lex"
option_yymore = option_sense;
#line 2044 "input-scan.lex.c"
  YY_BREAK

case 61:
YY_RULE_SETUP
#line 329 "input-scan.lex"
option_yy_read_character      = option_sense;
#line 2051 "input-scan.lex.c"
  YY_BREAK
case 62:
YY_RULE_SETUP
#line 330 "input-scan.lex"
option_yy_scan_string         = option_sense;
#line 2057 "input-scan.lex.c"
  YY_BREAK
case 63:
YY_RULE_SETUP
#line 331 "input-scan.lex"
option_yy_scan_bytes          = option_sense;
#line 2063 "input-scan.lex.c"
  YY_BREAK
case 64:
YY_RULE_SETUP
#line 332 "input-scan.lex"
option_yy_scan_buffer         = option_sense;
#line 2069 "input-scan.lex.c"
  YY_BREAK
case 65:
YY_RULE_SETUP
#line 333 "input-scan.lex"
option_yy_unread_character    = option_sense;
#line 2075 "input-scan.lex.c"
  YY_BREAK

case 66:
YY_RULE_SETUP
#line 335 "input-scan.lex"
return OPT_OUTFILE;
#line 2082 "input-scan.lex.c"
  YY_BREAK
case 67:
YY_RULE_SETUP
#line 336 "input-scan.lex"
return OPT_PREFIX;
#line 2088 "input-scan.lex.c"
  YY_BREAK
case 68:
YY_RULE_SETUP
#line 337 "input-scan.lex"
return OPT_YYCLASS;
#line 2094 "input-scan.lex.c"
  YY_BREAK
case 69:
YY_RULE_SETUP
#line 338 "input-scan.lex"
return OPT_YY_LEX_NAME;
#line 2100 "input-scan.lex.c"
  YY_BREAK
case 70:
YY_RULE_SETUP
#line 339 "input-scan.lex"
return OPT_YY_LEX_PARAMETERS;
#line 2106 "input-scan.lex.c"
  YY_BREAK

case 71:
YY_RULE_SETUP
#line 341 "input-scan.lex"
{
                          strcpy(nmstr, YY_TEXT + 1);
                          nmstr[strlen(nmstr) - 1] = '\0';
                          return NAME;
                        }
#line 2117 "input-scan.lex.c"
  YY_BREAK

case 72:
YY_RULE_SETUP
#line 347 "input-scan.lex"
{
                          format_synerr(_("unrecognized %%option: %s"), YY_TEXT);
                          YY_SET_START_CONDITION(RECOVER);
                        }
#line 2127 "input-scan.lex.c"
  YY_BREAK


case 73:
YY_RULE_SETUP
#line 353 "input-scan.lex"
++linenum; ADD_ACTION_NL(); YY_SET_START_CONDITION(INITIAL);
#line 2135 "input-scan.lex.c"
  YY_BREAK



case 74:
YY_RULE_SETUP
#line 357 "input-scan.lex"
++bracelevel; YY_LESS_TEXT( 2 );      /* eat only %{ */
#line 2144 "input-scan.lex.c"
  YY_BREAK
case 75:
YY_RULE_SETUP
#line 358 "input-scan.lex"
--bracelevel; YY_LESS_TEXT( 2 );      /* eat only %} */
#line 2150 "input-scan.lex.c"
  YY_BREAK

case 76:
YY_RULE_SETUP
#line 360 "input-scan.lex"
ACTION_ECHO;    /* indented code in prolog */
#line 2157 "input-scan.lex.c"
  YY_BREAK

case 77:
YY_RULE_SETUP
#line 362 "input-scan.lex"
{       /* non-indented code */
                          if (bracelevel <= 0) {   /* not in %{ ... %} */
                            YY_LESS_TEXT(0);       /* put it all back */
                            input_scan_set_bol(yy_lexer, 1);
                            mark_prolog();
                            YY_SET_START_CONDITION(SECT2);
                          }
                          else
                            ACTION_ECHO;
                        }
#line 2173 "input-scan.lex.c"
  YY_BREAK

case 78:
YY_RULE_SETUP
#line 373 "input-scan.lex"
ACTION_ECHO;
#line 2180 "input-scan.lex.c"
  YY_BREAK
case 79:
YY_RULE_SETUP
#line 374 "input-scan.lex"
++linenum; ACTION_ECHO;
#line 2186 "input-scan.lex.c"
  YY_BREAK

case YY_STATE_EOF(SECT2PROLOG):
#line 376 "input-scan.lex"
{
                          mark_prolog();
                          sectnum = 0;
                          YY_TERMINATE(); /* to stop the parser */
                        }
#line 2196 "input-scan.lex.c"
  YY_BREAK



case 80:
YY_RULE_SETUP
#line 384 "input-scan.lex"
{       /* allow blank lines in section 2 */
                          ++linenum;
                          ADD_ACTION_NL();
                        }
#line 2208 "input-scan.lex.c"
  YY_BREAK

case 81:
YY_RULE_SETUP
#line 389 "input-scan.lex"
{
                          indented_code = false;
                          doing_codeblock = true;
                          bracelevel = 1;
                          YY_SET_START_CONDITION(PERCENT_BRACE_ACTION);
                        }
#line 2220 "input-scan.lex.c"
  YY_BREAK

case 82:
YY_RULE_SETUP
#line 396 "input-scan.lex"
YY_SET_START_CONDITION(SC); return '<';
#line 2227 "input-scan.lex.c"
  YY_BREAK
case 83:
YY_RULE_SETUP
#line 397 "input-scan.lex"
return '^';
#line 2233 "input-scan.lex.c"
  YY_BREAK
case 84:
YY_RULE_SETUP
#line 398 "input-scan.lex"
YY_SET_START_CONDITION(QUOTE); return '"';
#line 2239 "input-scan.lex.c"
  YY_BREAK
case 85:
*yy_cp = yy_lexer->yy_hold_char; /* undo effects of setting up yy_text */
yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yy_text again */
YY_RULE_SETUP
#line 399 "input-scan.lex"
YY_SET_START_CONDITION(NUM); return '{';
#line 2248 "input-scan.lex.c"
  YY_BREAK
case 86:
*yy_cp = yy_lexer->yy_hold_char; /* undo effects of setting up yy_text */
yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yy_text again */
YY_RULE_SETUP
#line 400 "input-scan.lex"
return '$';
#line 2257 "input-scan.lex.c"
  YY_BREAK

case 87:
YY_RULE_SETUP
#line 402 "input-scan.lex"
{
                          bracelevel = 1;
                          YY_SET_START_CONDITION(PERCENT_BRACE_ACTION);

                          if (in_rule) {
                            doing_rule_action = true;
                            in_rule = false;
                            return '\n';
                          }
                        }
#line 2273 "input-scan.lex.c"
  YY_BREAK
case 88:
YY_RULE_SETUP
#line 412 "input-scan.lex"
{
                          /* There is a problem with #line numbers and
                           * continued actions, at least when the
                           * pattern is <<EOF>>, because we emit a line
                           * directive pointing at the source file
                           * before we realize the action is continued,
                           * and hence will not have any action code.
                           * So, emit another #line directive pointing
                           * back at the output file to cancel the
                           * effect of the first one.
                           *
                           * Test case: test/continued-action2.lex */
                          add_action(yy_output_file_line_directive);

                          continued_action = true;
                          ++linenum;
                          return '\n';
                        }
#line 2296 "input-scan.lex.c"
  YY_BREAK

case 89:
YY_RULE_SETUP
#line 431 "input-scan.lex"
{
                          YY_LESS_TEXT(YY_LENG - 2); /* put back '/', '*' */
                          bracelevel = 0;
                          continued_action = false;
                          YY_SET_START_CONDITION(ACTION);
                        }
#line 2308 "input-scan.lex.c"
  YY_BREAK

case 90:
YY_RULE_SETUP
#line 438 "input-scan.lex"
/* allow indented rules */
#line 2315 "input-scan.lex.c"
  YY_BREAK

case 91:
YY_RULE_SETUP
#line 440 "input-scan.lex"
{
                          /* This rule is separate from the one below because
                           * otherwise we get variable trailing context, so
                           * we can't build the scanner using -C{f,J}.
                           */
                          bracelevel = 0;
                          continued_action = false;
                          YY_SET_START_CONDITION(ACTION);

                          if (in_rule) {
                            doing_rule_action = true;
                            in_rule = false;
                            return '\n';
                          }
                        }
#line 2336 "input-scan.lex.c"
  YY_BREAK

case 92:
YY_RULE_SETUP
#line 456 "input-scan.lex"
{
                          bracelevel = 0;
                          continued_action = false;
                          YY_SET_START_CONDITION(ACTION);
                          YY_UNREAD_CHARACTER('\n');      /* so <ACTION> sees it */

                          if (in_rule) {
                            doing_rule_action = true;
                            in_rule = false;
                            return '\n';
                          }
                        }
#line 2354 "input-scan.lex.c"
  YY_BREAK

#line 2357 "input-scan.lex.c"
case 93:
case 94:
YY_RULE_SETUP
#line 470 "input-scan.lex"
return EOF_OP;
#line 2363 "input-scan.lex.c"
  YY_BREAK

case 95:
YY_RULE_SETUP
#line 472 "input-scan.lex"
{
                          sectnum = 3;
                          YY_SET_START_CONDITION(SECT3);
                          YY_TERMINATE(); /* to stop the parser */
                        }
#line 2374 "input-scan.lex.c"
  YY_BREAK

case 96:
YY_RULE_SETUP
#line 478 "input-scan.lex"
{
                          int cclval;

                          strcpy(nmstr, YY_TEXT);

                          /* Check to see if we've already encountered this
                           * ccl.
                           */
                          if ((cclval = ccllookup((Char *) nmstr)) != 0) {
                            if (YY_READ_CHARACTER() != ']')
                              synerr(_("bad character class"));

                            yylval = cclval;
                            ++cclreuse;
                            return PREVCCL;
                          }
                          else {
                            /* We fudge a bit.  We know that this ccl will
                             * soon be numbered as lastccl + 1 by cclinit.
                             */
                            cclinstal((Char *) nmstr, lastccl + 1);

                            /* Push back everything but the leading bracket
                             * so the ccl can be rescanned.
                             */
                            YY_LESS_TEXT(1);

                            YY_SET_START_CONDITION(FIRSTCCL);
                            return '[';
                          }
                        }
#line 2411 "input-scan.lex.c"
  YY_BREAK

case 97:
YY_RULE_SETUP
#line 510 "input-scan.lex"
{
                          Char *nmdefptr;
                          Char *ndlookup();

                          strcpy(nmstr, YY_TEXT + 1);
                          nmstr[YY_LENG - 2] = '\0'; /* chop trailing brace */

                          if ((nmdefptr = ndlookup(nmstr)) == 0)
                            format_synerr(_("undefined definition {%s}"), nmstr);

                          else {
                            /* push back name surrounded by ()'s */
                            int len = strlen((char *) nmdefptr);

                            /* don't use ()'s after all */
                            if (nmdefptr[0] == '^' ||
                                (len > 0 && nmdefptr[len - 1] == '$')) {
                              PUT_BACK_STRING((char *) nmdefptr, 0);

                              if (nmdefptr[0] == '^')
                                YY_SET_START_CONDITION(CARETISBOL);
                            }

                            else {
                              YY_UNREAD_CHARACTER(')');
                              PUT_BACK_STRING((char *) nmdefptr, 0);
                              YY_UNREAD_CHARACTER('(');
                            }
                          }
                        }
#line 2447 "input-scan.lex.c"
  YY_BREAK

case 98:
YY_RULE_SETUP
#line 541 "input-scan.lex"
return (unsigned char) YY_TEXT[0];
#line 2454 "input-scan.lex.c"
  YY_BREAK
case 99:
YY_RULE_SETUP
#line 542 "input-scan.lex"
RETURNCHAR;
#line 2460 "input-scan.lex.c"
  YY_BREAK




case 100:
YY_RULE_SETUP
#line 547 "input-scan.lex"
return (unsigned char) YY_TEXT[0];
#line 2470 "input-scan.lex.c"
  YY_BREAK
case 101:
YY_RULE_SETUP
#line 548 "input-scan.lex"
YY_SET_START_CONDITION(SECT2); return '>';
#line 2476 "input-scan.lex.c"
  YY_BREAK
case 102:
*yy_cp = yy_lexer->yy_hold_char; /* undo effects of setting up yy_text */
yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yy_text again */
YY_RULE_SETUP
#line 549 "input-scan.lex"
YY_SET_START_CONDITION(CARETISBOL); return '>';
#line 2485 "input-scan.lex.c"
  YY_BREAK
case 103:
YY_RULE_SETUP
#line 550 "input-scan.lex"
RETURNNAME;
#line 2491 "input-scan.lex.c"
  YY_BREAK
case 104:
YY_RULE_SETUP
#line 551 "input-scan.lex"
{
                          format_synerr(_("bad <start condition>: %s"), YY_TEXT);
                        }
#line 2499 "input-scan.lex.c"
  YY_BREAK


case 105:
YY_RULE_SETUP
#line 556 "input-scan.lex"
YY_SET_START_CONDITION(SECT2); return '^';
#line 2507 "input-scan.lex.c"
  YY_BREAK



case 106:
YY_RULE_SETUP
#line 560 "input-scan.lex"
RETURNCHAR;
#line 2516 "input-scan.lex.c"
  YY_BREAK
case 107:
YY_RULE_SETUP
#line 561 "input-scan.lex"
YY_SET_START_CONDITION(SECT2); return '"';
#line 2522 "input-scan.lex.c"
  YY_BREAK

case 108:
YY_RULE_SETUP
#line 563 "input-scan.lex"
{
                          synerr(_("missing quote"));
                          YY_SET_START_CONDITION(SECT2);
                          ++linenum;
                          ADD_ACTION_NL();
                          return '"';
                        }
#line 2535 "input-scan.lex.c"
  YY_BREAK




case 109:
*yy_cp = yy_lexer->yy_hold_char; /* undo effects of setting up yy_text */
yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yy_text again */
YY_RULE_SETUP
#line 574 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return '^';
#line 2548 "input-scan.lex.c"
  YY_BREAK
case 110:
*yy_cp = yy_lexer->yy_hold_char; /* undo effects of setting up yy_text */
yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yy_text again */
YY_RULE_SETUP
#line 575 "input-scan.lex"
return '^';
#line 2557 "input-scan.lex.c"
  YY_BREAK
case 111:
YY_RULE_SETUP
#line 576 "input-scan.lex"
YY_SET_START_CONDITION(CCL); RETURNCHAR;
#line 2563 "input-scan.lex.c"
  YY_BREAK



case 112:
*yy_cp = yy_lexer->yy_hold_char; /* undo effects of setting up yy_text */
yy_lexer->yy_buf_cur_pos = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yy_text again */
YY_RULE_SETUP
#line 580 "input-scan.lex"
return '-';
#line 2575 "input-scan.lex.c"
  YY_BREAK
case 113:
YY_RULE_SETUP
#line 581 "input-scan.lex"
RETURNCHAR;
#line 2581 "input-scan.lex.c"
  YY_BREAK
case 114:
YY_RULE_SETUP
#line 582 "input-scan.lex"
YY_SET_START_CONDITION(SECT2); return ']';
#line 2587 "input-scan.lex.c"
  YY_BREAK
case 115:
YY_RULE_SETUP
#line 583 "input-scan.lex"
{
                          synerr(_("bad character class"));
                          YY_SET_START_CONDITION(SECT2);
                          return ']';
                        }
#line 2597 "input-scan.lex.c"
  YY_BREAK



case 116:
YY_RULE_SETUP
#line 591 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_ALNUM;
#line 2606 "input-scan.lex.c"
  YY_BREAK
case 117:
YY_RULE_SETUP
#line 592 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_ALPHA;
#line 2612 "input-scan.lex.c"
  YY_BREAK
case 118:
YY_RULE_SETUP
#line 593 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_BLANK;
#line 2618 "input-scan.lex.c"
  YY_BREAK
case 119:
YY_RULE_SETUP
#line 594 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_CNTRL;
#line 2624 "input-scan.lex.c"
  YY_BREAK
case 120:
YY_RULE_SETUP
#line 595 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_DIGIT;
#line 2630 "input-scan.lex.c"
  YY_BREAK
case 121:
YY_RULE_SETUP
#line 596 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_GRAPH;
#line 2636 "input-scan.lex.c"
  YY_BREAK
case 122:
YY_RULE_SETUP
#line 597 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_LOWER;
#line 2642 "input-scan.lex.c"
  YY_BREAK
case 123:
YY_RULE_SETUP
#line 598 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_PRINT;
#line 2648 "input-scan.lex.c"
  YY_BREAK
case 124:
YY_RULE_SETUP
#line 599 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_PUNCT;
#line 2654 "input-scan.lex.c"
  YY_BREAK
case 125:
YY_RULE_SETUP
#line 600 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_SPACE;
#line 2660 "input-scan.lex.c"
  YY_BREAK
case 126:
YY_RULE_SETUP
#line 601 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_UPPER;
#line 2666 "input-scan.lex.c"
  YY_BREAK
case 127:
YY_RULE_SETUP
#line 602 "input-scan.lex"
YY_SET_START_CONDITION(CCL); return CCE_XDIGIT;
#line 2672 "input-scan.lex.c"
  YY_BREAK
case 128:
YY_RULE_SETUP
#line 603 "input-scan.lex"
{
                          format_synerr(_("bad character class expression: %s"),
                                        YY_TEXT);
                          YY_SET_START_CONDITION(CCL);
                          return CCE_ALNUM;
                        }
#line 2683 "input-scan.lex.c"
  YY_BREAK



case 129:
YY_RULE_SETUP
#line 612 "input-scan.lex"
{
                          yylval = myctoi(YY_TEXT);
                          return NUMBER;
                        }
#line 2695 "input-scan.lex.c"
  YY_BREAK

case 130:
YY_RULE_SETUP
#line 617 "input-scan.lex"
return ',';
#line 2702 "input-scan.lex.c"
  YY_BREAK
case 131:
YY_RULE_SETUP
#line 618 "input-scan.lex"
YY_SET_START_CONDITION(SECT2); return '}';
#line 2708 "input-scan.lex.c"
  YY_BREAK

case 132:
YY_RULE_SETUP
#line 620 "input-scan.lex"
{
                          synerr(_("bad character inside {}'s"));
                          YY_SET_START_CONDITION(SECT2);
                          return '}';
                        }
#line 2719 "input-scan.lex.c"
  YY_BREAK

case 133:
YY_RULE_SETUP
#line 626 "input-scan.lex"
{
                          synerr(_("missing }"));
                          YY_SET_START_CONDITION(SECT2);
                          ++linenum;
                          ADD_ACTION_NL();
                          return '}';
                        }
#line 2732 "input-scan.lex.c"
  YY_BREAK




case 134:
YY_RULE_SETUP
#line 637 "input-scan.lex"
bracelevel = 0;
#line 2742 "input-scan.lex.c"
  YY_BREAK

case 135:
YY_RULE_SETUP
#line 639 "input-scan.lex"
ACTION_ECHO; yy_push_start_condition(yy_lexer, COMMENT);
#line 2749 "input-scan.lex.c"
  YY_BREAK

case 136:
YY_RULE_SETUP
#line 641 "input-scan.lex"
ACTION_ECHO;
#line 2756 "input-scan.lex.c"
  YY_BREAK
case 137:
YY_RULE_SETUP
#line 642 "input-scan.lex"
{
                          ++ linenum;
                          ACTION_ECHO;
                          if (bracelevel == 0 ||
                              (doing_codeblock && indented_code)) {
                            if (doing_rule_action) {
                              add_action(yy_output_file_line_directive);
                              add_action("  YY_BREAK\n");
                            }

                            doing_rule_action = doing_codeblock = false;
                            YY_SET_START_CONDITION(SECT2);
                          }
                        }
#line 2775 "input-scan.lex.c"
  YY_BREAK



/* The ACTION state is where the lexer accumulates the text of
         * an action in memory, via ACTION_ECHO.  During this process,
         * nothing is reported to the parser.  Once the end of the
         * action is found, we return to the SECT2 state, at which
         * point we'll resume informing the parser of what we find. */


case 138:
YY_RULE_SETUP
#line 666 "input-scan.lex"
ACTION_ECHO; ++bracelevel;
#line 2791 "input-scan.lex.c"
  YY_BREAK
case 139:
YY_RULE_SETUP
#line 667 "input-scan.lex"
ACTION_ECHO; --bracelevel;
#line 2797 "input-scan.lex.c"
  YY_BREAK
case 140:
YY_RULE_SETUP
#line 668 "input-scan.lex"
ACTION_ECHO;
#line 2803 "input-scan.lex.c"
  YY_BREAK
case 141:
YY_RULE_SETUP
#line 669 "input-scan.lex"
ACTION_ECHO;
#line 2809 "input-scan.lex.c"
  YY_BREAK
case 142:
YY_RULE_SETUP
#line 670 "input-scan.lex"
ACTION_ECHO; /* character constant */
#line 2815 "input-scan.lex.c"
  YY_BREAK
case 143:
YY_RULE_SETUP
#line 671 "input-scan.lex"
ACTION_ECHO; YY_SET_START_CONDITION(ACTION_STRING);
#line 2821 "input-scan.lex.c"
  YY_BREAK
case 144:
YY_RULE_SETUP
#line 672 "input-scan.lex"
{
                          ++ linenum;
                          ACTION_ECHO;
                          if (bracelevel == 0) {
                            if (doing_rule_action) {
                              add_action(yy_output_file_line_directive);
                              add_action("  YY_BREAK\n");
                            }

                            doing_rule_action = false;
                            YY_SET_START_CONDITION(SECT2);
                          }
                        }
#line 2839 "input-scan.lex.c"
  YY_BREAK
case 145:
YY_RULE_SETUP
#line 685 "input-scan.lex"
ACTION_ECHO;
#line 2845 "input-scan.lex.c"
  YY_BREAK



case 146:
YY_RULE_SETUP
#line 689 "input-scan.lex"
ACTION_ECHO;
#line 2854 "input-scan.lex.c"
  YY_BREAK
case 147:
YY_RULE_SETUP
#line 690 "input-scan.lex"
ACTION_ECHO;
#line 2860 "input-scan.lex.c"
  YY_BREAK
case 148:
YY_RULE_SETUP
#line 691 "input-scan.lex"
++linenum; ACTION_ECHO;
#line 2866 "input-scan.lex.c"
  YY_BREAK
case 149:
YY_RULE_SETUP
#line 692 "input-scan.lex"
ACTION_ECHO; YY_SET_START_CONDITION(ACTION);
#line 2872 "input-scan.lex.c"
  YY_BREAK
case 150:
YY_RULE_SETUP
#line 693 "input-scan.lex"
ACTION_ECHO;
#line 2878 "input-scan.lex.c"
  YY_BREAK


case YY_STATE_EOF(COMMENT):
case YY_STATE_EOF(ACTION):
case YY_STATE_EOF(ACTION_STRING):
#line 696 "input-scan.lex"
{
                          synerr(_("EOF encountered inside an action"));
                          YY_TERMINATE();
                        }
#line 2890 "input-scan.lex.c"
  YY_BREAK


case 151:
YY_RULE_SETUP
#line 702 "input-scan.lex"
{
                          yylval = myesc((Char *) YY_TEXT);

                          if (YY_GET_START_CONDITION() == FIRSTCCL)
                            YY_SET_START_CONDITION(CCL);

                          return CHAR;
                        }
#line 2905 "input-scan.lex.c"
  YY_BREAK



case 152:
YY_RULE_SETUP
#line 713 "input-scan.lex"
out(YY_TEXT);   /* Copy section 3 to output. */
#line 2914 "input-scan.lex.c"
  YY_BREAK
case YY_STATE_EOF(SECT3):
#line 714 "input-scan.lex"
sectnum = 0; YY_TERMINATE();
#line 2919 "input-scan.lex.c"
  YY_BREAK


case 153:
YY_RULE_SETUP
#line 717 "input-scan.lex"
format_synerr(_("bad character: %s"), YY_TEXT);
#line 2927 "input-scan.lex.c"
  YY_BREAK

case 154:
YY_RULE_SETUP
#line 719 "input-scan.lex"
#line 2933 "input-scan.lex.c"
  YY_ERROR(yy_err_no_rule_matches, NULL /*detail*/);
  return 0;
#line 2936 "input-scan.lex.c"
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(SECT2):
case YY_STATE_EOF(CODEBLOCK):
case YY_STATE_EOF(PICKUPDEF):
case YY_STATE_EOF(SC):
case YY_STATE_EOF(CARETISBOL):
case YY_STATE_EOF(NUM):
case YY_STATE_EOF(QUOTE):
case YY_STATE_EOF(FIRSTCCL):
case YY_STATE_EOF(CCL):
case YY_STATE_EOF(RECOVER):
case YY_STATE_EOF(PERCENT_BRACE_ACTION):
case YY_STATE_EOF(OPTION):
case YY_STATE_EOF(LINEDIR):
  YY_TERMINATE();

/* Variant of 'yy_text' that is not a pointer to 'const'.  This is only
 * for use by the scanner internals, not user actions. */
#define YY_TEXT_NONCONST ((char*)(yy_lexer->yy_text))

      case YY_END_OF_BUFFER: {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int)(yy_cp - yy_lexer->yy_text) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = yy_lexer->yy_hold_char;

        if (yy_lexer->yy_current_buffer->yy_buf_status == YY_BUF_STATUS_NEW) {
          /* We're scanning a new file or input source.  It's
           * possible that this happened because the user
           * just pointed yy_input_stream at a new source and called
           * input_scan_lex().  If so, then we have to assure
           * consistency between yy_current_buffer and our
           * globals.  Here is the right place to do so, because
           * this is the first action (other than possibly a
           * back-up) that will match for the new input source.
           */
          yy_lexer->yy_buf_data_len = yy_lexer->yy_current_buffer->yy_buf_data_len;
          yy_lexer->yy_current_buffer->yy_input_stream = yy_lexer->yy_input_stream;
          yy_lexer->yy_current_buffer->yy_buf_status   = YY_BUF_STATUS_NORMAL;
        }

        /* Note that here we test for yy_buf_cur_pos "<=" to the position
         * of the first EOB in the buffer, since yy_buf_cur_pos will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if (yy_lexer->yy_buf_cur_pos <=
              &yy_lexer->yy_current_buffer->yy_buffer[yy_lexer->yy_buf_data_len]) {
          /* This was really a NUL. */
          input_scan_state_type_t yy_next_state;

          yy_lexer->yy_buf_cur_pos =
            YY_TEXT_NONCONST + yy_amount_of_matched_text;

          yy_current_state = yy_get_previous_state(yy_lexer);

          /* Okay, we're now positioned to make the NUL
           * transition.  We couldn't have
           * yy_get_previous_state() go ahead and do it
           * for us because it doesn't know how to deal
           * with the possibility of jamming (and we don't
           * want to build jamming into it because then it
           * will run more slowly).
           */

          yy_next_state = yy_try_NUL_trans(yy_lexer, yy_current_state);

          yy_bp = YY_TEXT_NONCONST + YY_MORE_LEN;

          if (yy_next_state) {
            /* Consume the NUL. */
            yy_cp = ++(yy_lexer->yy_buf_cur_pos);
            yy_current_state = yy_next_state;
            goto yy_match;
          }

          else {
            yy_cp = yy_lexer->yy_last_accepting_cpos;
            yy_current_state = yy_lexer->yy_last_accepting_state;
            goto yy_find_action;
          }
        }

        else {
          switch (yy_get_next_buffer(yy_lexer)) {
            case EOB_ACT_END_OF_FILE: {
              if (yy_lexer->yy_wrap_function(yy_lexer)) {
                /* Note: because we've taken care in
                 * yy_get_next_buffer() to have set up
                 * yy_text, we can now set up
                 * yy_buf_cur_pos so that if some total
                 * hoser (like smflex itself) wants to
                 * call the scanner after we return the
                 * YY_EOF_TOKEN_CODE, it'll still work - another
                 * YY_EOF_TOKEN_CODE will get returned.
                 */
                yy_lexer->yy_buf_cur_pos = YY_TEXT_NONCONST + YY_MORE_LEN;

                yy_act = YY_STATE_EOF(YY_GET_START_CONDITION());
                goto do_action;
              }

              else {
                /* The 'yy_wrap_function' should have switched buffers
                 * or called 'input_scan_restart' to activate a new input file. */
              }
              break;
            }

            case EOB_ACT_CONTINUE_SCAN:
              yy_lexer->yy_buf_cur_pos =
                YY_TEXT_NONCONST + yy_amount_of_matched_text;

              yy_current_state = yy_get_previous_state(yy_lexer);

              yy_cp = yy_lexer->yy_buf_cur_pos;
              yy_bp = YY_TEXT_NONCONST + YY_MORE_LEN;
              goto yy_match;

            case EOB_ACT_LAST_MATCH:
              yy_lexer->yy_buf_cur_pos =
                &yy_lexer->yy_current_buffer->yy_buffer[yy_lexer->yy_buf_data_len];

              yy_current_state = yy_get_previous_state(yy_lexer);

              yy_cp = yy_lexer->yy_buf_cur_pos;
              yy_bp = YY_TEXT_NONCONST + YY_MORE_LEN;
              goto yy_find_action;
          } /* switch (yy_get_next_buffer()) */
        }

        break;
      } /* case YY_END_OF_BUFFER */

      default:
        YY_ERROR(input_scan_err_internal_error, "bad action code");
        return 0;
    } /* end of action switch */
  } /* end of scanning one token */
} /* end of input_scan_lex */


STATIC_IF_CPP void input_scan_construct(input_scan_lexer_t *yy_lexer)
{
  /* Note: We do not perform any memory allocation here.  Instead,
   * allocation is deferred to 'input_scan_lex()' when 'yy_need_init==1'.
   *
   * One reason for this is to not create a read buffer needlessly
   * in the case that we will use 'input_scan_scan_buffer'.
   *
   * Another reason is if we allocate, the allocation could fail, but
   * the client has not had an opportunity to set up an error handler
   * yet. */

  yy_lexer->yy_client_data = NULL;

  yy_lexer->yy_text = NULL;
  yy_lexer->yy_leng = 0;

  yy_lexer->yy_input_stream = (input_scan_input_stream_t*)stdin;
  yy_lexer->yy_output_stream = (input_scan_output_stream_t*)stdout;

  yy_lexer->yy_read_input_function   = &input_scan_read_input_with_fread;
  yy_lexer->yy_write_output_function = &input_scan_write_output_with_fwrite;
  yy_lexer->yy_wrap_function         = &input_scan_wrap_return_1;
  yy_lexer->yy_error_function        = &input_scan_error_print_and_exit;

  yy_lexer->yy_current_buffer = NULL;

  yy_lexer->yy_error_code = input_scan_err_no_error;

  yy_lexer->yy_hold_char = 0;
  yy_lexer->yy_buf_data_len = 0;

  yy_lexer->yy_buf_cur_pos = NULL;
  yy_lexer->yy_need_init = 1;
  YY_SET_START_CONDITION(INITIAL);

  yy_lexer->yy_last_accepting_state = 0; /* This can be a pointer. */
  yy_lexer->yy_last_accepting_cpos = NULL;

  yy_lexer->yy_start_stack_cur_size = 0;
  yy_lexer->yy_start_stack_alloc_size = 0;
  yy_lexer->yy_start_stack_array = NULL;

}


STATIC_IF_CPP void input_scan_destroy(input_scan_lexer_t *yy_lexer)
{
  /* We set freed pointers to NULL for a bit of extra safety. */

  input_scan_delete_buffer(yy_lexer, yy_lexer->yy_current_buffer);
  yy_lexer->yy_current_buffer = NULL;

  yy_flex_free(yy_lexer->yy_start_stack_array);
  yy_lexer->yy_start_stack_array = NULL;
}



/* Get more data by calling 'yy_read_input_function'.  Returns a
 * non-negative integer number of bytes read (since a read error is
 * treated like a 0-length read as part of error recovery), with 0
 * signalling end of file. */
static int yy_call_read_input(input_scan_lexer_t *yy_lexer, void *dest, int size)
{
  int n;

  YY_ASSERT(size >= 1);
  if (yy_lexer->yy_current_buffer->yy_is_interactive) {
    /* Read one character at a time. */
    size = 1;
  }

  n = yy_lexer->yy_read_input_function(yy_lexer, dest, size);
  if (n < 0) {
    YY_ERROR(input_scan_err_input_error, NULL /*detail*/);

    /* Recover by pretending we saw EOF. */
    n = 0;
  }

#ifdef YY_ENABLE_DEBUG_LOG_CALL
  {
    int c = n==0? 0 : ((char*)dest)[0];
    printf("[n=%d c=%d]\n", n, c);
  }
#endif

  return n;
}


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(input_scan_lexer_t *yy_lexer)
{
  char *dest = yy_lexer->yy_current_buffer->yy_buffer;
  char *source = YY_TEXT_NONCONST;
  int number_to_move, i;
  int ret_val;

  if (yy_lexer->yy_buf_cur_pos >
        &yy_lexer->yy_current_buffer->yy_buffer[yy_lexer->yy_buf_data_len + 1]) {
    YY_ERROR(input_scan_err_internal_error, "end of buffer missed");
    return EOB_ACT_END_OF_FILE;
  }

  if (yy_lexer->yy_current_buffer->yy_fill_buffer == 0) { /* Don't try to fill the buffer, so this is an EOF. */
    if (yy_lexer->yy_buf_cur_pos - yy_lexer->yy_text - YY_MORE_LEN == 1) {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yy_lexer->yy_buf_cur_pos - yy_lexer->yy_text) - 1;

  for (i = 0; i < number_to_move; ++i) {
    *(dest++) = *(source++);
  }

  if (yy_lexer->yy_current_buffer->yy_buf_status == YY_BUF_STATUS_EOF_PENDING) {
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    yy_lexer->yy_buf_data_len = 0;
    yy_lexer->yy_current_buffer->yy_buf_data_len = 0;
  }

  else {
    int num_to_read = yy_lexer->yy_current_buffer->yy_buf_alloc_size - number_to_move - 1;

    while (num_to_read <= 0) {  /* Not enough room in the buffer - grow it. */
      /* just a shorter name for the current buffer */
      input_scan_buffer_state_t *b = yy_lexer->yy_current_buffer;

      int yy_c_buf_p_offset = (int) (yy_lexer->yy_buf_cur_pos - b->yy_buffer);

      if (b->yy_is_our_buffer) {
        int new_size;
        char *new_buffer;

        /* Check for arithemtic overflow calculating new size. */
        if (b->yy_buf_alloc_size > (INT_MAX-2) / 2) {
          YY_ERROR(yy_err_input_buffer_at_max_size, NULL /*detail*/);
          return EOB_ACT_END_OF_FILE;
        }
        new_size = b->yy_buf_alloc_size * 2;

        /* Allocate a new buffer. */
        YY_DEBUG_LOG_MEM("allocate new buffer", new_size + 2);
        new_buffer = (char*)yy_flex_alloc(new_size + 2);
        if (!new_buffer) {
          YY_ERROR(input_scan_err_out_of_memory, "while expanding input buffer");
          return EOB_ACT_END_OF_FILE;
        }

        /* Copy the old data, including the EOB characters. */
        memcpy(new_buffer, b->yy_buffer, b->yy_buf_alloc_size + 2);

        /* Release the old buffer and update the fields. */
        yy_flex_free(b->yy_buffer);
        b->yy_buffer = new_buffer;
        b->yy_buf_alloc_size = new_size;
      }
      else {
        /* This happens if we think we need more input to get a match,
         * but we are using 'input_scan_scan_buffer' and there is no more data.
         * But in that case, why did we not already see the end of
         * buffer markers? */
        YY_ERROR(input_scan_err_internal_error, "expanding un-owned input buffer");
        return EOB_ACT_END_OF_FILE;
      }

      yy_lexer->yy_buf_cur_pos = &b->yy_buffer[yy_c_buf_p_offset];

      num_to_read = yy_lexer->yy_current_buffer->yy_buf_alloc_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE) {
      num_to_read = YY_READ_BUF_SIZE;
    }

    /* Read in more data. */
    yy_lexer->yy_buf_data_len =
      yy_call_read_input(yy_lexer,
        &yy_lexer->yy_current_buffer->yy_buffer[number_to_move],
        num_to_read);

    yy_lexer->yy_current_buffer->yy_buf_data_len = yy_lexer->yy_buf_data_len;
  }

  if (yy_lexer->yy_buf_data_len == 0) {
    if (number_to_move == YY_MORE_LEN) {
      ret_val = EOB_ACT_END_OF_FILE;
      input_scan_restart(yy_lexer, yy_lexer->yy_input_stream);
    }

    else {
      ret_val = EOB_ACT_LAST_MATCH;
      yy_lexer->yy_current_buffer->yy_buf_status = YY_BUF_STATUS_EOF_PENDING;
    }
  }

  else {
    ret_val = EOB_ACT_CONTINUE_SCAN;
  }

  yy_lexer->yy_buf_data_len += number_to_move;
  yy_lexer->yy_current_buffer->yy_buffer[yy_lexer->yy_buf_data_len] = YY_END_OF_BUFFER_CHAR;
  yy_lexer->yy_current_buffer->yy_buffer[yy_lexer->yy_buf_data_len + 1] = YY_END_OF_BUFFER_CHAR;

  yy_lexer->yy_text = &yy_lexer->yy_current_buffer->yy_buffer[0];

  return ret_val;
}


/* yy_get_previous_state - get the state just before the EOB char was reached */
static input_scan_state_type_t yy_get_previous_state(input_scan_lexer_t *yy_lexer)
{
  input_scan_state_type_t yy_current_state;
  char *yy_cp;

  yy_current_state = yy_lexer->yy_start_state;
  yy_current_state += YY_GET_BOL();

  for (yy_cp = YY_TEXT_NONCONST + YY_MORE_LEN;
       yy_cp < yy_lexer->yy_buf_cur_pos;
       ++yy_cp) {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
    {
      yy_lexer->yy_last_accepting_state = yy_current_state;
      yy_lexer->yy_last_accepting_cpos = yy_cp;
    }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 681 )
        yy_c = yy_meta[(unsigned int) yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  }

  return yy_current_state;
}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans(yy_lexer, current_state);
 */
static input_scan_state_type_t yy_try_NUL_trans(input_scan_lexer_t *yy_lexer, input_scan_state_type_t yy_current_state)
{
  int yy_is_jam;
  char *yy_cp = yy_lexer->yy_buf_cur_pos;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
  {
    yy_lexer->yy_last_accepting_state = yy_current_state;
    yy_lexer->yy_last_accepting_cpos = yy_cp;
  }
  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
  {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 681 )
      yy_c = yy_meta[(unsigned int) yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 680);

  return yy_is_jam ? 0 : yy_current_state;
}


STATIC_IF_CPP void input_scan_unread_character(input_scan_lexer_t *yy_lexer, int c)
{
  char *yy_bp = YY_TEXT_NONCONST;
  char *yy_cp = yy_lexer->yy_buf_cur_pos;

  YY_API_PRECONDITION(0 <= c && c <= 255);

  /* undo effects of setting up yy_text */
  *yy_cp = yy_lexer->yy_hold_char;

  if (yy_cp < yy_lexer->yy_current_buffer->yy_buffer + 2) {
    /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = yy_lexer->yy_buf_data_len + 2;
    char *dest = &yy_lexer->yy_current_buffer->yy_buffer[
      yy_lexer->yy_current_buffer->yy_buf_alloc_size + 2];
    char *source =
      &yy_lexer->yy_current_buffer->yy_buffer[number_to_move];

    while (source > yy_lexer->yy_current_buffer->yy_buffer) {
      *--dest = *--source;
    }

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    yy_lexer->yy_current_buffer->yy_buf_data_len =
      yy_lexer->yy_buf_data_len =
        yy_lexer->yy_current_buffer->yy_buf_alloc_size;

    if (yy_cp < yy_lexer->yy_current_buffer->yy_buffer + 2) {
      YY_ERROR(input_scan_err_unread_overflow, NULL /*detail*/);
      return;
    }
  }

  *--yy_cp = (char)c;


  yy_lexer->yy_text = yy_bp;
  yy_lexer->yy_hold_char = *yy_cp;
  yy_lexer->yy_buf_cur_pos = yy_cp;
}



/* Read one character from the current input source of 'yy_lexer'. */
STATIC_IF_CPP int input_scan_read_character(input_scan_lexer_t *yy_lexer)
{
  int c;

  *(yy_lexer->yy_buf_cur_pos) = yy_lexer->yy_hold_char;

  if (*(yy_lexer->yy_buf_cur_pos) == YY_END_OF_BUFFER_CHAR) {
    /* yy_buf_cur_pos now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if (yy_lexer->yy_buf_cur_pos <
          &yy_lexer->yy_current_buffer->yy_buffer[yy_lexer->yy_buf_data_len]) {
      /* This was really a NUL. */
      *(yy_lexer->yy_buf_cur_pos) = '\0';
    }

    else { /* need more input */
      int offset = yy_lexer->yy_buf_cur_pos - yy_lexer->yy_text;
      ++(yy_lexer->yy_buf_cur_pos);

      switch (yy_get_next_buffer(yy_lexer)) {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_get_next_buffer()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input_scan_read_character(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          input_scan_restart(yy_lexer, yy_lexer->yy_input_stream);

          /* fall through */

        case EOB_ACT_END_OF_FILE: {
          if (yy_lexer->yy_wrap_function(yy_lexer)) {
            return EOF;
          }

          /* It is the responsibility of 'yy_wrap_function' to
           * have switched buffers or called 'input_scan_restart'. */

          return input_scan_read_character(yy_lexer);
        }

        case EOB_ACT_CONTINUE_SCAN:
          yy_lexer->yy_buf_cur_pos = YY_TEXT_NONCONST + offset;
          break;
      }
    }
  }

  c = *(unsigned char *)yy_lexer->yy_buf_cur_pos;   /* cast for 8-bit char's */

  /* Note: We are putting a NUL and then (in the next statement)
   * advancing 'yy_buf_cur_pos' and grabbing a new 'yy_hold_char'.
   * That means nothing will remember the character originally in
   * this spot (except for 'c', the value we are about to return).
   *
   * This means that successive 'input_scan_read_character' calls overwrite
   * characters after 'yy_text' with NULs, one by one. */
  *(yy_lexer->yy_buf_cur_pos) = '\0';     /* preserve yy_text */

  yy_lexer->yy_hold_char = *++(yy_lexer->yy_buf_cur_pos);

  yy_lexer->yy_current_buffer->yy_at_bol = (c == '\n');

  return c;
}



STATIC_IF_CPP void input_scan_restart(input_scan_lexer_t *yy_lexer, input_scan_input_stream_t *input_file)
{
  if (!yy_lexer->yy_current_buffer) {
    yy_lexer->yy_current_buffer =
      input_scan_create_buffer(yy_lexer, input_file, YY_DEFAULT_BUF_ALLOC_SIZE);
    if (!yy_lexer->yy_current_buffer) {
      return;     /* Error already reported, try to recover. */
    }

    /* Copy the cur_pos, data_len, and input_stream from current_buffer. */
    yy_load_current_buffer_state(yy_lexer);
  }
  else {
    /* This will call 'yy_load_current_buffer_state'. */
    input_scan_init_buffer(yy_lexer, yy_lexer->yy_current_buffer, input_file);
  }
}



STATIC_IF_CPP void input_scan_switch_to_buffer(input_scan_lexer_t *yy_lexer, input_scan_buffer_state_t *new_buffer)
{
  YY_API_PRECONDITION(new_buffer != NULL);

  if (yy_lexer->yy_current_buffer == new_buffer) {
    return;
  }

  if (yy_lexer->yy_current_buffer) {
    /* Replace the hold character so the old read buffer is intact. */
    *(yy_lexer->yy_buf_cur_pos) = yy_lexer->yy_hold_char;

    /* Save the duplicate fields back into the old buffer so they can
     * be restored when we later switch back. */
    yy_lexer->yy_current_buffer->yy_buf_cur_pos  = yy_lexer->yy_buf_cur_pos;
    yy_lexer->yy_current_buffer->yy_buf_data_len = yy_lexer->yy_buf_data_len;
  }

  yy_lexer->yy_current_buffer = new_buffer;

  /* Load the duplicate fields. */
  yy_load_current_buffer_state(yy_lexer);
}



/* Copy the fields from 'yy_lexer->yy_current_buffer' that are
 * duplicated in the 'input_scan_lexer_t' structure.
 *
 * Also set up 'yy_text' and 'yy_hold_char'. */
static void yy_load_current_buffer_state(input_scan_lexer_t *yy_lexer)
{
  /* Copy duplicated fields. */
  yy_lexer->yy_buf_data_len = yy_lexer->yy_current_buffer->yy_buf_data_len;
  yy_lexer->yy_buf_cur_pos  = yy_lexer->yy_current_buffer->yy_buf_cur_pos;
  yy_lexer->yy_input_stream = yy_lexer->yy_current_buffer->yy_input_stream;

  /* Set up 'yy_text'.  TODO: Why is this necessary? */
  yy_lexer->yy_text      =   yy_lexer->yy_buf_cur_pos;

  /* Establish the 'yy_hold_char' invariant. */
  yy_lexer->yy_hold_char = *(yy_lexer->yy_buf_cur_pos);
}


STATIC_IF_CPP input_scan_buffer_state_t *input_scan_create_buffer(
  input_scan_lexer_t *yy_lexer, input_scan_input_stream_t *file, int size)
{
  input_scan_buffer_state_t *b;

  b = (input_scan_buffer_state_t*)yy_flex_alloc(sizeof(input_scan_buffer_state_t));
  if (!b) {
    YY_ERROR(input_scan_err_out_of_memory, "input_scan_create_buffer: buffer structure");
    return NULL;
  }

  YY_API_PRECONDITION(size >= 0);
  YY_API_PRECONDITION(size < INT_MAX-2);

  if (size == 0) {
    /* Unspecified size becomes 'YY_DEFAULT_BUF_ALLOC_SIZE'. */
    size = YY_DEFAULT_BUF_ALLOC_SIZE;
  }
  b->yy_buf_alloc_size = size;

  /* yy_buffer has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_buffer = (char*)yy_flex_alloc(b->yy_buf_alloc_size + 2);
  if (!b->yy_buffer) {
    yy_flex_free(b);
    YY_ERROR(input_scan_err_out_of_memory, "input_scan_create_buffer: input buffer");
    return NULL;
  }

  b->yy_is_our_buffer = 1;

  input_scan_init_buffer(yy_lexer, b, file);

  return b;
}



STATIC_IF_CPP void input_scan_delete_buffer(
  input_scan_lexer_t *yy_lexer, input_scan_buffer_state_t *b)
{
  if (!b) {
    return;
  }

  if (yy_lexer->yy_current_buffer == b) {
    /* Return to the state of not having a current buffer. */
    yy_lexer->yy_current_buffer = NULL;
  }

  if (b->yy_is_our_buffer) {
    yy_flex_free((void*)b->yy_buffer);
  }

  yy_flex_free((void*)b);
}



static void input_scan_init_buffer(input_scan_lexer_t *yy_lexer,
                           input_scan_buffer_state_t *b, input_scan_input_stream_t *file)
{
  b->yy_input_stream = file;
  b->yy_fill_buffer = 1;

  /* Flush *after* setting the input stream of 'b', because 'flush'
   * calls 'load' which copies the input stream into 'yy_lexer'. */
  input_scan_flush_buffer(yy_lexer, b);

  b->yy_is_interactive = 0;
  YY_DEBUG_LOG_CALL("default behavior, so yy_is_interactive is", b->yy_is_interactive);
}


STATIC_IF_CPP void input_scan_flush_buffer(
  input_scan_lexer_t *yy_lexer, input_scan_buffer_state_t *b)
{
  if (!b) {
    return;
  }

  b->yy_buf_data_len = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_buffer[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_buffer[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_cur_pos = &b->yy_buffer[0];

  b->yy_at_bol = 1;
  b->yy_buf_status = YY_BUF_STATUS_NEW;

  if (b == yy_lexer->yy_current_buffer) {
    yy_load_current_buffer_state(yy_lexer);
  }
}









STATIC_IF_CPP void yy_push_start_condition(input_scan_lexer_t *yy_lexer, int new_cond)
{
  YY_ASSERT(0 <= yy_lexer->yy_start_stack_cur_size &&
                 yy_lexer->yy_start_stack_cur_size <= yy_lexer->yy_start_stack_alloc_size);

  if (yy_lexer->yy_start_stack_cur_size >= yy_lexer->yy_start_stack_alloc_size) {
    int new_alloc_size;
    int *new_array;

    /* Check for overflow. */
    if (yy_lexer->yy_start_stack_alloc_size >
          (INT_MAX/(int)sizeof(int) - YY_START_STACK_INCR) / 2) {
      YY_ERROR(input_scan_err_condition_stack_overflow, NULL /*detail*/);
      return;
    }
    new_alloc_size =
      yy_lexer->yy_start_stack_alloc_size * 2 + YY_START_STACK_INCR;

    /* Allocate. */
    new_array = (int*)yy_flex_alloc(new_alloc_size * sizeof(int));
    if (!new_array) {
      YY_ERROR(input_scan_err_out_of_memory, "yy_push_start_condition: expanding state stack");
      return;
    }

    /* Copy. */
    if (yy_lexer->yy_start_stack_array) {
      memcpy(new_array,
             yy_lexer->yy_start_stack_array,
             yy_lexer->yy_start_stack_alloc_size * sizeof(int));

      /* Release old storage. */
      yy_flex_free(yy_lexer->yy_start_stack_array);
    }

    /* Everything succeeded.  Update the data members. */
    yy_lexer->yy_start_stack_alloc_size = new_alloc_size;
    yy_lexer->yy_start_stack_array = new_array;
  }

  yy_lexer->yy_start_stack_array[yy_lexer->yy_start_stack_cur_size++] =
    YY_GET_START_CONDITION();

  YY_SET_START_CONDITION(new_cond);
}



STATIC_IF_CPP void yy_pop_start_condition(input_scan_lexer_t *yy_lexer)
{
  if (yy_lexer->yy_start_stack_cur_size <= 0) {
    YY_ERROR(input_scan_err_api_misuse, "yy_pop_start_condition: start stack is empty");
    return;
  }

  --(yy_lexer->yy_start_stack_cur_size);
  YY_SET_START_CONDITION(yy_lexer->yy_start_stack_array[yy_lexer->yy_start_stack_cur_size]);
}



STATIC_IF_CPP int yy_top_start_condition(input_scan_lexer_t const *yy_lexer)
{
  if (yy_lexer->yy_start_stack_cur_size <= 0) {
    YY_ERROR(input_scan_err_api_misuse, "yy_top_start_condition: state stack is empty");
    return INITIAL;
  }

  return yy_lexer->yy_start_stack_array[yy_lexer->yy_start_stack_cur_size - 1];
}



STATIC_IF_CPP int yy_condition_stack_is_empty(input_scan_lexer_t const *yy_lexer)
{
  return yy_lexer->yy_start_stack_cur_size <= 0;
}



STATIC_IF_CPP input_scan_error_code_t input_scan_get_error(input_scan_lexer_t const *yy_lexer)
{
  return yy_lexer->yy_error_code;
}



/* Table of error messages. */
static char const * const yy_error_string_table[] = {
  "no error",
  "internal error",
  "API misused",
  "error reading input source",
  "token is too large and input buffer cannot be expanded",
  "token is too large and input buffer is already at maximum size",
  "no rule matches the input text",
  "out of memory",
  "no space in buffer to unread a character",
  "cannot push a state because the start condition stack is at its maximum size",
};


STATIC_IF_CPP char const *input_scan_error_string(input_scan_error_code_t code)
{
  /* Make sure the table is kept in sync with the enumeration. */
  YY_STATIC_ASSERT(sizeof(yy_error_string_table) /
                   sizeof(yy_error_string_table[0]) == input_scan_err_num_error_codes);

  /* Forcing an unsigned comparison takes care of negatives while also
   * avoiding a possible compiler warning if the underlying type of
   * 'input_scan_error_code_t' is unsigned and we explicitly checked against 0. */
  if ((unsigned)code < (unsigned)input_scan_err_num_error_codes) {
    return yy_error_string_table[code];
  }
  else {
    return "invalid error code";
  }
}



STATIC_IF_CPP void input_scan_error_print_and_exit(input_scan_lexer_t const *yy_lexer,
  input_scan_error_code_t code, char const *detail)
{
  if (detail) {
    fprintf(stderr, "smflex scanner error: %s: %s\n",
            input_scan_error_string(code), detail);
  }
  else {
    fprintf(stderr, "smflex scanner error: %s\n", input_scan_error_string(code));
  }

  /* For fatal-ish error messages, I want to have the best chance of
   * seeing the message before the program dies. */
  fflush(stderr);

  /* I do not allow these error codes to be directly customized (for
   * example with an #ifdef) because I want to limit the exposed
   * configuration surface.  If an 'smflex' user wants different codes,
   * they should define their own error handling function. */

  if (code == input_scan_err_internal_error ||
      code == input_scan_err_api_misuse) {
    /* These codes indicate there is a bug in the program. */
    exit(4);
  }
  else {
    /* The rest are "normal" errors, such as an input read error or when
     * some implementation limit is hit. */
    exit(2);
  }
}




STATIC_IF_CPP void input_scan_less_text(input_scan_lexer_t *yy_lexer, int new_yy_leng)
{
  if (!YY_API_PRECONDITION(0 <= new_yy_leng &&
                                new_yy_leng <= yy_lexer->yy_leng)) {
    return;
  }

  /* Undo effects of setting up yy_text. */
  YY_TEXT_NONCONST[yy_lexer->yy_leng] = yy_lexer->yy_hold_char;

  /* Move the end-of-token pointer to the specified location. */
  yy_lexer->yy_buf_cur_pos = YY_TEXT_NONCONST + new_yy_leng;
  yy_lexer->yy_leng = new_yy_leng;

  /* Re-insert the temporary NUL terminator. */
  yy_lexer->yy_hold_char = *(yy_lexer->yy_buf_cur_pos);
  *(yy_lexer->yy_buf_cur_pos) = '\0';
}



/* When this symbol is defined, enable mechanisms to inject failures
 * into the allocator routines. */
#ifdef YY_ALLOCATOR_FAILURE_INJECTION
/* Number of 'alloc' calls before we inject a failure. */
unsigned yy_alloc_failure_countdown = 0;
#endif

static long yy_num_allocated_objects = 0;

static void *yy_flex_alloc(int size)
{
  void *ret;

  YY_DEBUG_LOG_MEM("yy_flex_alloc", size);
#ifdef YY_ALLOCATOR_FAILURE_INJECTION
  if (--yy_alloc_failure_countdown == 0) {
    YY_DEBUG_LOG_MEM("alloc_fail", size);
    return NULL;
  }
#endif

  ret = malloc(size);
  if (ret) {
    yy_num_allocated_objects++;
  }
  return ret;
}

static void yy_flex_free(void *ptr)
{
  if (ptr) {
    yy_num_allocated_objects--;
    YY_DEBUG_LOG_MEM("yy_flex_free", yy_num_allocated_objects);
  }
  free(ptr);
}


STATIC_IF_CPP void input_scan_check_for_memory_leaks()
{
  if (yy_num_allocated_objects != 0) {
    fprintf(stderr, "input_scan_check_for_memory_leaks: leaked %ld objects\n",
            yy_num_allocated_objects);
    exit(4);
  }
}



STATIC_IF_CPP void input_scan_set_start_condition(input_scan_lexer_t *yy_lexer, int state)
{
  YY_SET_START_CONDITION(state);
}



STATIC_IF_CPP int input_scan_get_start_condition(input_scan_lexer_t const *yy_lexer)
{
  return YY_GET_START_CONDITION();
}



int input_scan_read_input_with_fread(input_scan_lexer_t *yy_lexer,
  void *dest, int size)
{
  FILE *input_file = (FILE*)(yy_lexer->yy_input_stream);

  int n = fread(dest, 1, size, input_file);
  if (n == 0 && ferror(input_file)) {
    return -1;
  }
  return n;
}




int input_scan_write_output_with_fwrite(input_scan_lexer_t *yy_lexer,
  void const *dest, int size)
{
  FILE *output_file = (FILE*)(yy_lexer->yy_output_stream);

  size_t n = fwrite(dest, 1, size, output_file);
  if (n == (size_t)size) {
    return size;
  }
  else {
    return -1;
  }
}


int input_scan_wrap_return_1(input_scan_lexer_t *yy_lexer)
{
  return 1;      /* No more files. */
}





/* Remove undocumented YY_XXX macros I don't want leaking into the
 * namespace of section 3. */
#undef YY_ERROR
#undef YY_WRAPPER_OBJECT
#undef YY_TEXT_NONCONST
#undef YY_DEFAULT_BUF_ALLOC_SIZE

/* Remove documented YY_XXX macros, as they cannot be used in section 3.
 * Most of them have yy_XXX alternatives that accept 'input_scan_lexer_t*'. */
#undef YY_SET_START_CONDITION
#undef YY_GET_START_CONDITION
#undef YY_LESS_TEXT
#undef YY_CURRENT_BUFFER
#undef YY_FLUSH_CURRENT_BUFFER
#undef YY_GET_BOL
#undef YY_ECHO
#undef YY_TERMINATE
#undef YY_TEXT
#undef YY_LENG
#undef YY_READ_CHARACTER
#undef YY_UNREAD_CHARACTER
#undef YY_INPUT_STREAM
#undef YY_OUTPUT_STREAM

/* After this point, the user's section 3 code appears. */
#line 719 "input-scan.lex"



input_scan_lexer_t input_lexer;


/* set_input_file - open the given file (if NULL, stdin) for scanning */
void set_input_file(char *file)
{
  infilename = copy_string(file);
  input_lexer.yy_input_stream = fopen(infilename, "r");

  if (input_lexer.yy_input_stream == NULL) {
    lerrsf(_("can't open %s"), file);
  }

  linenum = 1;
}


int flexscan()
{
  return input_scan_lex(&input_lexer);
}


/* Wrapper routines for accessing the scanner's malloc routines. */
void *flex_alloc(size_t size)
{
  return (void *) malloc(size);
}

void *flex_realloc(void *ptr, size_t size)
{
  return (void *) realloc(ptr, size);
}

void flex_free(void *ptr)
{
  if (ptr)
    free(ptr);
}
