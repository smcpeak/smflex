/* File created from generated-scanner.skl via encode.sh */

/* NULL-terminated array of NUL-terminated lines, *without* line
 * terminators. */
const char *scanner_skl_contents[] = {
  "%# generated-scanner.skl: Skeleton of generated scanner.",
  "%#",
  "%# NOTE: There are three modes the skeleton file supports:",
  "%#",
  "%#   1. C interface scanner, compiled with a C compiler.",
  "%#",
  "%#   2. C interface scanner, compiled with a C++ compiler.",
  "%#",
  "%#   3. C++ interface scanner, compiled with a C++ compiler.",
  "%#",
  "%# The choice of scanner interface is controlled by \"%option c++\",",
  "%# which in the skeleton affects whether \"%if cpp_interface\" is emitted.",
  "%#",
  "%# The choice of compiler determines whether __cplusplus is defined",
  "%# while the scanner output is being compiled, but is not known to",
  "%# smflex at generation time (except that if \"%option c++\" is used,",
  "%# then we can assume a C++ compiler will be used).",
  "/* yy_scanner_file_name */",
  "/* A lexical scanner generated by smflex. */",
  "/* DO NOT EDIT MANUALLY. */",
  "",
  "#include \"yy_header_file_name\"     /* yy_lexer_t */",
  "",
  "#include <assert.h>          /* assert */",
  "#include <limits.h>          /* INT_MAX */",
  "#include <stdlib.h>          /* malloc, free, realloc, exit */",
  "#include <string.h>          /* strlen, memcpy */",
  "%if use_read",
  "#include <unistd.h>          /* read, needed for -Cr option */",
  "%endif",
  "%if cpp_interface",
  "#include <new>               /* std::bad_alloc */",
  "#include <sstream>           /* std::ostringstream */",
  "#include <string>            /* std::string */",
  "%endif",
  "",
  "/* Defined within a generated scanner. */",
  "#define SMFLEX_SCANNER",
  "",
  "/* Version of smflex used to generate this scanner. */",
  "#define YY_SMFLEX_MAJOR_VERSION 1",
  "#define YY_SMFLEX_MINOR_VERSION 0",
  "",
  "",
  "/* Returned value from yy_lex() upon end-of-file.  This macro is used",
  " * to make the occurrences more readily identifiable; the value must",
  " * be specifically 0 because that is what the documentation uses. */",
  "#define YY_EOF_TOKEN_CODE 0",
  "",
  "/* Promotes a possibly negative, possibly signed char to an unsigned",
  " * integer for use as an array index.  If the signed char is negative,",
  " * we want to instead treat it as an 8-bit unsigned char, hence the",
  " * double cast.",
  " */",
  "#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)",
  "",
  "/* Maximum value of 'size_t'.  C99 has SIZE_MAX but I am targeting",
  " * C89 as my lowest common denomnator. */",
  "#define YY_SIZE_T_MAX ((size_t)(-1))",
  "",
  "/* Enter a start condition. */",
  "#define YY_SET_START_STATE(s) (yy_lexer->yy_start_state = 1 + 2 * (s))",
  "",
  "/* Translate the current start state into a value that can be later handed",
  " * to YY_SET_START_STATE to return to the state. */",
  "#define YY_GET_START_STATE() ((yy_lexer->yy_start_state - 1) / 2)",
  "",
  "/* Action number for EOF rule of a given start state. */",
  "#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)",
  "",
  "/* Special action meaning \"start processing a new file\". */",
  "#define YY_NEW_FILE yy_restart(yy_lexer, yy_lexer->yy_input_stream)",
  "",
  "/* Two copies of this character are placed into the read buffer,",
  " * right after the data that was read from the input.  This is used",
  " * to signal the state machine logic that it has reached the end of",
  " * the buffered data, so it must stop and read more. */",
  "#define YY_END_OF_BUFFER_CHAR 0",
  "",
  "/* Size of default input buffer. */",
  "#define YY_BUF_SIZE 16384",
  "",
  "/* Define a macro that, when enabled, causes certain printouts to go",
  " * to stdout.  The intent is to use this as part of tests in order to",
  " * be able to see what some of the internals are doing when there is",
  " * not a less intrusive method available.  The symbol",
  " * 'YY_ENABLE_DEBUG_LOG_CALL' must be passed as a -D argument on the",
  " * compiler command line to activate this. */",
  "#ifdef YY_ENABLE_DEBUG_LOG_CALL",
  "%if !cpp_interface",
  "#  define YY_DEBUG_LOG_CALL(call, val) \\",
  "     printf(\"[%s: %d]\\n\", call, (int)(val))",
  "%else",
  "#  define YY_DEBUG_LOG_CALL(call, val) \\",
  "     (std::cout << '[' << (call) << \": \" << (int)(val) << \"]\\n\")",
  "%endif",
  "#else",
  "#  define YY_DEBUG_LOG_CALL(str, val) ((void)0)",
  "#endif",
  "",
  "/* A switch to control memory-related debug logs. */",
  "#ifdef YY_ENABLE_DEBUG_LOG_MEM",
  "%if !cpp_interface",
  "#  define YY_DEBUG_LOG_MEM(str, val) \\",
  "     printf(\"[%s: %d]\\n\", str, (int)(val))",
  "%else",
  "#  define YY_DEBUG_LOG_MEM(str, val) \\",
  "     (std::cout << '[' << (str) << \": \" << (int)(val) << \"]\\n\")",
  "%endif",
  "#else",
  "#  define YY_DEBUG_LOG_MEM(str, val) ((void)0)",
  "#endif",
  "",
  "/* This macro is meant to be used for a label that the code generator",
  " * emits but is not sure will be used.  Its purpose is to suppress any",
  " * warnings about the label in case it is, in fact, unused. */",
  "#ifndef YY_POSSIBLY_UNUSED_LABEL",
  "#  ifdef __GNUC__",
  "#    define YY_POSSIBLY_UNUSED_LABEL(label) \\",
  "       label: __attribute__((__unused__));",
  "#  else",
  "#    define YY_POSSIBLY_UNUSED_LABEL(label) label:",
  "#  endif",
  "#endif",
  "",
  "/* This macro is placed in front of the declarations of functions that",
  " * may or may not be used, depending on what the user's actions do. */",
  "#ifndef YY_POSSIBLY_UNUSED_FUNCTION",
  "#  ifdef __GNUC__",
  "#    define YY_POSSIBLY_UNUSED_FUNCTION __attribute__((__unused__))",
  "#  else",
  "#    define YY_POSSIBLY_UNUSED_FUNCTION /*nothing*/",
  "#  endif",
  "#endif",
  "",
  "/* This is used for internal integrity checks that do not have a",
  " * significant impact on performance, so should be fine to leave",
  " * enabled in production usage.  If YY_ASSERT fails, it means there",
  " * is a bug in smflex or the API has been misused. */",
  "#ifndef YY_ASSERT",
  "#  define YY_ASSERT(cond) assert(cond)",
  "#endif",
  "",
  "/* Assert something at compile time. */",
  "#ifndef YY_STATIC_ASSERT",
  "#  define YY_STATIC_ASSERT(cond) ((void)(int (*)[((cond)? +1 : -1)])0)",
  "#endif",
  "",
  "/* Check an API precondition.  If it fails, call YY_ERROR.  If that",
  " * returns, the form evaluates to 0; otherwise it evaluates to 1. */",
  "#ifndef YY_API_PRECONDITION",
  "#  define YY_API_PRECONDITION(cond) \\",
  "     ((cond)? 1 : (YY_ERROR(yy_err_api_misuse, #cond), 0))",
  "#endif",
  "",
  "#define EOB_ACT_CONTINUE_SCAN 0",
  "#define EOB_ACT_END_OF_FILE 1",
  "#define EOB_ACT_LAST_MATCH 2",
  "",
  "/* Return all but the first 'n' matched characters back to the input",
  " * stream.  This definition only works in section 3 where the local",
  " * variables 'yy_cp' and 'yy_bp' are present. */",
  "#define YY_LESS_TEXT(new_yy_leng) \\",
  "  if (1) { \\",
  "    /* Undo effects of setting up yy_text. */ \\",
  "    *yy_cp = yy_lexer->yy_hold_char; \\",
  "    yy_lexer->yy_c_buf_p = yy_cp = yy_bp + new_yy_leng - YY_MORE_ADJ; \\",
  "    YY_DO_BEFORE_ACTION; /* set up yy_text again */ \\",
  "  } else ((void)0)",
  "",
  "/* This structure contains the buffer state for a particular input",
  " * source.  By buffering, it allows efficient access to the bytes in",
  " * that source one at a time; its principal operations are to get the",
  " * next character and to put a character back. */",
  "struct yy_buffer_state_struct {",
  "  yy_input_stream_t *yy_input_file;",
  "",
  "  /* Pointer to the beginning of the input buffer.  The allocated",
  "   * space in the buffer is 'yy_buf_size+2'.  The buffer is owned",
  "   * by this structure if 'yy_is_our_buffer'. */",
  "  char *yy_ch_buf;",
  "",
  "  char *yy_buf_pos;               /* current position in input buffer */",
  "",
  "  /* Size of input buffer in bytes, not including room for EOB",
  "   * characters.",
  "   */",
  "  size_t yy_buf_size;",
  "",
  "  /* Number of characters read into yy_ch_buf, not including EOB",
  "   * characters.",
  "   */",
  "  int yy_n_chars;",
  "",
  "  /* Whether we \"own\" the buffer - i.e., we know we created it,",
  "   * and can realloc() it to grow it, and should free() it to",
  "   * delete it.",
  "   */",
  "  int yy_is_our_buffer;",
  "",
  "  /* Whether this is an \"interactive\" input source; if so, and",
  "   * if we're using stdio for input, then we want to use getc()",
  "   * instead of fread(), to make sure we stop fetching input after",
  "   * each newline.",
  "   */",
  "  int yy_is_interactive;",
  "",
  "  /* Whether we're considered to be at the beginning of a line.",
  "   * If so, '^' rules will be active on the next match, otherwise",
  "   * not.",
  "   */",
  "  int yy_at_bol;",
  "",
  "  /* Whether to try to fill the input buffer when we reach the",
  "   * end of it.",
  "   */",
  "  int yy_fill_buffer;",
  "",
  "  int yy_buffer_status;",
  "#define YY_BUFFER_NEW 0",
  "#define YY_BUFFER_NORMAL 1",
  "  /* When an EOF's been seen but there's still some text to process",
  "   * then we mark the buffer as YY_EOF_PENDING, to indicate that we",
  "   * shouldn't try reading from the input source any more.  We might",
  "   * still have a bunch of tokens to match, though, because of",
  "   * possible backing-up.",
  "   *",
  "   * When we actually see the EOF, we change the status to \"new\"",
  "   * (via yy_restart()), so that the user can continue scanning by",
  "   * just pointing 'yy_input_stream' at a new input file.",
  "   */",
  "#define YY_BUFFER_EOF_PENDING 2",
  "};",
  "",
  "/* We provide macros for accessing buffer states in case in the",
  " * future we want to put the buffer states in a more general",
  " * \"scanner state\".",
  " */",
  "#define YY_CURRENT_BUFFER (yy_lexer->yy_current_buffer)",
  "",
  "",
  "#define YY_FLUSH_CURRENT_BUFFER yy_flush_buffer(yy_lexer, yy_lexer->yy_current_buffer)",
  "",
  "static void *yy_flex_alloc(size_t);",
  "static void yy_flex_free(void *);",
  "",
  "",
  "%if cpp_interface",
  "namespace {",
  "",
  "/* Class that automatically frees a pointer with 'yy_flex_free'. */",
  "class yyAutoFree {",
  "public:      /* data */",
  "  /* Pointer to free. */",
  "  void *m_ptr;",
  "",
  "private:     /* not implemented methods */",
  "  yyAutoFree(yyAutoFree const &);",
  "  yyAutoFree& operator= (yyAutoFree const &);",
  "",
  "public:      /* methods */",
  "  yyAutoFree(void *ptr)",
  "    : m_ptr(ptr)",
  "  {}",
  "",
  "  ~yyAutoFree()",
  "  {",
  "    if (m_ptr) {",
  "      yy_flex_free(m_ptr);",
  "    }",
  "  }",
  "",
  "  /* Remove the pointer so it will not be freed. */",
  "  void clear()",
  "  {",
  "    m_ptr = NULL;",
  "  }",
  "};",
  "",
  "} /* anonymous namespace */",
  "%endif",
  "",
  "",
  "static void yy_load_current_buffer_state(yy_lexer_t *yy_lexer);",
  "static void yy_init_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *b,",
  "                           yy_input_stream_t *file);",
  "",
  "/* If 'yy_lexer' does not have a current buffer, create one.",
  " * Return false if allocation failed.*/",
  "static int yy_create_buffer_if_needed(yy_lexer_t *yy_lexer)",
  "{",
  "  if (!yy_lexer->yy_current_buffer) {",
  "    yy_lexer->yy_current_buffer =",
  "      yy_create_buffer(yy_lexer, yy_lexer->yy_input_stream, YY_BUF_SIZE);",
  "    if (!yy_lexer->yy_current_buffer) {",
  "      return 0;",
  "    }",
  "  }",
  "  return 1;",
  "}",
  "",
  "",
  "void yy_set_interactive(yy_lexer_t *yy_lexer, int is_interactive)",
  "{",
  "  if (!yy_create_buffer_if_needed(yy_lexer)) {",
  "    return;",
  "  }",
  "  YY_DEBUG_LOG_CALL(\"setting yy_is_interactive due to yy_set_interactive\", is_interactive);",
  "  yy_lexer->yy_current_buffer->yy_is_interactive = is_interactive;",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_set_interactive(int is_interactive)",
  "{",
  "  yy_set_interactive(&yym_lexer_state, is_interactive);",
  "}",
  "%endif",
  "",
  "",
  "int yy_get_bol(yy_lexer_t const *yy_lexer)",
  "{",
  "  if (!yy_lexer->yy_current_buffer) {",
  "    /* When we start reading, BOL will be true. */",
  "    return 1;",
  "  }",
  "  else {",
  "    return yy_lexer->yy_current_buffer->yy_at_bol;",
  "  }",
  "}",
  "",
  "%if cpp_interface",
  "bool yyFlexLexer::yym_get_bol() const",
  "{",
  "  return !!yy_get_bol(&yym_lexer_state);",
  "}",
  "%endif",
  "",
  "",
  "",
  "void yy_set_bol(yy_lexer_t *yy_lexer, int at_bol)",
  "{",
  "  if (!yy_create_buffer_if_needed(yy_lexer)) {",
  "    return;",
  "  }",
  "  yy_lexer->yy_current_buffer->yy_at_bol = at_bol;",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_set_bol(bool at_bol)",
  "{",
  "  yy_set_bol(&yym_lexer_state, at_bol);",
  "}",
  "%endif",
  "",
  "",
  "%if cpp_interface",
  "/* Pointer to the C++ wrapper object. */",
  "#define YY_WRAPPER_OBJECT ((yyFlexLexer*)(yy_lexer->yy_client_data))",
  "",
  "static int yy_wrap_delegate(yy_lexer_t *yy_lexer)",
  "{",
  "  return YY_WRAPPER_OBJECT->yym_wrap();",
  "}",
  "",
  "int yyFlexLexer::yym_wrap()",
  "{",
  "  return 1;    /* No more input. */",
  "}",
  "",
  "",
  "static int yy_read_input_delegate(yy_lexer_t *yy_lexer, void *dest, int size)",
  "{",
  "  return YY_WRAPPER_OBJECT->yym_read_input(dest, size);",
  "}",
  "",
  "static int yy_write_output_delegate(yy_lexer_t *yy_lexer,",
  "                                    void const *dest, int size)",
  "{",
  "  return YY_WRAPPER_OBJECT->yym_write_output(dest, size);",
  "}",
  "",
  "static void yy_error_delegate(yy_lexer_t const *yy_lexer,",
  "                              yy_error_code_t code, char const *detail)",
  "{",
  "  YY_WRAPPER_OBJECT->yym_error(code, detail);",
  "}",
  "%endif # cpp_interface",
  "",
  "",
  "%% yy_text_def: yy_text/yy_input_stream/yy_output_stream/yy_state_type_t/yy_lineno etc. def's & init go here",
  "",
  "static yy_state_type_t yy_get_previous_state(yy_lexer_t *yy_lexer);",
  "static yy_state_type_t yy_try_NUL_trans(yy_lexer_t *yy_lexer, yy_state_type_t current_state);",
  "static int yy_get_next_buffer(yy_lexer_t *yy_lexer);",
  "",
  "/* Done after the current pattern has been matched and before the",
  " * corresponding action - sets up yy_text.",
  " */",
  "#define YY_DO_BEFORE_ACTION \\",
  "  yy_lexer->yy_text = yy_bp; \\",
  "%% yymore_yy_text: code to fiddle yy_text and yy_leng for yymore() goes here",
  "  yy_lexer->yy_hold_char = *yy_cp; \\",
  "  *yy_cp = '\\0'; \\",
  "  yy_lexer->yy_c_buf_p = yy_cp;",
  "",
  "%% dfa_tables: data tables for the DFA and the user's section 1 definitions go here",
  "",
  "/* Macros after this point can all be overridden by user definitions in",
  " * section 1.",
  " */",
  "",
  "",
  "/* Amount of stuff to slurp up with each read. */",
  "#ifndef YY_READ_BUF_SIZE",
  "#  define YY_READ_BUF_SIZE 8192",
  "#endif",
  "",
  "/* Copy whatever the last rule matched to the output stream. */",
  "#ifndef YY_ECHO",
  "#  define YY_ECHO ((void)yy_lexer->yy_write_output_function(yy_lexer, \\",
  "                           yy_lexer->yy_text, yy_lexer->yy_leng))",
  "#endif",
  "",
  "/* No semi-colon after return; correct usage is to write \"YY_TERMINATE();\" -",
  " * we don't want an extra ';' after the \"return\" because that will cause",
  " * some compilers to complain about unreachable statements.",
  " */",
  "#ifndef YY_TERMINATE",
  "#  define YY_TERMINATE() return YY_EOF_TOKEN_CODE",
  "#endif",
  "",
  "/* Number of entries by which start-condition stack grows, on top of",
  " * doubling every time. */",
  "#ifndef YY_START_STACK_INCR",
  "#  define YY_START_STACK_INCR 25",
  "#endif",
  "",
  "",
  "/* Report an error.  This may return, in which case the scanner will",
  " * attempt to return control to the client so it can clean up. */",
  "#define YY_ERROR(code, detail) \\",
  "  (yy_call_error_function(yy_lexer, code, detail))",
  "",
  "static void yy_call_error_function(yy_lexer_t const *yy_lexer,",
  "  yy_error_code_t code, char const *detail)",
  "{",
  "  /* Record the error in the lexer object, but only the first one. */",
  "  if (yy_lexer->yy_error_code == yy_err_no_error) {",
  "    /* Cast away constness.  I do not want to remove 'const' from the",
  "     * functions that are conceptually just queries, nor do I want to",
  "     * forgo enforcing prerequisites, nor do I want to abandon saving",
  "     * the error code. */",
  "    ((yy_lexer_t*)yy_lexer)->yy_error_code = code;",
  "  }",
  "",
  "  yy_lexer->yy_error_function(yy_lexer, code, detail);",
  "}",
  "",
  "",
  "/* Code executed at the beginning of each rule, after yy_text and yy_leng",
  " * have been set up.",
  " */",
  "#ifndef YY_USER_ACTION",
  "#  define YY_USER_ACTION",
  "#endif",
  "",
  "/* Code executed at the end of each rule. */",
  "#ifndef YY_BREAK",
  "#  define YY_BREAK break;",
  "#endif",
  "",
  "%% YY_RULE_SETUP: YY_RULE_SETUP definition goes here",
  "",
  "%if !cpp_interface",
  "int yy_lex(yy_lexer_t * const yy_lexer)",
  "%else",
  "%if option_yyclass",
  "int option_yyclass_name::yym_lex()",
  "%else",
  "int yyFlexLexer::yym_lex()",
  "%endif",
  "%endif",
  "{",
  "%if cpp_interface",
  "  /* Define a local 'yy_lexer' that plays the same role as the parameter",
  "   * 'yy_lexer' in the C interface.  By making this 'const' the compiler",
  "   * will hopefully understand it is just an alias for a member. */",
  "  yy_lexer_t * const yy_lexer = &(this->yym_lexer_state);",
  "%endif",
  "",
  "  yy_state_type_t yy_current_state;",
  "  char *yy_cp, *yy_bp;",
  "  int yy_act;",
  "",
  "      /* Prepare convenience aliases for important data.",
  "       * These aliases can only be used directly within actions, not",
  "       * in other functions, even those defined in sections 1 or 3. */",
  "#     define yytext (yy_lexer->yy_text)",
  "#     define yyleng (yy_lexer->yy_leng)",
  "#     define YY_GET_BOL() (yy_get_bol(yy_lexer))",
  "%if option_yy_read_character",
  "#     define YY_READ_CHARACTER() (yy_read_character(yy_lexer))",
  "%endif",
  "%if option_yy_unread_character",
  "#     define YY_UNREAD_CHARACTER(c) yy_unread_character(yy_lexer, c)",
  "%endif",
  "#     define yyin (yy_lexer->yy_input_stream)",
  "#     define yyout (yy_lexer->yy_output_stream)",
  "%if do_yylineno",
  "#     define yylineno (yy_lexer->yy_lineno)",
  "%endif",
  "",
  "%if option_flex_compat",
  "      /* flex compatibility aliases. */",
  "#     define ECHO YY_ECHO",
  "#     define yyless(n) YY_LESS_TEXT(n)",
  "#     define BEGIN(s) YY_SET_START_STATE(s)",
  "#     define YY_START YY_GET_START_STATE()",
  "#     define YY_AT_BOL() YY_GET_BOL()",
  "#     define yyterminate() YY_TERMINATE()",
  "%if option_yy_read_character",
  "#     define input() YY_READ_CHARACTER()",
  "#     define yyinput() YY_READ_CHARACTER()",
  "%endif",
  "%if option_yy_unread_character",
  "#     define unput(c) YY_UNREAD_CHARACTER(c)",
  "%endif",
  "%endif # option_flex_compat",
  "",
  "%% user_local_decl: user's declarations go here",
  "",
  "  if (yy_lexer->yy_init) {",
  "    yy_lexer->yy_init = 0;",
  "",
  "#ifdef YY_USER_INIT",
  "    YY_USER_INIT;",
  "#endif",
  "",
  "    if (!yy_lexer->yy_start_state) {",
  "      yy_lexer->yy_start_state = 1;   /* first start state */",
  "    }",
  "",
  "    if (!yy_lexer->yy_current_buffer) {",
  "      yy_lexer->yy_current_buffer =",
  "        yy_create_buffer(yy_lexer, yy_lexer->yy_input_stream, YY_BUF_SIZE);",
  "      if (!yy_lexer->yy_current_buffer) {",
  "        /* Error already reported, just try to get out. */",
  "        return 0;",
  "      }",
  "    }",
  "",
  "    yy_load_current_buffer_state(yy_lexer);",
  "  }",
  "",
  "  /* Loop over all tokens in the input until end-of-file. */",
  "  while (1) {",
  "%% yymore_loop_top: yymore()-related code goes here",
  "    yy_cp = yy_lexer->yy_c_buf_p;",
  "",
  "    /* Support of yy_text. */",
  "    *yy_cp = yy_lexer->yy_hold_char;",
  "",
  "    /* yy_bp points to the position in yy_ch_buf of the start of",
  "     * the current run.",
  "     */",
  "    yy_bp = yy_cp;",
  "",
  "%% find_next_match: code to set up and find next match goes here",
  "",
  "yy_find_action:",
  "%% find_action_number: code to find the action number goes here",
  "",
  "    YY_DO_BEFORE_ACTION;",
  "",
  "%if do_yylineno",
  "    if (yy_act != YY_END_OF_BUFFER) {",
  "      int yyl;",
  "      for (yyl = 0; yyl < yy_lexer->yy_leng; ++yyl) {",
  "        if (yy_lexer->yy_text[yyl] == '\\n') {",
  "          ++(yy_lexer->yy_lineno);",
  "        }",
  "      }",
  "    }",
  "%endif",
  "",
  "do_action:      /* This label is used only to access EOF actions. */",
  "",
  "%if option_debug",
  "    if (yy_lexer->yy_flex_debug) {",
  "%if !cpp_interface",
  "      if (yy_act == 0)",
  "        fprintf(stderr, \"--scanner backing up\\n\");",
  "      else if (yy_act < YY_NUM_RULES)",
  "        fprintf(stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\",",
  "                yy_rule_linenum[yy_act], yy_lexer->yy_text);",
  "      else if (yy_act == YY_NUM_RULES)",
  "        fprintf(stderr, \"--accepting default rule (\\\"%s\\\")\\n\",",
  "                yy_lexer->yy_text);",
  "      else if (yy_act == YY_NUM_RULES+1)",
  "        fprintf(stderr, \"--(end of buffer or a NUL)\\n\");",
  "      else",
  "        fprintf(stderr, \"--EOF (start condition %d)\\n\", YY_GET_START_STATE());",
  "%else",
  "      if (yy_act == 0)",
  "        std::cerr << \"--scanner backing up\\n\";",
  "      else if (yy_act < YY_NUM_RULES)",
  "        std::cerr << \"--accepting rule at line \" << yy_rule_linenum[yy_act] <<",
  "                     \" (\\\"\" << yy_lexer->yy_text << \"\\\")\\n\";",
  "      else if (yy_act == YY_NUM_RULES)",
  "        std::cerr << \"--accepting default rule (\\\"\" << yy_lexer->yy_text << \"\\\")\\n\";",
  "      else if (yy_act == YY_NUM_RULES+1)",
  "        std::cerr << \"--(end of buffer or a NUL)\\n\";",
  "      else",
  "        std::cerr << \"--EOF (start condition \" << YY_GET_START_STATE() << \")\\n\";",
  "%endif",
  "    }",
  "%endif",
  "",
  "    switch (yy_act) { /* beginning of action switch */",
  "",
  "%% user_actions: user rule actions from section 2 go here",
  "",
  "      case YY_END_OF_BUFFER: {",
  "        /* Amount of text matched not including the EOB char. */",
  "        int yy_amount_of_matched_text = (int)(yy_cp - yy_lexer->yy_text) - 1;",
  "",
  "        /* Undo the effects of YY_DO_BEFORE_ACTION. */",
  "        *yy_cp = yy_lexer->yy_hold_char;",
  "",
  "        if (yy_lexer->yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW) {",
  "          /* We're scanning a new file or input source.  It's",
  "           * possible that this happened because the user",
  "           * just pointed yy_input_stream at a new source and called",
  "           * yy_lex().  If so, then we have to assure",
  "           * consistency between yy_current_buffer and our",
  "           * globals.  Here is the right place to do so, because",
  "           * this is the first action (other than possibly a",
  "           * back-up) that will match for the new input source.",
  "           */",
  "          yy_lexer->yy_n_chars = yy_lexer->yy_current_buffer->yy_n_chars;",
  "          yy_lexer->yy_current_buffer->yy_input_file = yy_lexer->yy_input_stream;",
  "          yy_lexer->yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;",
  "        }",
  "",
  "        /* Note that here we test for yy_c_buf_p \"<=\" to the position",
  "         * of the first EOB in the buffer, since yy_c_buf_p will",
  "         * already have been incremented past the NUL character",
  "         * (since all states make transitions on EOB to the",
  "         * end-of-buffer state).  Contrast this with the test",
  "         * in input().",
  "         */",
  "        if (yy_lexer->yy_c_buf_p <=",
  "              &yy_lexer->yy_current_buffer->yy_ch_buf[yy_lexer->yy_n_chars]) {",
  "          /* This was really a NUL. */",
  "          yy_state_type_t yy_next_state;",
  "",
  "          yy_lexer->yy_c_buf_p = yy_lexer->yy_text + yy_amount_of_matched_text;",
  "",
  "          yy_current_state = yy_get_previous_state(yy_lexer);",
  "",
  "          /* Okay, we're now positioned to make the NUL",
  "           * transition.  We couldn't have",
  "           * yy_get_previous_state() go ahead and do it",
  "           * for us because it doesn't know how to deal",
  "           * with the possibility of jamming (and we don't",
  "           * want to build jamming into it because then it",
  "           * will run more slowly).",
  "           */",
  "",
  "          yy_next_state = yy_try_NUL_trans(yy_lexer, yy_current_state);",
  "",
  "          yy_bp = yy_lexer->yy_text + YY_MORE_ADJ;",
  "",
  "          if (yy_next_state) {",
  "            /* Consume the NUL. */",
  "            yy_cp = ++(yy_lexer->yy_c_buf_p);",
  "            yy_current_state = yy_next_state;",
  "            goto yy_match;",
  "          }",
  "",
  "          else {",
  "%% back_up: code to do back-up for compressed tables and set up yy_cp goes here",
  "            goto yy_find_action;",
  "          }",
  "        }",
  "",
  "        else {",
  "          switch (yy_get_next_buffer(yy_lexer)) {",
  "            case EOB_ACT_END_OF_FILE: {",
  "              yy_lexer->yy_did_buffer_switch_on_eof = 0;",
  "",
  "              if (yy_lexer->yy_wrap_function(yy_lexer)) {",
  "                /* Note: because we've taken care in",
  "                 * yy_get_next_buffer() to have set up",
  "                 * yy_text, we can now set up",
  "                 * yy_c_buf_p so that if some total",
  "                 * hoser (like smflex itself) wants to",
  "                 * call the scanner after we return the",
  "                 * YY_EOF_TOKEN_CODE, it'll still work - another",
  "                 * YY_EOF_TOKEN_CODE will get returned.",
  "                 */",
  "                yy_lexer->yy_c_buf_p = yy_lexer->yy_text + YY_MORE_ADJ;",
  "",
  "                yy_act = YY_STATE_EOF(YY_GET_START_STATE());",
  "                goto do_action;",
  "              }",
  "",
  "              else {",
  "                if (!yy_lexer->yy_did_buffer_switch_on_eof) {",
  "                  YY_NEW_FILE;",
  "                }",
  "              }",
  "              break;",
  "            }",
  "",
  "            case EOB_ACT_CONTINUE_SCAN:",
  "              yy_lexer->yy_c_buf_p = yy_lexer->yy_text + yy_amount_of_matched_text;",
  "",
  "              yy_current_state = yy_get_previous_state(yy_lexer);",
  "",
  "              yy_cp = yy_lexer->yy_c_buf_p;",
  "              yy_bp = yy_lexer->yy_text + YY_MORE_ADJ;",
  "              goto yy_match;",
  "",
  "            case EOB_ACT_LAST_MATCH:",
  "              yy_lexer->yy_c_buf_p =",
  "                &yy_lexer->yy_current_buffer->yy_ch_buf[yy_lexer->yy_n_chars];",
  "",
  "              yy_current_state = yy_get_previous_state(yy_lexer);",
  "",
  "              yy_cp = yy_lexer->yy_c_buf_p;",
  "              yy_bp = yy_lexer->yy_text + YY_MORE_ADJ;",
  "              goto yy_find_action;",
  "          } /* switch (yy_get_next_buffer()) */",
  "        }",
  "",
  "        break;",
  "      } /* case YY_END_OF_BUFFER */",
  "",
  "      default:",
  "        YY_ERROR(yy_err_internal_error, \"bad action code\");",
  "        return 0;",
  "    } /* end of action switch */",
  "  } /* end of scanning one token */",
  "} /* end of yy_lex */",
  "",
  "",
  "void yy_construct(yy_lexer_t *yy_lexer)",
  "{",
  "  yy_lexer->yy_client_data = NULL;",
  "",
  "  yy_lexer->yy_text = NULL;",
  "  yy_lexer->yy_leng = 0;",
  "",
  "  yy_lexer->yy_input_stream = (yy_input_stream_t*)stdin;",
  "  yy_lexer->yy_output_stream = (yy_output_stream_t*)stdout;",
  "",
  "%if use_read",
  "  yy_lexer->yy_read_input_function   = &yy_read_input_with_read;",
  "%else",
  "  yy_lexer->yy_read_input_function   = &yy_read_input_with_fread;",
  "%endif",
  "  yy_lexer->yy_write_output_function = &yy_write_output_with_fwrite;",
  "  yy_lexer->yy_wrap_function         = &yy_wrap_return_1;",
  "  yy_lexer->yy_error_function        = &yy_error_print_and_exit;",
  "",
  "%if do_yylineno",
  "  yy_lexer->yy_lineno = 1;",
  "",
  "%endif",
  "%if option_debug",
  "  yy_lexer->yy_flex_debug = 1;",
  "",
  "%endif",
  "  yy_lexer->yy_current_buffer = NULL;",
  "",
  "  yy_lexer->yy_error_code = yy_err_no_error;",
  "",
  "  yy_lexer->yy_hold_char = 0;",
  "  yy_lexer->yy_n_chars = 0;",
  "",
  "  yy_lexer->yy_c_buf_p = NULL;",
  "  yy_lexer->yy_init = 1;",
  "  yy_lexer->yy_start_state = 0;",
  "  yy_lexer->yy_did_buffer_switch_on_eof = 0;",
  "",
  "%if num_backing_up > 0 && !reject_used",
  "  yy_lexer->yy_last_accepting_state = 0; /* This can be a pointer. */",
  "  yy_lexer->yy_last_accepting_cpos = NULL;",
  "",
  "%endif",
  "%if reject_used",
  "  yy_lexer->yy_state_buf =",
  "    (yy_state_type_t*)yy_flex_alloc(sizeof(yy_state_type_t) * (YY_BUF_SIZE+2));",
  "  yy_lexer->yy_state_ptr = NULL;",
  "  yy_lexer->yy_full_match = NULL;",
  "  yy_lexer->yy_lp = 0;",
  "",
  "%endif",
  "%if reject_used && variable_trailing_context_rules",
  "  yy_lexer->yy_looking_for_trail_begin = 0;",
  "  yy_lexer->yy_full_lp = 0;",
  "  yy_lexer->yy_full_state = NULL;",
  "",
  "%endif",
  "%if yymore_used",
  "  yy_lexer->yy_more_flag = 0;",
  "  yy_lexer->yy_more_len = 0;",
  "",
  "%endif",
  "%if option_stack",
  "  yy_lexer->yy_start_stack_cur_size = 0;",
  "  yy_lexer->yy_start_stack_alloc_size = 0;",
  "  yy_lexer->yy_start_stack_array = NULL;",
  "",
  "%endif",
  "}",
  "",
  "%if cpp_interface",
  "yyFlexLexer::yyFlexLexer(yy_input_stream_t *arg_yyin, yy_output_stream_t *arg_yyout)",
  "{",
  "  yy_construct(&yym_lexer_state);",
  "  yym_lexer_state.yy_client_data = this;",
  "",
  "  yym_lexer_state.yy_input_stream =",
  "    arg_yyin  ? arg_yyin  : (yy_input_stream_t*)&std::cin;",
  "  yym_lexer_state.yy_output_stream =",
  "    arg_yyout ? arg_yyout : (yy_output_stream_t*)&std::cout;",
  "",
  "  yym_lexer_state.yy_read_input_function   = &yy_read_input_delegate;",
  "  yym_lexer_state.yy_write_output_function = &yy_write_output_delegate;",
  "  yym_lexer_state.yy_wrap_function         = &yy_wrap_delegate;",
  "  yym_lexer_state.yy_error_function        = &yy_error_delegate;",
  "}",
  "%endif",
  "",
  "void yy_destroy(yy_lexer_t *yy_lexer)",
  "{",
  "%if reject_used",
  "  yy_flex_free(yy_lexer->yy_state_buf);",
  "%endif",
  "%if option_stack",
  "  yy_flex_free(yy_lexer->yy_start_stack_array);",
  "%endif",
  "  yy_delete_buffer(yy_lexer, yy_lexer->yy_current_buffer);",
  "}",
  "",
  "%if cpp_interface",
  "yyFlexLexer::~yyFlexLexer()",
  "{",
  "  yy_destroy(&yym_lexer_state);",
  "}",
  "",
  "void yyFlexLexer::yym_switch_streams(yy_input_stream_t *new_in)",
  "{",
  "  yym_delete_buffer(yym_lexer_state.yy_current_buffer);",
  "  yym_switch_to_buffer(yym_create_buffer(new_in, YY_BUF_SIZE));",
  "}",
  "",
  "",
  "int yyFlexLexer::yym_read_input(void *dest, int size)",
  "{",
  "  std::istream *input_istream = (std::istream*)yym_input_stream();",
  "  input_istream->read((char*)dest, size);",
  "  if (input_istream->bad()) {",
  "    return -1;",
  "  }",
  "  else {",
  "    std::streamsize ret = input_istream->gcount();",
  "    return ret;",
  "  }",
  "}",
  "",
  "",
  "int yyFlexLexer::yym_write_output(void const *dest, int size)",
  "{",
  "  std::ostream *output_ostream = (std::ostream*)yym_output_stream();",
  "  output_ostream->write((char const *)dest, size);",
  "  if (output_ostream->bad()) {",
  "    return -1;",
  "  }",
  "  else {",
  "    return size;",
  "  }",
  "}",
  "%endif",
  "",
  "",
  "/* Get more data by calling 'yy_read_input_function'.  Returns a",
  " * non-negative integer number of bytes read (since a read error is",
  " * treated like a 0-length read as part of error recovery), with 0",
  " * signalling end of file. */",
  "static int yy_call_read_input(yy_lexer_t *yy_lexer, void *dest, int size)",
  "{",
  "  int n;",
  "",
  "  YY_ASSERT(size >= 1);",
  "  if (yy_lexer->yy_current_buffer->yy_is_interactive) {",
  "    /* Read one character at a time. */",
  "    size = 1;",
  "  }",
  "",
  "  n = yy_lexer->yy_read_input_function(yy_lexer, dest, size);",
  "  if (n < 0) {",
  "    YY_ERROR(yy_err_input_error, NULL /*detail*/);",
  "",
  "    /* Recover by pretending we saw EOF. */",
  "    n = 0;",
  "  }",
  "",
  "#ifdef YY_ENABLE_DEBUG_LOG_CALL",
  "  {",
  "    int c = n==0? 0 : ((char*)dest)[0];",
  "%if !cpp_interface",
  "    printf(\"[n=%d c=%d]\\n\", n, c);",
  "%else",
  "    std::cout << \"[n=\" << n << \" c=\" << c << \"]\\n\";",
  "%endif",
  "  }",
  "#endif",
  "",
  "  return n;",
  "}",
  "",
  "",
  "/* yy_get_next_buffer - try to read in a new buffer",
  " *",
  " * Returns a code representing an action:",
  " *      EOB_ACT_LAST_MATCH -",
  " *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
  " *      EOB_ACT_END_OF_FILE - end of file",
  " */",
  "static int yy_get_next_buffer(yy_lexer_t *yy_lexer)",
  "{",
  "  char *dest = yy_lexer->yy_current_buffer->yy_ch_buf;",
  "  char *source = yy_lexer->yy_text;",
  "  int number_to_move, i;",
  "  int ret_val;",
  "",
  "  if (yy_lexer->yy_c_buf_p > &yy_lexer->yy_current_buffer->yy_ch_buf[yy_lexer->yy_n_chars + 1]) {",
  "    YY_ERROR(yy_err_internal_error, \"end of buffer missed\");",
  "    return EOB_ACT_END_OF_FILE;",
  "  }",
  "",
  "  if (yy_lexer->yy_current_buffer->yy_fill_buffer == 0) { /* Don't try to fill the buffer, so this is an EOF. */",
  "    if (yy_lexer->yy_c_buf_p - yy_lexer->yy_text - YY_MORE_ADJ == 1) {",
  "      /* We matched a single character, the EOB, so",
  "       * treat this as a final EOF.",
  "       */",
  "      return EOB_ACT_END_OF_FILE;",
  "    }",
  "",
  "    else {",
  "      /* We matched some text prior to the EOB, first",
  "       * process it.",
  "       */",
  "      return EOB_ACT_LAST_MATCH;",
  "    }",
  "  }",
  "",
  "  /* Try to read more data. */",
  "",
  "  /* First move last chars to start of buffer. */",
  "  number_to_move = (int) (yy_lexer->yy_c_buf_p - yy_lexer->yy_text) - 1;",
  "",
  "  for (i = 0; i < number_to_move; ++i) {",
  "    *(dest++) = *(source++);",
  "  }",
  "",
  "  if (yy_lexer->yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING) {",
  "    /* don't do the read, it's not guaranteed to return an EOF,",
  "     * just force an EOF",
  "     */",
  "    yy_lexer->yy_current_buffer->yy_n_chars = yy_lexer->yy_n_chars = 0;",
  "  }",
  "",
  "  else {",
  "    int num_to_read = yy_lexer->yy_current_buffer->yy_buf_size - number_to_move - 1;",
  "",
  "    while (num_to_read <= 0) {  /* Not enough room in the buffer - grow it. */",
  "%if reject_used",
  "      /* Cannot enlarge because of REJECT. */",
  "      YY_ERROR(yy_err_input_buffer_cannot_expand,",
  "        \"can't enlarge buffer because scanner uses REJECT\");",
  "      return EOB_ACT_END_OF_FILE;",
  "%else",
  "      /* just a shorter name for the current buffer */",
  "      yy_buffer_state_t *b = yy_lexer->yy_current_buffer;",
  "",
  "      int yy_c_buf_p_offset = (int) (yy_lexer->yy_c_buf_p - b->yy_ch_buf);",
  "",
  "      if (b->yy_is_our_buffer) {",
  "        size_t new_size;",
  "        char *new_buffer;",
  "",
  "        /* Check for arithemtic overflow calculating new size. */",
  "        if (b->yy_buf_size > (YY_SIZE_T_MAX-2) / 2) {",
  "          YY_ERROR(yy_err_input_buffer_at_max_size, NULL /*detail*/);",
  "          return EOB_ACT_END_OF_FILE;",
  "        }",
  "        new_size = b->yy_buf_size * 2;",
  "",
  "        /* Allocate a new buffer. */",
  "        YY_DEBUG_LOG_MEM(\"allocate new buffer\", new_size + 2);",
  "        new_buffer = (char*)yy_flex_alloc(new_size + 2);",
  "        if (!new_buffer) {",
  "          YY_ERROR(yy_err_out_of_memory, \"while expanding input buffer\");",
  "          return EOB_ACT_END_OF_FILE;",
  "        }",
  "",
  "        /* Copy the old data, including the EOB characters. */",
  "        memcpy(new_buffer, b->yy_ch_buf, b->yy_buf_size + 2);",
  "",
  "        /* Release the old buffer and update the fields. */",
  "        yy_flex_free(b->yy_ch_buf);",
  "        b->yy_ch_buf = new_buffer;",
  "        b->yy_buf_size = new_size;",
  "      }",
  "      else {",
  "        /* This happens if we think we need more input to get a match,",
  "         * but we are using 'yy_scan_buffer' and there is no more data.",
  "         * But in that case, why did we not already see the end of",
  "         * buffer markers? */",
  "        YY_ERROR(yy_err_internal_error, \"expanding un-owned input buffer\");",
  "        return EOB_ACT_END_OF_FILE;",
  "      }",
  "",
  "      yy_lexer->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];",
  "",
  "      num_to_read = yy_lexer->yy_current_buffer->yy_buf_size - number_to_move - 1;",
  "%endif",
  "    }",
  "",
  "    if (num_to_read > YY_READ_BUF_SIZE) {",
  "      num_to_read = YY_READ_BUF_SIZE;",
  "    }",
  "",
  "    /* Read in more data. */",
  "    yy_lexer->yy_n_chars =",
  "      yy_call_read_input(yy_lexer,",
  "        &yy_lexer->yy_current_buffer->yy_ch_buf[number_to_move],",
  "        num_to_read);",
  "",
  "    yy_lexer->yy_current_buffer->yy_n_chars = yy_lexer->yy_n_chars;",
  "  }",
  "",
  "  if (yy_lexer->yy_n_chars == 0) {",
  "    if (number_to_move == YY_MORE_ADJ) {",
  "      ret_val = EOB_ACT_END_OF_FILE;",
  "      yy_restart(yy_lexer, yy_lexer->yy_input_stream);",
  "    }",
  "",
  "    else {",
  "      ret_val = EOB_ACT_LAST_MATCH;",
  "      yy_lexer->yy_current_buffer->yy_buffer_status = YY_BUFFER_EOF_PENDING;",
  "    }",
  "  }",
  "",
  "  else {",
  "    ret_val = EOB_ACT_CONTINUE_SCAN;",
  "  }",
  "",
  "  yy_lexer->yy_n_chars += number_to_move;",
  "  yy_lexer->yy_current_buffer->yy_ch_buf[yy_lexer->yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
  "  yy_lexer->yy_current_buffer->yy_ch_buf[yy_lexer->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "  yy_lexer->yy_text = &yy_lexer->yy_current_buffer->yy_ch_buf[0];",
  "",
  "  return ret_val;",
  "}",
  "",
  "",
  "/* yy_get_previous_state - get the state just before the EOB char was reached */",
  "static yy_state_type_t yy_get_previous_state(yy_lexer_t *yy_lexer)",
  "{",
  "  yy_state_type_t yy_current_state;",
  "  char *yy_cp;",
  "",
  "%% prev_start_to_current: code to get the start state into yy_current_state goes here",
  "",
  "  for (yy_cp = yy_lexer->yy_text + YY_MORE_ADJ;",
  "       yy_cp < yy_lexer->yy_c_buf_p;",
  "       ++yy_cp) {",
  "%% prev_find_next_state: code to find the next state goes here",
  "  }",
  "",
  "  return yy_current_state;",
  "}",
  "",
  "",
  "/* yy_try_NUL_trans - try to make a transition on the NUL character",
  " *",
  " * synopsis",
  " *      next_state = yy_try_NUL_trans(yy_lexer, current_state);",
  " */",
  "static yy_state_type_t yy_try_NUL_trans(yy_lexer_t *yy_lexer, yy_state_type_t yy_current_state)",
  "{",
  "  int yy_is_jam;",
  "%% nul_trans_next_state: code to find the next state, and perhaps do backing up, goes here",
  "",
  "  return yy_is_jam ? 0 : yy_current_state;",
  "}",
  "",
  "",
  "%if option_yy_unread_character",
  "void yy_unread_character(yy_lexer_t *yy_lexer, int c)",
  "{",
  "  char *yy_bp = yy_lexer->yy_text;",
  "  char *yy_cp = yy_lexer->yy_c_buf_p;",
  "",
  "  /* undo effects of setting up yy_text */",
  "  *yy_cp = yy_lexer->yy_hold_char;",
  "",
  "  if (yy_cp < yy_lexer->yy_current_buffer->yy_ch_buf + 2) {",
  "    /* need to shift things up to make room */",
  "    /* +2 for EOB chars. */",
  "    int number_to_move = yy_lexer->yy_n_chars + 2;",
  "    char *dest = &yy_lexer->yy_current_buffer->yy_ch_buf[",
  "      yy_lexer->yy_current_buffer->yy_buf_size + 2];",
  "    char *source =",
  "      &yy_lexer->yy_current_buffer->yy_ch_buf[number_to_move];",
  "",
  "    while (source > yy_lexer->yy_current_buffer->yy_ch_buf) {",
  "      *--dest = *--source;",
  "    }",
  "",
  "    yy_cp += (int)(dest - source);",
  "    yy_bp += (int)(dest - source);",
  "    yy_lexer->yy_current_buffer->yy_n_chars =",
  "      yy_lexer->yy_n_chars = yy_lexer->yy_current_buffer->yy_buf_size;",
  "",
  "    if (yy_cp < yy_lexer->yy_current_buffer->yy_ch_buf + 2) {",
  "      YY_ERROR(yy_err_unread_overflow, NULL /*detail*/);",
  "      return;",
  "    }",
  "  }",
  "",
  "  *--yy_cp = (char)c;",
  "",
  "%if do_yylineno",
  "  if (c == '\\n') {",
  "    --(yy_lexer->yy_lineno);",
  "  }",
  "%endif",
  "",
  "  yy_lexer->yy_text = yy_bp;",
  "  yy_lexer->yy_hold_char = *yy_cp;",
  "  yy_lexer->yy_c_buf_p = yy_cp;",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_unread_character(int c)",
  "{",
  "  yy_unread_character(&yym_lexer_state, c);",
  "}",
  "%endif",
  "%endif # option_yy_unread_character",
  "",
  "",
  "%if option_yy_read_character",
  "/* Read one character from the current input source of 'yy_lexer'. */",
  "int yy_read_character(yy_lexer_t *yy_lexer)",
  "{",
  "  int c;",
  "",
  "  *(yy_lexer->yy_c_buf_p) = yy_lexer->yy_hold_char;",
  "",
  "  if (*(yy_lexer->yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {",
  "    /* yy_c_buf_p now points to the character we want to return.",
  "     * If this occurs *before* the EOB characters, then it's a",
  "     * valid NUL; if not, then we've hit the end of the buffer.",
  "     */",
  "    if (yy_lexer->yy_c_buf_p <",
  "          &yy_lexer->yy_current_buffer->yy_ch_buf[yy_lexer->yy_n_chars]) {",
  "      /* This was really a NUL. */",
  "      *(yy_lexer->yy_c_buf_p) = '\\0';",
  "    }",
  "",
  "    else { /* need more input */",
  "      int offset = yy_lexer->yy_c_buf_p - yy_lexer->yy_text;",
  "      ++(yy_lexer->yy_c_buf_p);",
  "",
  "      switch (yy_get_next_buffer(yy_lexer)) {",
  "        case EOB_ACT_LAST_MATCH:",
  "          /* This happens because yy_g_n_b()",
  "           * sees that we've accumulated a",
  "           * token and flags that we need to",
  "           * try matching the token before",
  "           * proceeding.  But for input(),",
  "           * there's no matching to consider.",
  "           * So convert the EOB_ACT_LAST_MATCH",
  "           * to EOB_ACT_END_OF_FILE.",
  "           */",
  "",
  "          /* Reset buffer status. */",
  "          yy_restart(yy_lexer, yy_lexer->yy_input_stream);",
  "",
  "          /* fall through */",
  "",
  "        case EOB_ACT_END_OF_FILE: {",
  "          if (yy_lexer->yy_wrap_function(yy_lexer)) {",
  "            return EOF;",
  "          }",
  "",
  "          if (!yy_lexer->yy_did_buffer_switch_on_eof) {",
  "            YY_NEW_FILE;",
  "          }",
  "",
  "          return yy_read_character(yy_lexer);",
  "        }",
  "",
  "        case EOB_ACT_CONTINUE_SCAN:",
  "          yy_lexer->yy_c_buf_p = yy_lexer->yy_text + offset;",
  "          break;",
  "      }",
  "    }",
  "  }",
  "",
  "  c = *(unsigned char *)yy_lexer->yy_c_buf_p;   /* cast for 8-bit char's */",
  "  *(yy_lexer->yy_c_buf_p) = '\\0';     /* preserve yy_text */",
  "  yy_lexer->yy_hold_char = *++(yy_lexer->yy_c_buf_p);",
  "",
  "%if bol_needed",
  "  yy_lexer->yy_current_buffer->yy_at_bol = (c == '\\n');",
  "%endif",
  "%if do_yylineno",
  "  if (c == '\\n') {",
  "    ++(yy_lexer->yy_lineno);",
  "  }",
  "%endif",
  "",
  "  return c;",
  "}",
  "",
  "%if cpp_interface",
  "int yyFlexLexer::yym_read_character()",
  "{",
  "  return yy_read_character(&yym_lexer_state);",
  "}",
  "%endif",
  "%endif # option_yy_read_character",
  "",
  "",
  "void yy_restart(yy_lexer_t *yy_lexer, yy_input_stream_t *input_file)",
  "{",
  "  if (!yy_lexer->yy_current_buffer) {",
  "    yy_lexer->yy_current_buffer =",
  "      yy_create_buffer(yy_lexer, yy_lexer->yy_input_stream, YY_BUF_SIZE);",
  "    if (!yy_lexer->yy_current_buffer) {",
  "      return;     /* Error already reported, try to recover. */",
  "    }",
  "  }",
  "",
  "  yy_init_buffer(yy_lexer, yy_lexer->yy_current_buffer, input_file);",
  "  yy_load_current_buffer_state(yy_lexer);",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_restart(yy_input_stream_t *input_file)",
  "{",
  "  yy_restart(&yym_lexer_state, input_file);",
  "}",
  "%endif",
  "",
  "",
  "void yy_switch_to_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *new_buffer)",
  "{",
  "  if (yy_lexer->yy_current_buffer == new_buffer) {",
  "    return;",
  "  }",
  "",
  "  if (yy_lexer->yy_current_buffer) {",
  "    /* Flush out information for old buffer. */",
  "    *(yy_lexer->yy_c_buf_p) = yy_lexer->yy_hold_char;",
  "    yy_lexer->yy_current_buffer->yy_buf_pos = yy_lexer->yy_c_buf_p;",
  "    yy_lexer->yy_current_buffer->yy_n_chars = yy_lexer->yy_n_chars;",
  "  }",
  "",
  "  yy_lexer->yy_current_buffer = new_buffer;",
  "  yy_load_current_buffer_state(yy_lexer);",
  "",
  "  /* We don't actually know whether we did this switch during",
  "   * EOF (yy_wrap()) processing, but the only time this flag",
  "   * is looked at is after yy_wrap() is called, so it's safe",
  "   * to go ahead and always set it.",
  "   */",
  "  yy_lexer->yy_did_buffer_switch_on_eof = 1;",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_switch_to_buffer(yy_buffer_state_t *new_buffer)",
  "{",
  "  yy_switch_to_buffer(&yym_lexer_state, new_buffer);",
  "}",
  "%endif",
  "",
  "",
  "/* Copy the fields from 'yy_lexer->yy_current_buffer' that are",
  " * duplicated in the 'yy_lexer_t' structure.",
  " *",
  " * Also set up 'yy_text' and 'yy_hold_char'. */",
  "static void yy_load_current_buffer_state(yy_lexer_t *yy_lexer)",
  "{",
  "  /* Copy duplicated fields. */",
  "  yy_lexer->yy_n_chars      = yy_lexer->yy_current_buffer->yy_n_chars;",
  "  yy_lexer->yy_c_buf_p      = yy_lexer->yy_current_buffer->yy_buf_pos;",
  "  yy_lexer->yy_input_stream = yy_lexer->yy_current_buffer->yy_input_file;",
  "",
  "  /* Set up 'yy_text'.  TODO: Why is this necessary? */",
  "  yy_lexer->yy_text      =   yy_lexer->yy_c_buf_p;",
  "",
  "  /* Establish the 'yy_hold_char' invariant. */",
  "  yy_lexer->yy_hold_char = *(yy_lexer->yy_c_buf_p);",
  "}",
  "",
  "",
  "yy_buffer_state_t *yy_create_buffer(yy_lexer_t *yy_lexer,",
  "                                    yy_input_stream_t *file, int size)",
  "{",
  "  yy_buffer_state_t *b;",
  "",
  "  b = (yy_buffer_state_t*)yy_flex_alloc(sizeof(yy_buffer_state_t));",
  "  if (!b) {",
  "    YY_ERROR(yy_err_out_of_memory, \"yy_create_buffer: buffer structure\");",
  "    return NULL;",
  "  }",
  "",
  "  if (size == 0) {",
  "    /* Unspecified size becomes 'YY_BUF_SIZE'. */",
  "    size = YY_BUF_SIZE;",
  "  }",
  "  b->yy_buf_size = size;",
  "",
  "  /* yy_ch_buf has to be 2 characters longer than the size given because",
  "   * we need to put in 2 end-of-buffer characters.",
  "   */",
  "  b->yy_ch_buf = (char*)yy_flex_alloc(b->yy_buf_size + 2);",
  "  if (!b->yy_ch_buf) {",
  "    yy_flex_free(b);",
  "    YY_ERROR(yy_err_out_of_memory, \"yy_create_buffer: input buffer\");",
  "    return NULL;",
  "  }",
  "",
  "  b->yy_is_our_buffer = 1;",
  "",
  "  yy_init_buffer(yy_lexer, b, file);",
  "",
  "  return b;",
  "}",
  "",
  "%if cpp_interface",
  "yy_buffer_state_t *yyFlexLexer::yym_create_buffer(yy_input_stream_t *file,",
  "                                                  int size)",
  "{",
  "  return yy_create_buffer(&yym_lexer_state, file, size);",
  "}",
  "%endif",
  "",
  "",
  "void yy_delete_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *b)",
  "{",
  "  if (!b) {",
  "    return;",
  "  }",
  "",
  "  if (yy_lexer->yy_current_buffer == b) {",
  "    /* Safety measure. */",
  "    yy_lexer->yy_current_buffer = NULL;",
  "  }",
  "",
  "  if (b->yy_is_our_buffer) {",
  "    yy_flex_free((void*)b->yy_ch_buf);",
  "  }",
  "",
  "  yy_flex_free((void*)b);",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_delete_buffer(yy_buffer_state_t *b)",
  "{",
  "  yy_delete_buffer(&yym_lexer_state, b);",
  "}",
  "%endif",
  "",
  "",
  "static void yy_init_buffer(yy_lexer_t *yy_lexer,",
  "                           yy_buffer_state_t *b, yy_input_stream_t *file)",
  "{",
  "  yy_flush_buffer(yy_lexer, b);",
  "",
  "  b->yy_input_file = file;",
  "  b->yy_fill_buffer = 1;",
  "",
  "%if interactive",
  "  b->yy_is_interactive = 1;",
  "  YY_DEBUG_LOG_CALL(\"due to option interactive, yy_is_interactive is\", b->yy_is_interactive);",
  "%else",
  "  b->yy_is_interactive = 0;",
  "  YY_DEBUG_LOG_CALL(\"default behavior, so yy_is_interactive is\", b->yy_is_interactive);",
  "%endif",
  "}",
  "",
  "",
  "void yy_flush_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *b)",
  "{",
  "  if (!b) {",
  "    return;",
  "  }",
  "",
  "  b->yy_n_chars = 0;",
  "",
  "  /* We always need two end-of-buffer characters.  The first causes",
  "   * a transition to the end-of-buffer state.  The second causes",
  "   * a jam in that state.",
  "   */",
  "  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;",
  "  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "  b->yy_buf_pos = &b->yy_ch_buf[0];",
  "",
  "  b->yy_at_bol = 1;",
  "  b->yy_buffer_status = YY_BUFFER_NEW;",
  "",
  "  if (b == yy_lexer->yy_current_buffer) {",
  "    yy_load_current_buffer_state(yy_lexer);",
  "  }",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_flush_buffer(yy_buffer_state_t *b)",
  "{",
  "  yy_flush_buffer(&yym_lexer_state, b);",
  "}",
  "%endif",
  "",
  "",
  "%# yy_scan_string and yy_scan_bytes require yy_scan_buffer",
  "%if option_yy_scan_buffer || option_yy_scan_bytes || option_yy_scan_string",
  "yy_buffer_state_t *yy_scan_buffer(yy_lexer_t *yy_lexer,",
  "                                  char *base, size_t size)",
  "{",
  "  yy_buffer_state_t *b;",
  "",
  "  if (size < 2 ||",
  "      base[size - 2] != YY_END_OF_BUFFER_CHAR ||",
  "      base[size - 1] != YY_END_OF_BUFFER_CHAR) {",
  "    YY_ERROR(yy_err_api_misuse,",
  "      \"buffer does not end with two zero bytes\");",
  "    return NULL;",
  "  }",
  "",
  "  b = (yy_buffer_state_t*)yy_flex_alloc(sizeof(yy_buffer_state_t));",
  "  if (!b) {",
  "    YY_ERROR(yy_err_out_of_memory, \"yy_scan_buffer: buffer structure\");",
  "    return NULL;",
  "  }",
  "",
  "  b->yy_buf_size = size - 2;    /* \"- 2\" to take care of EOB's */",
  "  b->yy_buf_pos = b->yy_ch_buf = base;",
  "  b->yy_is_our_buffer = 0;",
  "  b->yy_input_file = 0;",
  "  b->yy_n_chars = b->yy_buf_size;",
  "  YY_DEBUG_LOG_CALL(\"setting yy_is_interactive to 0 in yy_scan_buffer\", 0);",
  "  b->yy_is_interactive = 0;",
  "  b->yy_at_bol = 1;",
  "  b->yy_fill_buffer = 0;",
  "  b->yy_buffer_status = YY_BUFFER_NEW;",
  "",
  "  yy_switch_to_buffer(yy_lexer, b);",
  "",
  "  return b;",
  "}",
  "%endif",
  "",
  "%# yy_scan_string requires yy_scan_bytes",
  "%if option_yy_scan_bytes || option_yy_scan_string",
  "yy_buffer_state_t *yy_scan_bytes(yy_lexer_t *yy_lexer,",
  "                                 const char *bytes, int len)",
  "{",
  "  yy_buffer_state_t *b;",
  "  char *buf;",
  "  size_t n;",
  "  int i;",
  "",
  "  /* Get memory for full buffer, including space for trailing EOB's. */",
  "  n = len + 2;",
  "  buf = (char*)yy_flex_alloc(n);",
  "  if (!buf) {",
  "    YY_ERROR(yy_err_out_of_memory, \"yy_scan_bytes: input buffer\");",
  "    return NULL;",
  "  }",
  "",
  "  for (i = 0; i < len; ++i) {",
  "    buf[i] = bytes[i];",
  "  }",
  "",
  "  buf[len] = buf[len + 1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "%if cpp_interface",
  "  /* Ensure 'buf' is freed if 'yy_scan_buffer' throws. */",
  "  yyAutoFree af(buf);",
  "",
  "%endif",
  "  b = yy_scan_buffer(yy_lexer, buf, n);",
  "%if cpp_interface",
  "",
  "  /* No exception was thrown.  Let the C code clean up if needed. */",
  "  af.clear();",
  "%endif",
  "",
  "  if (!b) {",
  "    /* The error has already been reported. */",
  "    yy_flex_free(buf);",
  "    return NULL;",
  "  }",
  "",
  "  /* It's okay to grow etc. this buffer, and we should throw it",
  "   * away when we're done.",
  "   */",
  "  b->yy_is_our_buffer = 1;",
  "",
  "  return b;",
  "}",
  "%endif",
  "",
  "%if option_yy_scan_string",
  "yy_buffer_state_t *yy_scan_string(yy_lexer_t *yy_lexer, const char *yy_str)",
  "{",
  "  return yy_scan_bytes(yy_lexer, yy_str, strlen(yy_str));",
  "}",
  "%endif",
  "",
  "",
  "%if cpp_interface",
  "%if option_yy_scan_string",
  "yy_buffer_state_t *yyFlexLexer::yym_scan_string(const char *yy_str)",
  "{",
  "  return yy_scan_string(&yym_lexer_state, yy_str);",
  "}",
  "%endif",
  "",
  "%if option_yy_scan_bytes",
  "yy_buffer_state_t *yyFlexLexer::yym_scan_bytes(const char *bytes, int len)",
  "{",
  "  return yy_scan_bytes(&yym_lexer_state, bytes, len);",
  "}",
  "%endif",
  "",
  "%if option_yy_scan_buffer",
  "yy_buffer_state_t *yyFlexLexer::yym_scan_buffer(char *base, size_t size)",
  "{",
  "  return yy_scan_buffer(&yym_lexer_state, base, size);",
  "}",
  "%endif",
  "%endif # cpp_interface",
  "",
  "",
  "%if option_stack",
  "void yy_push_state(yy_lexer_t *yy_lexer, int new_state)",
  "{",
  "  YY_ASSERT(0 <= yy_lexer->yy_start_stack_cur_size &&",
  "                 yy_lexer->yy_start_stack_cur_size <= yy_lexer->yy_start_stack_alloc_size);",
  "",
  "  if (yy_lexer->yy_start_stack_cur_size >= yy_lexer->yy_start_stack_alloc_size) {",
  "    int new_alloc_size;",
  "    int *new_array;",
  "",
  "    /* Check for overflow. */",
  "    if (yy_lexer->yy_start_stack_alloc_size > INT_MAX/2 - YY_START_STACK_INCR) {",
  "      YY_ERROR(yy_err_state_stack_overflow, NULL /*detail*/);",
  "      return;",
  "    }",
  "    new_alloc_size =",
  "      yy_lexer->yy_start_stack_alloc_size * 2 + YY_START_STACK_INCR;",
  "",
  "    /* Allocate. */",
  "    new_array = (int*)yy_flex_alloc(new_alloc_size * sizeof(int));",
  "    if (!new_array) {",
  "      YY_ERROR(yy_err_out_of_memory, \"yy_push_state: expanding state stack\");",
  "      return;",
  "    }",
  "",
  "    /* Copy. */",
  "    if (yy_lexer->yy_start_stack_array) {",
  "      memcpy(new_array,",
  "             yy_lexer->yy_start_stack_array,",
  "             yy_lexer->yy_start_stack_alloc_size * sizeof(int));",
  "",
  "      /* Release old storage. */",
  "      yy_flex_free(yy_lexer->yy_start_stack_array);",
  "    }",
  "",
  "    /* Everything succeeded.  Update the data members. */",
  "    yy_lexer->yy_start_stack_alloc_size = new_alloc_size;",
  "    yy_lexer->yy_start_stack_array = new_array;",
  "  }",
  "",
  "  yy_lexer->yy_start_stack_array[yy_lexer->yy_start_stack_cur_size++] =",
  "    YY_GET_START_STATE();",
  "",
  "  YY_SET_START_STATE(new_state);",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_push_state(int new_state)",
  "{",
  "  yy_push_state(&yym_lexer_state, new_state);",
  "}",
  "%endif",
  "",
  "",
  "void yy_pop_state(yy_lexer_t *yy_lexer)",
  "{",
  "  if (yy_lexer->yy_start_stack_cur_size <= 0) {",
  "    YY_ERROR(yy_err_api_misuse, \"yy_pop_state: start stack is empty\");",
  "    return;",
  "  }",
  "",
  "  --(yy_lexer->yy_start_stack_cur_size);",
  "  YY_SET_START_STATE(yy_lexer->yy_start_stack_array[yy_lexer->yy_start_stack_cur_size]);",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_pop_state()",
  "{",
  "  yy_pop_state(&yym_lexer_state);",
  "}",
  "%endif",
  "",
  "",
  "%if option_yy_top_state",
  "int yy_top_state(yy_lexer_t const *yy_lexer)",
  "{",
  "  if (yy_lexer->yy_start_stack_cur_size <= 0) {",
  "    YY_ERROR(yy_err_api_misuse, \"yy_top_state: state stack is empty\");",
  "    return INITIAL;",
  "  }",
  "",
  "  return yy_lexer->yy_start_stack_array[yy_lexer->yy_start_stack_cur_size - 1];",
  "}",
  "",
  "%if cpp_interface",
  "int yyFlexLexer::yym_top_state() const",
  "{",
  "  return yy_top_state(&yym_lexer_state);",
  "}",
  "%endif",
  "%endif",
  "%endif # option_stack",
  "",
  "",
  "yy_error_code_t yy_get_error(yy_lexer_t const *yy_lexer)",
  "{",
  "  return yy_lexer->yy_error_code;",
  "}",
  "",
  "",
  "/* Table of error messages. */",
  "static char const * const yy_error_string_table[] = {",
  "  \"no error\",",
  "  \"internal error\",",
  "  \"API misused\",",
  "  \"error reading input source\",",
  "  \"token is too large and input buffer cannot be expanded\",",
  "  \"token is too large and input buffer is already at maximum size\",",
  "  \"no rule matches the input text\",",
  "  \"out of memory\",",
  "%if option_yy_unread_character",
  "  \"no space in buffer to unread a character\",",
  "%endif",
  "%if option_stack",
  "  \"cannot push a state because the start-state stack is at its maximum size\",",
  "%endif",
  "};",
  "",
  "",
  "char const *yy_error_string(yy_error_code_t code)",
  "{",
  "  /* Make sure the table is kept in sync with the enumeration. */",
  "  YY_STATIC_ASSERT(sizeof(yy_error_string_table) /",
  "                   sizeof(yy_error_string_table[0]) == yy_err_num_error_codes);",
  "",
  "  /* Forcing an unsigned comparison takes care of negatives while also",
  "   * avoiding a possible compiler warning if the underlying type of",
  "   * 'yy_error_code_t' is unsigned and we explicitly checked against 0. */",
  "  if ((unsigned)code < (unsigned)yy_err_num_error_codes) {",
  "    return yy_error_string_table[code];",
  "  }",
  "  else {",
  "    return \"invalid error code\";",
  "  }",
  "}",
  "",
  "",
  "void yy_error_print_and_exit(yy_lexer_t const *yy_lexer,",
  "  yy_error_code_t code, char const *detail)",
  "{",
  "  if (detail) {",
  "    fprintf(stderr, \"smflex scanner error: %s: %s\\n\",",
  "            yy_error_string(code), detail);",
  "  }",
  "  else {",
  "    fprintf(stderr, \"smflex scanner error: %s\\n\", yy_error_string(code));",
  "  }",
  "",
  "  /* For fatal-ish error messages, I want to have the best chance of",
  "   * seeing the message before the program dies. */",
  "  fflush(stderr);",
  "",
  "  /* I do not allow these error codes to be directly customized (for",
  "   * example with an #ifdef) because I want to limit the exposed",
  "   * configuration surface.  If an 'smflex' user wants different codes,",
  "   * they should define their own error handling function. */",
  "",
  "  if (code == yy_err_internal_error ||",
  "      code == yy_err_api_misuse) {",
  "    /* These codes indicate there is a bug in the program. */",
  "    exit(4);",
  "  }",
  "  else {",
  "    /* The rest are \"normal\" errors, such as an input read error or when",
  "     * some implementation limit is hit. */",
  "    exit(2);",
  "  }",
  "}",
  "",
  "",
  "%if cpp_interface",
  "",
  "yyFlexLexer::LexError::LexError(yy_error_code_t code, char const *detail) YY_NOEXCEPT",
  "  : std::exception(),",
  "    m_what(NULL),",
  "    m_code(code),",
  "    m_detail(detail)",
  "{}",
  "",
  "yyFlexLexer::LexError::LexError(LexError const &obj) YY_NOEXCEPT",
  "  : std::exception(obj),",
  "    m_what(NULL),            /* Do not copy obj.m_what! */",
  "    m_code(obj.m_code),",
  "    m_detail(obj.m_detail)",
  "{}",
  "",
  "yyFlexLexer::LexError::~LexError() YY_NOEXCEPT",
  "{",
  "  clearWhat();",
  "}",
  "",
  "void yyFlexLexer::LexError::clearWhat() YY_NOEXCEPT",
  "{",
  "  if (m_what) {",
  "    /* I use the 'flex' allocation functions for 'm_what' so I can",
  "     * use their debug and failure injection facilities. */",
  "    yy_flex_free(m_what);",
  "    m_what = NULL;",
  "  }",
  "}",
  "",
  "yyFlexLexer::LexError& yyFlexLexer::LexError::operator=(LexError const &obj) YY_NOEXCEPT",
  "{",
  "  if (this != &obj) {",
  "    this->std::exception::operator=(obj);",
  "",
  "    /* We do not copy obj.m_what because of the risk of throwing.  But",
  "     * we can't leave the old data either. */",
  "    this->clearWhat();",
  "",
  "    this->m_code = obj.m_code;",
  "    this->m_detail = obj.m_detail;",
  "  }",
  "  return *this;",
  "}",
  "",
  "char const *yyFlexLexer::LexError::what() const YY_NOEXCEPT",
  "{",
  "  try {",
  "    if (!m_what) {",
  "      /* Build the message. */",
  "      std::ostringstream oss;",
  "      if (m_detail) {",
  "        oss << \"smflex scanner error: \" << yy_error_string(m_code)",
  "            << \": \" << m_detail;",
  "      }",
  "      else {",
  "        oss << \"smflex scanner error: \" << yy_error_string(m_code);",
  "      }",
  "",
  "      /* Transfer it into 'm_what'. */",
  "      std::string str = oss.str();",
  "      m_what = (char*)yy_flex_alloc(str.size()+1);",
  "      if (!m_what) {",
  "        throw std::bad_alloc();        /* Go to the 'catch'. */",
  "      }",
  "      strcpy(m_what, str.c_str());",
  "    }",
  "",
  "    return m_what;",
  "  }",
  "  catch (...) {",
  "    return \"smflex scanner error (description unavailable due to failure in 'what()' method)\";",
  "  }",
  "}",
  "",
  "void yyFlexLexer::yym_error(yy_error_code_t code, char const *detail) const",
  "{",
  "  throw LexError(code, detail);",
  "}",
  "",
  "%endif",
  "",
  "",
  "void yy_less_text(yy_lexer_t *yy_lexer, int new_yy_leng)",
  "{",
  "  if (!YY_API_PRECONDITION(0 <= new_yy_leng &&",
  "                                new_yy_leng <= yy_lexer->yy_leng)) {",
  "    return;",
  "  }",
  "",
  "  /* Undo effects of setting up yy_text. */",
  "  yy_lexer->yy_text[yy_lexer->yy_leng] = yy_lexer->yy_hold_char;",
  "",
  "  /* Move the end-of-token pointer to the specified location. */",
  "  yy_lexer->yy_c_buf_p = yy_lexer->yy_text + new_yy_leng;",
  "  yy_lexer->yy_leng = new_yy_leng;",
  "",
  "  /* Re-insert the temporary NUL terminator. */",
  "  yy_lexer->yy_hold_char = *(yy_lexer->yy_c_buf_p);",
  "  *(yy_lexer->yy_c_buf_p) = '\\0';",
  "}",
  "",
  "",
  "/* When this symbol is defined, enable mechanisms to inject failures",
  " * into the allocator routines. */",
  "#ifdef YY_ALLOCATOR_FAILURE_INJECTION",
  "/* Number of 'alloc' calls before we inject a failure. */",
  "unsigned yy_alloc_failure_countdown = 0;",
  "#endif",
  "",
  "static long yy_num_allocated_objects = 0;",
  "",
  "static void *yy_flex_alloc(size_t size)",
  "{",
  "  void *ret;",
  "",
  "  YY_DEBUG_LOG_MEM(\"yy_flex_alloc\", size);",
  "#ifdef YY_ALLOCATOR_FAILURE_INJECTION",
  "  if (--yy_alloc_failure_countdown == 0) {",
  "    YY_DEBUG_LOG_MEM(\"alloc_fail\", size);",
  "    return NULL;",
  "  }",
  "#endif",
  "",
  "  ret = malloc(size);",
  "  if (ret) {",
  "    yy_num_allocated_objects++;",
  "  }",
  "  return ret;",
  "}",
  "",
  "static void yy_flex_free(void *ptr)",
  "{",
  "  if (ptr) {",
  "    yy_num_allocated_objects--;",
  "    YY_DEBUG_LOG_MEM(\"yy_flex_free\", yy_num_allocated_objects);",
  "  }",
  "  free(ptr);",
  "}",
  "",
  "",
  "void yy_check_for_memory_leaks()",
  "{",
  "  if (yy_num_allocated_objects != 0) {",
  "    fprintf(stderr, \"yy_check_for_memory_leaks: leaked %ld objects\\n\",",
  "            yy_num_allocated_objects);",
  "    exit(4);",
  "  }",
  "}",
  "",
  "%if cpp_interface",
  "/*static*/ void yyFlexLexer::yym_check_for_memory_leaks()",
  "{",
  "  yy_check_for_memory_leaks();",
  "}",
  "%endif",
  "",
  "",
  "void yy_set_start_state(yy_lexer_t *yy_lexer, int state)",
  "{",
  "  YY_SET_START_STATE(state);",
  "}",
  "",
  "%if cpp_interface",
  "void yyFlexLexer::yym_set_start_state(int state)",
  "{",
  "  yy_set_start_state(&yym_lexer_state, state);",
  "}",
  "%endif",
  "",
  "",
  "int yy_get_start_state(yy_lexer_t const *yy_lexer)",
  "{",
  "  return YY_GET_START_STATE();",
  "}",
  "",
  "%if cpp_interface",
  "int yyFlexLexer::yym_get_start_state() const",
  "{",
  "  return yy_get_start_state(&yym_lexer_state);",
  "}",
  "%endif",
  "",
  "",
  "int yy_read_input_with_fread(yy_lexer_t *yy_lexer,",
  "  void *dest, int size)",
  "{",
  "  FILE *input_file = (FILE*)(yy_lexer->yy_input_stream);",
  "",
  "  int n = fread(dest, 1, size, input_file);",
  "  if (n == 0 && ferror(input_file)) {",
  "    return -1;",
  "  }",
  "  return n;",
  "}",
  "",
  "",
  "%if use_read",
  "int yy_read_input_with_read(yy_lexer_t *yy_lexer,",
  "  void *dest, int size)",
  "{",
  "  FILE *input_file = (FILE*)(yy_lexer->yy_input_stream);",
  "",
  "  int n = read(fileno(input_file), dest, size);",
  "  if (n < 0) {",
  "    return -1;",
  "  }",
  "  return n;",
  "}",
  "%endif",
  "",
  "",
  "int yy_write_output_with_fwrite(yy_lexer_t *yy_lexer,",
  "  void const *dest, int size)",
  "{",
  "  FILE *output_file = (FILE*)(yy_lexer->yy_output_stream);",
  "",
  "  size_t n = fwrite(dest, 1, size, output_file);",
  "  if (n == (size_t)size) {",
  "    return size;",
  "  }",
  "  else {",
  "    return -1;",
  "  }",
  "}",
  "",
  "",
  "int yy_wrap_return_1(yy_lexer_t *yy_lexer)",
  "{",
  "  return 1;      /* No more files. */",
  "}",
  "",
  "",
  "%if option_main",
  "%if !cpp_interface",
  "int main()",
  "{",
  "  /* Keep retrieving tokens and discarding them until EOF. */",
  "  yy_lexer_t lexer;",
  "  yy_construct(&lexer);",
  "  while (yy_lex(&lexer) != 0)",
  "    {} /* nothing */",
  "  yy_destroy(&lexer);",
  "",
  "  return 0;",
  "}",
  "%else",
  "int main()",
  "{",
  "  /* Keep retrieving tokens and discarding them until EOF. */",
  "%if option_yyclass",
  "  option_yyclass_name lexer;",
  "%else",
  "  yyFlexLexer lexer;",
  "%endif",
  "  while (lexer.yym_lex() != 0)",
  "    {} /* nothing */",
  "",
  "  return 0;",
  "}",
  "%endif",
  "%endif",
  "",
  "",
  "%if option_flex_compat",
  "      /* Remove flex compatibility aliases. */",
  "#undef ECHO",
  "#undef yyless",
  "#undef BEGIN",
  "#undef YY_START",
  "#undef YY_AT_BOL",
  "#undef yyterminate",
  "%if option_yy_read_character",
  "#undef input",
  "#undef yyinput",
  "%endif",
  "%if option_yy_unread_character",
  "#undef unput",
  "%endif",
  "%endif # option_flex_compat",
  "",
  "/* Remove undocumented YY_XXX macros I don't want leaking into the",
  " * namespace of section 3. */",
  "#undef YY_ERROR",
  "#undef YY_NEW_FILE",
  "#undef YY_WRAPPER_OBJECT",
  "",
  "/* Remove documented YY_XXX macros, as they cannot be used in section 3.",
  " * Most of them have yy_XXX alternatives that accept 'yy_lexer_t*'. */",
  "#undef YY_SET_START_STATE",
  "#undef YY_GET_START_STATE",
  "#undef YY_LESS_TEXT",
  "#undef YY_CURRENT_BUFFER",
  "#undef YY_FLUSH_CURRENT_BUFFER",
  "#undef YY_GET_BOL",
  "#undef YY_ECHO",
  "#undef YY_TERMINATE",
  "#undef yytext               /* TODO: Capitalize, underscore. */",
  "#undef yyleng               /* TODO: Capitalize, underscore. */",
  "%if option_yy_read_character",
  "#undef YY_READ_CHARACTER",
  "%endif",
  "%if option_yy_unread_character",
  "#undef YY_UNREAD_CHARACTER",
  "%endif",
  "#undef yyin                 /* TODO: Capitalize, underscore. */",
  "#undef yyout                /* TODO: Capitalize, underscore. */",
  "%if do_yylineno",
  "#undef yylineno             /* TODO: Capitalize, underscore. */",
  "%endif",
  "",
  "/* After this point, the user's section 3 code appears. */",
  0
};
