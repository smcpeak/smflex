<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SMFLEX</title>
  <style>
    html {
      font-family: Georgia, serif;
      font-size: 16px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 60em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      line-height: 1.5;
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul, dl {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
      hyphens: none;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    th.row2 {
      border-top: 0;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    td.numeric {
      text-align: right;
    }
    .highlight {
      background-color: #ddd;
    }
    .center {
      text-align: center;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script>
    // Ugly hack to remove the leading and trailing blank line from <pre><code> blocks, from:
    // https://stackoverflow.com/questions/14946908/how-can-i-ignore-leading-and-trailing-linebreaks-within-an-html-code-block-usi
    window.onload = function (){
      // Remove leading and trailing newlines code blocks.  The
      // final newline can be followed by spaces and it will still
      // be removed.
      //
      // NOTE: If the code begins with an HTML comment, that will
      // interfere with removing leading blank lines, even though the
      // comment is not shown in the display.  Therefore, place any
      // comments for "BEGIN example", etc., outside the "code" element.
      var pre = document.getElementsByTagName("code");
      for (var i = 0, len = pre.length; i < len; i++) {
        // Remove leading newlines from the first child.
        var text = pre[i].firstChild.nodeValue;
        pre[i].firstChild.nodeValue = text.replace(/^\n+/g, "");

        // Remove trailing newlines from the last child.  There
        // are multiple children if, for example, there is a 'span'
        // element in the middle.
        text = pre[i].lastChild.nodeValue;
        pre[i].lastChild.nodeValue = text.replace(/\n+[ ]*$/g, "");
      }
    }
  </script>
</head>
<body>
<header id="title-block-header">
  <h1 class="title">SMFLEX</h1>
  <p>Version 1.0.0-dev
</header>


<!-- ======================================================= -->
<h1 id="name">NAME</h1>

<p><code>smflex</code> - Scott McPeak's fast lexical analyzer generator


<!-- ======================================================= -->
<h1 id="synopsis">SYNOPSIS</h1>

<pre><code>
  smflex [options] input.lex [...]
</code></pre>

<p>Briefly, the options are as follows
   (see <a href="#options">Options</a> for more details):

<pre><code>
  Options that affect what input smflex accepts:

    --flex-compat    Activate aliases that provide partial flex compatibility.

  Options that affect what output smflex writes:

    -b               Generate backing-up information.
    -h, --help, -?   Print usage.
    -n               Write output with platform native line endings.
    -ooutput         Specify name of output file ["lex.yy.c" or "lex.yy.cc"].
    -p               Write performance report to stderr.
    -v               Write scanner statistics to stderr.
    -w               Suppress warnings.
    -L               Suppress #line directives.
    -T               Enable debug tracing of the table building process.
    -V, --version    Print version number and exit.

  Options that influence the interface (API) of the generated scanner:

    -+               Generate a scanner with a C++ interface.
    -Pprefix         Specify symbol name prefix in generated scanner ["yy"].

  Options that influence the behavior of the generated scanner:

    -7               Generate a 7-bit scanner [if -Cf or -CJ but not -Cfe or -CJe].
    -8               Generate an 8-bit scanner [opposite of -7].
    -d               Generate a debug mode scanner.
    -i               Generate a case-insensitive scanner.
    -s               Suppress the default "echo" rule.
    -B               Generate a batch (non-interactive) scanner [true].
    -C[aefFmr]*      Generate scanner with various table compression modes [-Cem].
    -I               Generate an interactive scanner.
</code></pre>

<p>
The values enclosed in square brackets are the defaults.  When no
default is indicated it means it defaults to off.



<!-- ======================================================= -->
<h1 id="overview">OVERVIEW</h1>

<p>This manual describes <code>smflex</code>, a tool for generating programs
that perform pattern-matching on text. The manual includes both tutorial
and reference sections:

<ul>

<li><a href="#description">Description</a>:
    a brief overview of the tool

<li><a href="#some-simple-examples">Some Simple Examples</a>:

<li><a href="#format-of-the-input-file">Format Of The Input File</a>:

<li><a href="#patterns">Patterns</a>:
    the extended regular expressions used by <code>smflex</code>

<li><a href="#rule-semantics">Rule Semantics</a>:
    the rules for determining what has been matched

<li><a href="#actions">Actions</a>:
    how to specify what to do when a pattern is matched

<li><a href="#the-generated-scanner">The Generated Scanner</a>:
    details regarding the scanner that <code>smflex</code> produces;
    how to control the input source

<li><a href="#start-conditions">Start Conditions</a>:
    introducing context into your scanners, and
    managing "mini-scanners"

<li><a href="#multiple-input-buffers">Multiple Input Buffers</a>:
    how to manipulate multiple input sources; how to
    scan from strings instead of files

<li><a href="#end-of-file-rules">End-of-file Rules</a>:
    special rules for matching the end of the input

<li><a href="#miscellaneous-macros">Miscellaneous Macros</a>:
    a summary of macros available to the actions

<li><a href="#values-available-to-the-user">Values Available To The User</a>:
    a summary of values available to the actions

<li><a href="#interfacing-with-yacc">Interfacing With Yacc</a>:
    connecting <code>smflex</code> scanners together with yacc parsers

<li><a href="#options">Options</a>:
    <code>smflex</code> command-line options, and the "%option"
    directive

<li><a href="#performance-considerations">Performance Considerations</a>:
    how to make your scanner go as fast as possible

<li><a href="#generating-cpp-scanners">Generating C++ Scanners</a>:
    the (experimental) facility for generating C++
    scanner classes

<li><a href="#incompatibilities-with-flex">Incompatibilities with Flex</a>:
    how Scott McPeak's <code>smflex</code> differs from
    Vern Paxson's <code>flex-2.5.4</code>

<li><a href="#incompatibilities-with-lex-and-posix">Incompatibilities With Lex And POSIX</a>:
    how <code>smflex</code> differs from AT&amp;T lex and the POSIX lex
    standard

<li><a href="#diagnostics">Diagnostics</a>:
    those error messages produced by <code>smflex</code> (or scanners
    it generates) whose meanings might not be apparent

<li><a href="#deficiencies-n-bugs">Deficiencies / Bugs</a>:
    known problems with <code>smflex</code>

<li><a href="#see-also">See Also</a>:
    other documentation, related tools

<li><a href="#author">Author</a>:
    includes contact information

</ul>


<!-- ======================================================= -->
<h1 id="description">DESCRIPTION</h1>

<p><code>smflex</code> is a tool for generating <em>scanners</em>: programs
which recognized lexical patterns in text. <code>smflex</code> reads the
given input files, or its standard input if no file names are given, for
a description of a scanner to generate. The description is in the form
of pairs of regular expressions and C code, called <em>rules</em>.  <code>smflex</code>
generates as output a C source file, <code>lex.yy.c</code>, which
defines a routine <code>yy_lex()</code>. This file is compiled and linked
with the <code>-lfl</code> library to produce an executable. When the
executable is run, it analyzes its input for occurrences of the regular
expressions. Whenever it finds one, it executes the corresponding C code.


<!-- ======================================================= -->
<h1 id="some-simple-examples">SOME SIMPLE EXAMPLES</h1>

<p>Let's start with some simple examples to get the flavor of how one uses
<code>smflex</code>. The following <code>smflex</code>
<a href="test/username.lex">input</a> specifies a
scanner which whenever it encounters the string "username" will replace
it with the user's login name:

<pre><!-- BEGIN example: "username.lex" fragment=true indent=4 --><code>
    %%
    username    printf("%s", getlogin());
</code><!-- END example --></pre>

<p>By default, any text not matched by a <code>smflex</code> scanner is
copied to the output, so the net effect of this scanner is to copy its
input file to its output with each occurrence of "username" expanded. In
this input, there is just one rule. "username" is the <em>pattern</em>
and the "printf" is the <em>action</em>. The "%%" marks the beginning
of the rules.

<p>Here's another simple <a href="test/count-lines-chars.lex">example</a>:

<pre><!-- BEGIN example: "count-lines-chars.lex" fragment=true indent=4 --><code>
            int num_lines = 0, num_chars = 0;

    %%
    \n      ++num_lines; ++num_chars;
    .       ++num_chars;

    %%
    int main() {
      yy_lexer_t lexer;
      yy_construct(&amp;lexer);
      yy_lex(&amp;lexer);
      printf("# of lines = %d, # of chars = %d\n",
             num_lines, num_chars);
      yy_destroy(&amp;lexer);
      return 0;
    }
</code><!-- END example --></pre>

<p>This scanner counts the number of characters and the number of
lines in its input (it produces no output other than the final report
on the counts). The first line declares two globals, "num_lines" and
"num_chars", which are accessible both inside <code>yy_lex()</code> and
in the <code>main()</code> routine declared after the second "%%". There
are two rules, one which matches a newline ("\n") and increments both the
line count and the character count, and one which matches any character
other than a newline (indicated by the "." regular expression).

<p>A somewhat more complicated
<a href="test/toy-pascal.lex">example</a>:

<pre><!-- BEGIN example: "toy-pascal.lex" fragment=true indent=4 --><code>
    /* scanner for a toy Pascal-like language */

    %{
    #include &lt;math.h&gt;            /* atof */
    #include &lt;stdlib.h&gt;          /* atoi */
    %}

    DIGIT    [0-9]
    ID       [a-zA-Z][a-zA-Z0-9]*

    %%

    {DIGIT}+              {
                            printf("An integer: %s (%d)\n", yytext,
                                   atoi(yytext));
                          }

    {DIGIT}+"."{DIGIT}*   {
                            printf("A float: %s (%g)\n", yytext,
                                   atof(yytext));
                          }

      /* Comments can go between rules, but must be indented. */
    if|then|begin|end|procedure|function|program        {
                            printf("A keyword: %s\n", yytext);
                          }

    {ID}                  printf("An identifier: %s\n", yytext);

    "'"[^'\n]*"'"         printf("A string: %s\n", yytext);

    [+*/()-]              printf("An operator: %s\n", yytext);
    [;.,]                 printf("A punctuator: %s\n", yytext);

    "{"[^}]*"}"           /* eat up comments, including multi-line */
    [ \t\n]+              /* eat up whitespace */

    .                     printf("Unrecognized character: %s\n", yytext);

    %%

    int main(int argc, char **argv)
    {
      yy_lexer_t lexer;
      yy_construct(&amp;lexer);
      lexer.yy_input_stream = (argc &gt;= 2)? fopen(argv[1], "r") : stdin;
      yy_lex(&amp;lexer);
      yy_destroy(&amp;lexer);
      return 0;
    }
</code><!-- END example --></pre>

<p>This is the beginnings of a simple scanner for a language like
Pascal. It identifies different types of <em>tokens</em> and reports on
what it has seen.

<p>The details of this example will be explained in the following
sections.


<!-- ======================================================= -->
<h1 id="format-of-the-input-file">FORMAT OF THE INPUT FILE</h1>

<p>The <code>smflex</code> input file consists of three sections, separated
by a line with just <code>%%</code> in it:

<pre><code>
    definitions
    %%
    rules
    %%
    user code
</code></pre>

<p>The <em>definitions</em> section contains declarations of simple
<em>name</em> definitions to simplify the scanner specification, and
declarations of <em>start conditions</em>, which are explained in the
<a href="#start-conditions">Start Conditions</a> section.

<p>Name definitions have the form:

<pre><code>
    name definition
</code></pre>

<p>The "name" is a word beginning with a letter or an underscore ('_')
followed by zero or more letters, digits, '_', or '-' (dash). The
definition is taken to begin at the first non-white-space character
following the name and continuing to the end of the line. The definition
can subsequently be referred to using "{name}", which will expand to
"(definition)". For example,

<pre><code>
    DIGIT    [0-9]
    ID       [a-zA-Z][a-zA-Z0-9]*
</code></pre>

<p>defines "DIGIT" to be a regular expression which matches a single
digit, and "ID" to be a regular expression which matches a letter
(lowercase or uppercase) followed
by zero-or-more letters-or-digits. A subsequent reference to

<pre><code>
    {DIGIT}+"."{DIGIT}*
</code></pre>

<p>is identical to

<pre><code>
    ([0-9])+"."([0-9])*
</code></pre>

<p>and matches one-or-more digits followed by a '.' followed by
zero-or-more digits.

<p>The <em>rules</em> section of the <code>smflex</code> input contains
a series of rules of the form:

<pre><code>
    pattern   action
</code></pre>

<p>where the pattern must be unindented and the action must begin on
the same line.

<p>See below for further description of <a href="#patterns">Patterns</a>,
<a href="#rule-semantics">Rule Semantics</a>, and
<a href="#actions">Actions</a>.

<p>Finally, the user code section is simply copied to
<code>lex.yy.c</code> verbatim. It is used for companion routines
which call or are called by the scanner. The presence of this section
is optional; if it is missing, the second <code>%%</code> in the input
file may be skipped, too.

<p>In the definitions and rules sections, any <em>indented</em> text or
text enclosed in <code>%{</code> and <code>%}</code> is copied verbatim
to the output (with the <code>%{}</code> delimiters removed). The
<code>%{}</code> delimiters must appear unindented on lines by themselves.

<p>In the rules section, comments can be placed between rules in
<code>/* the usual C notation */</code>, but must be
<strong>indented</strong>.

<p>In the rules section, any indented or <code>%{}</code> text appearing
before the first rule may be used to declare variables which are local
to the scanning routine and specify code to execute whenever the
scanning routine is entered.

<p>Indented or <code>%{}</code> text appearing in the rule section after
the first rule is also copied to the output, but its meaning is not
defined.

<p>In the definitions section (but not in the rules section), an
unindented comment (i.e., a line beginning with "<code>/*"</code>) is
also copied verbatim to the output up to the next "<code>*/</code>".


<!-- ======================================================= -->
<h1 id="patterns">PATTERNS</h1>

<p>The patterns in the input are written using an extended set of regular
expressions. These are:

<dl>

<dt><code>x</code>

<dd>match the character 'x'

<dt><code>.</code>

<dd>any character (byte) except newline

<dt><code>[xyz]</code>

<dd>a "character class"; in this case, the pattern matches either an
'x', a 'y', or a 'z'

<dt><code>[abj-oZ]</code>

<dd>a "character class" with a range in it; matches an 'a', a 'b', any
letter from 'j' through 'o', or a 'Z'

<dt><code>[^A-Z]</code>

<dd>a "negated character class", i.e., any character but those in the
class.  In this case, any character EXCEPT an uppercase letter.

<dt><code>[^A-Z\n]</code>

<dd>any character EXCEPT an uppercase letter or a newline

<dt><code>r*</code>

<dd>zero or more <code>r</code>'s, where <code>r</code> is any regular
expression

<dt><code>r+</code>

<dd>one or more <code>r</code>'s

<dt><code>r?</code>

<dd>zero or one <code>r</code>'s (that is, "an optional <code>r</code>")

<dt><code>r{2,5}</code>

<dd>anywhere from two to five <code>r</code>'s

<dt><code>r{2,}</code>

<dd>two or more <code>r</code>'s

<dt><code>r{4}</code>

<dd>exactly 4 <code>r</code>'s

<dt><code>{name}</code>

<dd>the expansion of the "name" definition (see "definitions"
    subsection of
    <a href="#format-of-the-input-file">Format of the Input File</a>)

<dt><code>"[xyz]\"foo"</code>

<dd>the literal string: [xyz]"foo

<dt><code>\X</code>

<dd>if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v', then the ANSI-C
interpretation of \x.  Otherwise, a literal 'X' (used to escape
operators such as '*')

<dt><code>\0</code>

<dd>a NUL character (ASCII code 0)

<dt><code>\123</code>

<dd>the character with octal value 123

<dt><code>\x2a</code>

<dd>the character with hexadecimal value 2a

<dt><code>(r)</code>

<dd>match an <code>r</code>; parentheses are used to override
precedence (see below)

<dt><code>rs</code>

<dd>the regular expression <code>r</code> followed by the
regular expression <code>s</code>; called "concatenation"

<dt><code>r|s</code>

<dd>either an <code>r</code> or an <code>s</code>

<dt><code>r/s</code>

<dd>an <code>r</code> but only if it is followed by an <code>s</code>.
The text matched by <code>s</code> is
included when determining whether this rule is the "longest
match", but is then returned to the input before the action is
executed.  So the action only sees the text matched by <code>r</code>.  This type of
pattern is called "trailing context".  (There are some combinations
of <code>r/s</code> that <code>smflex</code> cannot match correctly; see notes in the
<a href="#deficiencies-n-bugs">Deficiencies / Bugs</a> section below
regarding "dangerous trailing context".)

<dt><code>^r</code>

<dd>an <code>r</code>, but only at the beginning of a line (i.e., which
just starting to scan, or right after a newline has been scanned).

<dt><code>r$</code>

<dd>an <code>r</code>, but only at the end of a line (i.e., just
before a newline).  Equivalent to "r/\n".
Note that <code>smflex</code>'s notion of "newline" is exactly whatever the C
compiler used to compile <code>smflex</code> interprets '\n' as; in particular, on some
DOS systems you must either filter out \r's in the input yourself, or
explicitly use r/\r\n for "r$".

<dt><code>&lt;s&gt;r</code>

<dd>an <code>r</code>, but only in start condition <code>s</code> (see
<a href="#start-conditions">Start Conditions</a>)

<dt><code>&lt;s1,s2,s3&gt;r</code>

<dd>same, but in any of start conditions s1, s2, or s3

<dt><code>&lt;*&gt;r</code>

<dd>an <code>r</code> in any start condition, even an exclusive one.

<dt><code>&lt;&lt;EOF&gt;&gt;</code>

<dd>an end-of-file

<dt><code>&lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;</code>

<dd>an end-of-file when in start condition s1 or s2

</dl>

<p>Note that inside of a character class, all regular expression operators
lose their special meaning except escape ('\') and the character class
operators, '-', ']', and, at the beginning of the class, '^'.

<p>The regular expressions listed above are grouped according to
precedence, from highest precedence at the top to lowest at the
bottom. Those grouped together have equal precedence. For example,

<pre><code>
    foo|bar*
</code></pre>

<p>is the same as

<pre><code>
    (foo)|(ba(r*))
</code></pre>

<p>since the '*' operator has higher precedence than concatenation,
and concatenation higher than alternation ('|'). This pattern therefore
matches <em>either</em> the string "foo" <em>or</em> the string "ba"
followed by zero-or-more r's. To match "foo" or zero-or-more "bar"'s, use:

<pre><code>
    foo|(bar)*
</code></pre>

<p>and to match zero-or-more "foo"'s-or-"bar"'s:

<pre><code>
    (foo|bar)*
</code></pre>

<p>In addition to characters and ranges of characters, character
classes can also contain character class <em>expressions</em>. These
are expressions enclosed inside <code>[:</code> and <code>:]</code>
delimiters (which themselves must appear between the '[' and ']' of the
character class; other elements may occur inside the character class,
too). The valid expressions are:

<pre><code>
    [:alnum:] [:alpha:] [:blank:]
    [:cntrl:] [:digit:] [:graph:]
    [:lower:] [:print:] [:punct:]
    [:space:] [:upper:] [:xdigit:]
</code></pre>

<p>These expressions all designate a set of characters equivalent
to the corresponding standard C <code>isXXX</code> function. For
example, <code>[:alnum:]</code> designates those characters for
which <code>isalnum()</code> returns true - i.e., any alphabetic or
numeric. Some systems don't provide <code>isblank()</code>, so <code>smflex</code>
defines <code>[:blank:]</code> as a blank or a tab.

<p>For example, the following character classes are all equivalent:

<pre><code>
    [[:alnum:]]
    [[:alpha:][:digit:]
    [[:alpha:]0-9]
    [a-zA-Z0-9]
</code></pre>

<p>If your scanner is case-insensitive (the <code>-i</code> flag),
then <code>[:upper:]</code> and <code>[:lower:]</code> are equivalent
to <code>[:alpha:]</code>.

<p>Some notes on patterns:

<ul>

<li><p>A negated character class such as the example "[^A-Z]" above
    <em>will match a newline</em> unless "\n" (or an equivalent escape
    sequence) is one of the characters explicitly present in the negated
    character class (e.g., "[^A-Z\n]"). This is unlike how many other
    regular expression tools treat negated character classes, but
    unfortunately the inconsistency is historically entrenched. Matching
    newlines means that a pattern like [^"]* can match the entire input
    unless there's another quote in the input.

<li><p>A rule can have at most one instance of trailing context (the
    '/' operator or the '$' operator). The start condition, '^', and
    "&lt;&lt;EOF&gt;&gt;" patterns can only occur at the beginning of a
    pattern, and, as well as with '/' and '$', cannot be grouped inside
    parentheses. A '^' which does not occur at the beginning of a rule or a
    '$' which does not occur at the end of a rule loses its special properties
    and is treated as a normal character.

</ul>

<p>The following are illegal:

<pre><code>
    foo/bar$
    &lt;sc1&gt;foo&lt;sc2&gt;bar
</code></pre>

<p>Note that the first of these, can be written "foo/bar\n".

<p>The following will result in '$' or '^' being treated as a normal
character:

<pre><code>
    foo|(bar$)
    foo|^bar
</code></pre>

<p>If what's wanted is a "foo" or a bar-followed-by-a-newline, the
following could be used (the special '|' action is explained below):

<pre><code>
    foo      |
    bar$     /* action goes here */
</code></pre>

<p>A similar trick will work for matching a foo or a
bar-at-the-beginning-of-a-line.


<!-- ======================================================= -->
<h1 id="rule-semantics">RULE SEMANTICS</h1>

<p>When the generated scanner is run, it analyzes its input looking for
strings which match any of its active rule patterns. If it finds more than one match,
it takes the one matching the most text (for trailing context rules,
this includes the length of the trailing part, even though it will
then be returned to the input). If it finds two or more matches of the
same length, the rule listed first in the <code>smflex</code> input file
is chosen.

<p>Whether a rule is <em>active</em> depends on the scanner's current
<em>start condition</em> and whether and how the
rule is qualified with start conditions.  If you do not use any
start conditions, then all rules are always active.
See <a href="#start-conditions">Start Conditions</a> for more on this
aspect.

<p>Once the match is determined, the text corresponding to the match
(called the <em>token</em>) is made available in the global character
pointer <code>yytext</code>, and its length in the global integer
<code>yyleng</code>. The <em>action</em> corresponding to the matched
pattern is then executed (a more detailed description of <a href="#actions">actions</a> follows),
and then the remaining input is scanned for another match.

<p id="default-rule">If no match is found, then the <em>default rule</em> is executed:
the next character in the input is considered matched and copied to the
standard output. Thus, the simplest legal <code>smflex</code> input is:

<pre><code>
    %%
</code></pre>

<p>which generates a scanner that simply copies its input (one character
at a time) to its output.


<!-- ======================================================= -->
<h1 id="actions">ACTIONS</h1>

<p>Each pattern in a rule has a corresponding action, which can be
any arbitrary C statement. The pattern ends at the first non-escaped
whitespace character; the remainder of the line is its action. If the
action is empty, then when the pattern is matched the input token is
simply discarded. For example, here is the specification for a
<a href="test/zap-me.lex">program</a>
which deletes all occurrences of "zap me" from its input:

<pre><!-- BEGIN example: "zap-me.lex" fragment=true indent=4 --><code>
    %%
    "zap me"
</code><!-- END example --></pre>

<p>(It will copy all other characters in the input to the output since
they will be matched by the default rule.)

<p>Here is a <a href="test/normalize-whitespace.lex">program</a>
which compresses multiple blanks and tabs down to
a single blank, and throws away whitespace found at the end of a line:

<pre><!-- BEGIN example: "normalize-whitespace.lex" fragment=true indent=4 --><code>
    %%
    [ \t]+        putchar(' ');
    [ \t]+$       /* ignore this token */
</code><!-- END example --></pre>

<p>If the action contains a '{', then the action spans till the balancing
'}' is found, and the action may cross multiple lines. <code>smflex</code>
knows about C strings and comments and won't be fooled by braces found
within them, but also allows actions to begin with <code>%{</code> and
will consider the action to be all the text up to the next <code>%}</code>
(regardless of ordinary braces inside the action).

<p>An action consisting solely of a vertical bar ('|') means "same as
the action for the next rule." See below for an illustration.

<p>Actions can include arbitrary C code, including <code>return</code>
statements to return a value to whatever routine called
<code>yy_lex()</code>. Each time <code>yy_lex()</code> is called it
continues processing tokens from where it last left off until it either
reaches the end of the file or executes a return.

<p>Actions are free to modify <code>yytext</code> except for
lengthening it (adding characters to its end--these will overwrite
later characters in the input stream).

<p>Actions are free to modify <code>yyleng</code> except they should
not do so if the action also includes use of <code>yymore()</code>
(see below).


<h2 id="action-macros">Action Macros</h2>

<p>There are a number of macros that can be called from within
an action:

<ul>

<li id="yy_echo"><p><code>YY_ECHO</code> copies
    <a href="#yy_text"><code>yy_text</code></a>
    to the scanner's output
    (<a href="#yy_output_stream"><code>yy_output_stream</code></a>).

<li id="YY_SET_START_STATE-macro"><p><code>YY_SET_START_STATE(s)</code>
    places the scanner in
    <a href="#start-conditions">start condition</a>
    <code>s</code>.

    See also
    <a href="#yy_set_start_state"><code>yy_set_start_state</code></a>.

<li id="YY_GET_START_STATE-macro"><p><code>YY_GET_START_STATE</code>
    returns the current start state.

    See also
    <a href="#yy_get_start_state"><code>yy_get_start_state</code></a>.

<li><p><code>REJECT</code>
    directs the scanner to proceed on to the "second best" rule which
    matched the input (or a prefix of the input). The rule is chosen as
    described above in "How the Input is Matched", and
    <code>yytext</code> and <code>yyleng</code> set up appropriately. It
    may either be one which matched as much text as the originally
    chosen rule but came later in the <code>smflex</code> input file, or
    one which matched less text. For example, the
    <a href="test/reject-frob.lex">following</a> will both
    count the words in the input and call the routine special() whenever
    "frob" is seen:

    <pre><!-- BEGIN example: "reject-frob.lex" fragment=true indent=8 --><code>
                int word_count = 0;
        %%

        frob        special(); REJECT;
        [^ \t\n]+   ++word_count;
    </code><!-- END example --></pre>

    <p>Without the <code>REJECT</code>, any "frob"'s in the input would not
    be counted as words, since the scanner normally executes only one action
    per token. Multiple <code>REJECT</code>s are allowed, each one finding
    the next best choice to the currently active rule. For example, when
    the <a href="test/reject-abcd.lex">following scanner</a> scans the
    token "abcd", it will write "abcdabcaba"
    to the output:

    <pre><!-- BEGIN example: "reject-abcd.lex" fragment=true indent=8 --><code>
        %%
        a        |
        ab       |
        abc      |
        abcd     YY_ECHO; REJECT;
        .|\n     /* eat up any unmatched character */
    </code><!-- END example --></pre>

    <p>(The first three rules share the fourth's action since they use the
    special '|' action.)  Any use of <code>REJECT</code> imposes
    restrictions on scanner performance; see
    <a href="#performance-considerations">Performance Considerations</a>.

    <p>Be aware that, unlike the other special actions, <code>REJECT</code>
    is a <em>branch</em>; code immediately following it in the action will
    <em>not</em> be executed.

<li><p><code>yymore()</code>
    tells the scanner that the next time it matches a rule, the
    corresponding token should be <em>appended</em> onto the current
    value of <code>yytext</code> rather than replacing it. For example,
    given the input "mega-kludge" the
    <a href="test/yymore-mega-kludge.lex">following</a> will write
    "mega-mega-kludge" to the output:

    <pre><!-- BEGIN example: "yymore-mega-kludge.lex" fragment=true indent=8 --><code>
        %%
        mega-    YY_ECHO; yymore();
        kludge   YY_ECHO;
    </code><!-- END example --></pre>

    <p>First "mega-" is matched and echoed to the output. Then "kludge"
    is matched, but the previous "mega-" is still hanging around at the
    beginning of <code>yytext</code> so the <code>YY_ECHO</code> for the "kludge"
    rule will actually write "mega-kludge".

    <p>Two notes regarding use of <code>yymore()</code>. First,
    <code>yymore()</code> depends on the value of <code>yyleng</code>
    correctly reflecting the size of the current token, so you must not modify
    <code>yyleng</code> if you are using <code>yymore()</code>. Second,
    the presence of <code>yymore()</code> in the scanner's action entails
    a minor performance penalty in the scanner's matching speed.

<li id="YY_LESS_TEXT-macro"><p><code>YY_LESS_TEXT(n)</code>
    returns all but the first <code>n</code> characters of the current
    token back to the input stream, where they will be rescanned when
    the scanner looks for the next match.
    <a href="#yy_text"><code>yy_text</code></a> and
    <a href="#yy_leng"><code>yy_leng</code></a>
    are adjusted appropriately (e.g.,
    <code>yy_leng</code> will now be equal to <code>n</code>). For
    example, on the input "foobar" the
    <a href="test/yyless-foobar.lex">following</a> will write out
    "foobarbar":

    <pre><!-- BEGIN example: "yyless-foobar.lex" fragment=true indent=8 --><code>
        %%
        foobar    YY_ECHO; YY_LESS_TEXT(3);
        [a-z]+    YY_ECHO;
    </code><!-- END example --></pre>

    <p>An argument of 0 to <code>YY_LESS_TEXT</code> will cause the entire current
    input string to be scanned again. Unless you've changed how the scanner
    will subsequently process its input (using <code>YY_SET_START_STATE</code>, for
    example), this will result in an endless loop.

    <p>Outside of rule actions, the <code>YY_LESS_TEXT</code>
    macro is not available.  Instead, you can call the
    <a href="#yy_less_text"><code>yy_less_text</code></a> function.

<li><p id="yy_unread_character"><code>YY_UNREAD_CHARACTER(c)</code>
    puts the character <code>c</code> back onto the input stream. It
    will be the next character scanned. The
    <a href="test/unread-character-parenthesized.lex">following action</a> will take
    the current token and cause it to be rescanned enclosed in
    parentheses.

    <pre><!-- BEGIN example: "unread-character-parenthesized.lex" fragment=true indent=0 --><code>
    {
      int i;
      /* Copy yytext because YY_UNREAD_CHARACTER() trashes yytext */
      char *yycopy = strdup(yytext);
      YY_UNREAD_CHARACTER(')');
      for (i = yyleng - 1; i &gt;= 0; --i) {
        YY_UNREAD_CHARACTER(yycopy[i]);
      }
      YY_UNREAD_CHARACTER('(');
      free(yycopy);
    }
    </code><!-- END example --></pre>

    <p>Note that since each <code>YY_UNREAD_CHARACTER()</code> puts the given character
    back at the <em>beginning</em> of the input stream, pushing back strings
    must be done back-to-front.

    <p>An important potential problem when using <code>YY_UNREAD_CHARACTER()</code>
    is that
    a call to <code>YY_UNREAD_CHARACTER()</code> <em>destroys</em> the contents of
    <code>yytext</code>, starting with its rightmost character and devouring
    one character to the left with each call. If you need the value of yytext
    preserved after a call to <code>YY_UNREAD_CHARACTER()</code> (as in the above example),
    you must first copy it elsewhere.

    <p>Finally, note that you cannot put back <code>EOF</code> to attempt
    to mark the input stream with an end-of-file.

    <p>Use of this macro requires
    <code>%option yy_unread_character</code>.

    <p>Outside of rule actions, the <code>YY_UNREAD_CHARACTER</code>
    macro is not available.  Instead, you can call the
    <code>void yy_unread_character(yy_lexer_t *lexer, int c)</code> function.

<li><p id="yy_read_character"><code>YY_READ_CHARACTER()</code>
    reads the next character from the input.  Once a character is read in
    this way, it is considered "consumed", and will not be subsequently
    matched by scanner rules.  For example, the
    <a href="test/read-character-c-comments.lex">following</a> is one way to eat up C comments:

    <pre><!-- BEGIN example: "read-character-c-comments.lex" fragment=true indent=8 --><code>
        %%
        "/*"      {
                    int c;
                    for (;;) {
                      while ( (c = YY_READ_CHARACTER()) != '*' &amp;&amp; c != EOF )
                        {}    /* eat up text of comment */

                      if (c == '*') {
                        while ( (c = YY_READ_CHARACTER()) == '*' )
                          {}
                        if (c == '/') {
                          break;    /* found the end */
                        }
                      }

                      if (c == EOF) {
                        error("EOF in comment");
                        break;
                      }
                    }
                  }
    </code><!-- END example --></pre>

    <p>Use of this macro requires
    <code>%option yy_read_character</code>.

    <p>Outside of rule actions, the <code>YY_READ_CHARACTER</code>
    macro is not available.  Instead, you can call the
    <code>int yy_read_character(yy_lexer_t *lexer)</code> function.

<li><p><code>YY_FLUSH_CURRENT_BUFFER</code>
    flushes the scanner's internal buffer so that the next time the
    scanner attempts to match a token, it will first refill the buffer
    using
    <a href="#yy_read_input_function"><code>yy_read_input_function</code></a>
    This action is a special case of the more general
    <code>yy_flush_buffer()</code> function, described in
    <a href="#multiple-input-buffers">Multiple Input Buffers</a>.

<li><p><code>yyterminate()</code>
    can be used in lieu of a return statement in an action. It
    terminates the scanner and returns a 0 to the scanner's caller,
    indicating "all done". By default, <code>yyterminate()</code> is
    also called when an end-of-file is encountered. It is a macro and
    may be redefined.

</ul>

<p>
Be aware that the above macros <em>only</em> work from actions in
section 2 of the scanner definition.  Some have equivalent functions
that can be called from elsewhere, but those have a different name
(generally starting with "<code>yy_</code>" instead of just
"<code>yy</code>"), and accept an additional <code>yy_lexer_t*</code>
parameter.


<!-- ======================================================= -->
<h1 id="the-generated-scanner">THE GENERATED SCANNER</h1>

<p>TODO: Rename this section to "The C API".

<p>The output of <code>smflex</code> is the file <code>lex.yy.c</code>,
which contains the scanning routine <code>yy_lex()</code>, a number of
tables used by it for matching tokens, and a number of auxiliary routines
and macros. By default, <code>yy_lex()</code> is defined as follows:

<pre><code>
    int yy_lex(yy_lexer_t *yy_lexer)
    {
      ... various definitions and the actions in here ...
    }
</code></pre>

<p>Whenever <code>yy_lex()</code> is called, it scans tokens from the
input file <code>yy_lexer-&gt;yy_input_stream</code> (which defaults to stdin). It
continues until it either reaches an end-of-file (at which point it
returns the value 0) or one of its actions executes a <code>return</code>
statement.

<p>If the scanner reaches an end-of-file, subsequent calls are undefined
unless either <code>yyin</code> is pointed at a new input file (in which
case scanning continues from that file), or <code>yy_restart()</code>
is called. <code>yy_restart()</code> takes one argument, a <code>FILE *</code>
pointer (which can be nil, if you've set up
<a href="#yy_read_input_function"><code>yy_read_input_function</code></a>
to scan from a source other than <code>yyin</code>), and initializes
<code>yyin</code> for scanning from that file. Essentially there is no
difference between just assigning <code>yyin</code> to a new input file
or using <code>yy_restart()</code> to do so; the latter is available
for compatibility with previous versions of <code>flex</code>,
and because it can be used to switch input files in the middle
of scanning. It can also be used to throw away the current input
buffer, by calling it with an argument of <code>yyin</code>; but
better is to use <code>YY_FLUSH_CURRENT_BUFFER</code> (see above). Note that
<code>yy_restart()</code> does <em>not</em> reset the start condition to
<code>INITIAL</code> (see <a href="#start-conditions">Start Conditions</a>).

<p>If <code>yy_lex()</code> stops scanning due to executing a
<code>return</code> statement in one of the actions, the scanner may
then be called again and it will resume scanning where it left off.

<p>If the scanner is built with the <code>-B</code> / <code>%option batch</code>
option, the scanner uses
block reads rather than simple <code>getc()</code> calls to read
characters from <code>yyin</code>. The nature of how it gets its input
can be controlled by setting
<a href="#yy_read_input_function"><code>yy_read_input_function</code></a>.

<p>When the scanner receives an end-of-file indication from
<code>yy_read_input_function</code>,
the scanner terminates, returning 0 to its caller.  The start
condition remains unchanged; it does <em>not</em> revert to
<code>INITIAL</code>.

<p>If you instead want the scanner to continue scanning a new file, as
if its contents came right after the previous one, then set
<a href="#yy_wrap_function"><code>yy_wrap_function</code></a>.

<p>Three routines are available for scanning from in-memory buffers rather
than files: <code>yy_scan_string()</code>, <code>yy_scan_bytes()</code>,
and <code>yy_scan_buffer()</code>. See the discussion of them in
the section <a href="#multiple-input-buffers">Multiple Input Buffers</a>.

<p>The scanner writes its <code>YY_ECHO</code> output to the
<code>yyout</code> global (default, stdout), which may be redefined by
the user simply by assigning it to some other <code>FILE</code> pointer.


<h2 id="yy_lexer_t">The yy_lexer_t structure</h2>

<p>The <code>yy_lexer_t</code> structure contains all of the scanner
state except for local variables inside the <code>yy_lex()</code>
function.  All scanner operations require a <code>yy_lexer_t</code>;
it is the central structure of the C API.

<p>However, when using the <code>yyFlexLexer</code> C++ wrapper class,
this structure should not be directly accessed.  The descriptions below
apply only to direct use of the C API.

<p>Within this document, a "public" member is one that the client is
allowed to both read and write.  <code>yy_lexer_t</code> contains the
following public members:

<dl>

<dt id="yy_client_data"><code>void *yy_client_data;</code>

    <dd><p>
    This pointer is available for use by the client of the API to
    associate any additional data with the <code>yy_lexer_t</code>
    object.  It is initially <code>NULL</code>.

<dt id="yy_text"><code>char *yy_text;</code>

    <dd><p>
    After a rule pattern has been matched, this points at the matched
    text within the scanning buffer.  It is NUL-terminated.  It is only
    valid while an action is executing; you must make a copy of the
    data to use it for longer than that.

<dt id="yy_leng"><code>int yy_leng;</code>

    <dd><p>
    When <code>yy_text</code> is valid, <code>yy_leng</code> gives the
    length of the matched text, in bytes.

<dt id="yy_input_stream"><code>yy_input_stream_t *yy_input_stream;</code>

    <dd><p>
    Usually, this is a pointer to some object that acts as an input
    source for the scanner.  However, exactly what it is, and whether it
    is even used, are determined by <code>yy_read_input_function</code>,
    and hence ultimately up to the client.  Consequently, the type
    <code>yy_input_stream_t</code> is more of a default or a suggestion
    than a requirement.

    <p>When using the C API, this is initialized to <code>stdin</code>,
    which has type <code>FILE*</code>.

    <p>TODO: What exactly are the rules for changing this value?

<dt id="yy_output_stream"><code>yy_output_stream_t *yy_output_stream;</code>

    <dd><p>
    Similar to the preceding, this is normally an object capable of
    receiving output, but precisely what it is is determined by the
    <code>yy_write_output_function</code>.

    <p>When using the C API, this is initialized to <code>stdout</code>.

<dt id="yy_read_input_function">
    <code>int (*yy_read_input_function)(yy_lexer_t *yy_lexer, void *dest, int size);</code>

    <dd><p>
    Read up to <code>size</code> bytes into <code>dest</code>.  The
    presumed source of the data is <code>yy_input_stream</code>, but
    that is up to the client.  Return the number of bytes read, or 0 for
    end of file, or -1 for a read error.

    <p>
    The initial value depends on the <code>smflex</code> options, but by
    default, it uses <code>fread</code> to read from
    <code>yy_input_stream</code>.  The user of the API can customize how
    input is read by changing this function pointer.

    <p>
    An <a href="test/yy-input-redefined.lex">example</a> showing a
    definition of <code>yy_read_input_function</code> and how to
    activate it for scanning is:

    <pre><!-- BEGIN example: "yy-input-redefined.lex" fragment=true indent=8 --><code>
        int my_read_input(yy_lexer_t *yy_lexer, void *dest, int size)
        {
          int c = getchar();
          c = tolower(c);    /* Just for demonstration purposes. */
          if (c == EOF) {
            return 0;
          }
          else {
            ((char*)dest)[0] = c;
            return 1;
          }
        }

        int main()
        {
          yy_lexer_t lexer;
          yy_construct(&amp;lexer);

          /* Alter how the scanner gets its input. */
          lexer.yy_read_input_function = &amp;my_read_input;

          while (yy_lex(&amp;lexer))
            {}
          yy_destroy(&amp;lexer);
          return 0;
        }
    </code><!-- END example --></pre>

    <p>This definition will change the input processing to occur one character
    at a time.  (The <code>-I</code> / <code>%option interactive</code>
    option also has that effect.)  For demonstration purposes, it also
    lowercases all input as it is read.

<dt id="yy_write_output_function">
    <code>int (*yy_write_output_function)(struct yy_lexer_struct *yy_lexer, void const *src, int size);</code>

    <dd><p>
    Write <code>size</code> bytes from <code>src</code>.  The presumed
    destination is <code>yy_output_stream</code>.  Return
    <code>size</code> for success or -1 for error.

    <p>With default settings, the initial value is a function that
    writes to <code>yy_output_stream</code> using <code>fwrite</code>.

    <p>The <a href="#yy_echo"><code>YY_ECHO</code></a> macro, which is
    implicitly used by the <a href="#default-rule">default rule</a>,
    calls this function.

<dt id="yy_wrap_function"><code>int (*yy_wrap_function)(yy_lexer_t *yy_lexer);</code>

    <dd><p>
    When the end of the current input is encountered,
    the scanner calls this to determine what to do
    next.  It can return true, meaning is no more input, and the scanner
    will terminate.  It can instead return false (0) after setting up a
    new input source, meaning the scanner will continue scanning with
    that new input.

    <p>
    The initial value is
    <a href="#yy_wrap_return_1"><code>yy_wrap_return_1</code></a>.

<dt id="yy_error_function">
    <code>void (*yy_error_function)(yy_lexer_t *yy_lexer, yy_error_code_t code, char const *detail);</code>

    <dd><p>
    When an error occurs during scanning, such as running out of memory
    or the input source reports a read error, this function is called.
    If the function returns, the scanner tries to recover by returning
    control to the client, for example by pretending the end of the input
    was reached.  The client should cease scanning activities and use
    <code>yy_destroy</code> to release resources.

    <p>
    <code>code</code> describes the error with sufficient precision to
    allow automatic recovery by the client.
    See <a href="#diagnostics">Diagnostics</a> for a list
    of error codes and their descriptions.  <code>detail</code> is
    optional (possibly <code>NULL</code>) additional information that
    may be of interest to a human but should not be mechanically
    inspected.

    <p>
    The initial value is
    <a href="#yy_error_print_and_exit"><code>yy_error_print_and_exit</code></a>.

<dt id="yy_lineno"><code>int yy_lineno;</code>

    <dd><p>
    When <code>%option yylineno</code> is set, this field exists, has
    initial value 1, and is incremented once for every newline character
    in <code>yy_text</code> when a token is matched.  It is also
    incremented for every newline seen by <a
    href="#yy_read_character"><code>yy_read_character</code></a>, and
    decremented once for every newline seen by <a
    href="#yy_unread_character"><code>yy_unread_character</code></a>.

    <p>This value is not otherwise manipulated by the scanning engine.
    In particular, it is not affected by
    <a href="#yy_restart"><code>yy_restart</code></a>,
    <a href="#yy_switch_to_buffer"><code>yy_switch_to_buffer</code></a>,
    <a href="#yy_wrap_function"><code>yy_wrap_function</code></a> activity,
    etc.  If you want line numbers tracked across multiple input
    sources, you have to save and restore this value yourself at
    appropriate times.  The engine only knows to increment it when
    newline characters are matched.

<dt id="yy_flex_debug"><code>int yy_flex_debug;</code>

    <dd><p>
    When <code>%option debug</code> is set, this field exists with
    initial falue true.  The client may change it at any time; the
    scanner does not.

    <p>
    When this field is true, and a rule is matched, the scanner will
    write to <code>stderr</code> a line of the form:

    <pre><code>
        --accepting rule at line 53 ("the matched text")
    </code></pre>

    <p>The line number refers to the location of the rule in the file
    defining the scanner (i.e., the file that was fed to <code>smflex</code>). Messages
    are also generated when the scanner backs up, accepts the default rule,
    reaches the end of its input buffer (or encounters a NUL; at this point,
    the two look the same as far as the scanner is concerned), or reaches
    an end-of-file.

<dt id="yy_current_buffer"><code>yy_buffer_state_t *yy_current_buffer;</code>

    <dd><p>
    The input source we are currently reading from, and a buffer
    in front of it.

    <p>This member is <em>semi-public</em>, meaning it can be directly
    read by the client, but cannot be directly written.  Instead, use
    <a href="#yy_switch_to_buffer"><code>yy_switch_to_buffer</code></a>.

</dl>

<p>Within section 2 actions, several convenience macros provide access
to associated fields without the need for an explicit object:

<pre><code>
    #define YY_TEXT           (yy_lexer-&gt;yy_text)
    #define YY_LENG           (yy_lexer-&gt;yy_leng)
    #define YY_CURRENT_BUFFER (yy_lexer-&gt;yy_current_buffer)
</code></pre>

<p>These functions are available for inspecting and manipulating the
text matched by a rule:

<dl>

<dt id="yy_less_text"><code>void yy_less_text(yy_lexer_t *yy_lexer, int new_yy_leng);</code>

    <dd><p>
    Put a suffix of the matched text back into the read buffer so it
    will be scanned next.  This function can only be called when <a
    href="#yy_text"><code>yy_text</code></a> could be accessed.
    <code>new_yy_leng</code> must be in <code>[0,yy_leng]</code>, and it
    determines the new value of <a
    href="#yy_leng"><code>yy_leng</code></a>. The amount of text put
    back is the difference between the old and new lengths.

</dl>

<p id="start-state-functions">These functions are available for manipulating the current
<a href="#start-conditions">start state</a>:

<dl>

<dt id="yy_set_start_state"><code>void yy_set_start_state(yy_lexer_t *yy_lexer, int state);</code>

    <dd><p>
    Set the start state of <code>yy_lexer</code> to <code>state</code>.

<dt id="yy_get_start_state"><code>int yy_get_start_state(yy_lexer_t *yy_lexer);</code>

    <dd><p>
    Get the current start state.

</dl>

<p>Additionally, the functions
<a href="#yy_push_state"><code>yy_push_state</code></a>,
<a href="#yy_pop_state"><code>yy_pop_state</code></a>, and
<a href="#yy_top_state"><code>yy_top_state</code></a> are
available to manipulate the stack of start states, as  documented under
<a href="#start-conditions">Start Conditions</a>.

<p>These functions are the pre-defined handlers for the function
pointers in <code>yy_lexer_t</code>:

<dl>

<dt id="yy_wrap_return_1"><code>int yy_wrap_return_1(yy_lexer_t *yy_lexer);</code>

    <dd><p>
    Return 1, meaning no more files.

<dt id="yy_error_print_and_exit">
    <code>void yy_error_print_and_exit(yy_lexer_t *yy_lexer, yy_error_code_t code, char const *detail);</code>

    <dd><p>
    Prints a message to standard error and exits with a non-zero exit code.

</dl>

<p>These functions relate to error handling and diagnostics:

<dl>

<dt id="yy_get_error">
    <code>yy_error_code_t yy_get_error(yy_lexer_t *yy_lexer);</code>

    <dd><p>
    Return the code of the error the scanner encountered, or
    <code>yy_err_no_error</code> if none has
    been.  This can be used in situations where <a
    href="#yy_error_function"><code>yy_error_function</code></a> returns
    in order to signal to the client code that it must stop calling
    scanner functions.

<dt id="yy_error_string">
    <code>char const *yy_error_string(yy_error_code_t code);</code>

    <dd><p>
    Return an English string describing the given error
    <code>code</code> as a pointer to statically-allocated memory.

<dt id="yy_check_for_memory_leaks"><code>void yy_check_for_memory_leaks(void);</code>

    <dd><p>
    Fail an assertion if there are any objects allocated, across all
    scanner instances, that have not been freed.  This can be called
    after destroying all instances to check for memory leaks.

</dl>


<!-- ======================================================= -->
<h1 id="start-conditions">START CONDITIONS</h1>

<p>TODO: This section should be called "Start States", not "conditions".
There is nothing conditional about them.

<p><code>smflex</code> provides a mechanism for conditionally activating
rules. Any rule whose pattern is prefixed with "&lt;sc&gt;" will only be
active when the scanner is in the start condition named "sc". For example,

<pre><code>
    &lt;STRING&gt;[^"]*        { /* eat up the string body ... */
                ...
                }
</code></pre>

<p>will be active only when the scanner is in the "STRING" start
condition, and

<pre><code>
    &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
                ...
                }
</code></pre>

<p>will be active only when the current start condition is either
"INITIAL", "STRING", or "QUOTE".

<p>Start conditions are declared in the definitions (first) section of
the input using unindented lines beginning with either <code>%s</code>
or <code>%x</code> followed by a list of names. The former declares
<em>inclusive</em> start conditions, the latter <em>exclusive</em> start
conditions. A start condition is activated using the
<a href="#YY_SET_START_STATE-macro"><code>YY_SET_START_STATE</code></a>
action. Until the next <code>YY_SET_START_STATE</code> action is executed, rules
with the given start condition will be active and rules with other start
conditions will be inactive. If the start condition is <em>inclusive</em>,
then rules with no start conditions at all will also be active. If
it is <em>exclusive</em>, then <em>only</em> rules qualified with the
start condition will be active. A set of rules contingent on the same
exclusive start condition describe a scanner which is independent of
any of the other rules in the <code>smflex</code> input. Because of this,
exclusive start conditions make it easy to specify "mini-scanners" which
scan portions of the input that are syntactically different from the rest
(e.g., comments).

<p>If the distinction between inclusive and exclusive start conditions is
still a little vague, here's a simple example illustrating the connection
between the two. The set of rules:

<pre><code>
    %s example
    %%

    &lt;example&gt;foo   do_something();

    bar            something_else();
</code></pre>

<p>is equivalent to

<pre><code>
    %x example
    %%

    &lt;example&gt;foo   do_something();

    &lt;INITIAL,example&gt;bar    something_else();
</code></pre>

<p>Without the <code>&lt;INITIAL,example&gt;</code> qualifier, the
<code>bar</code> pattern in the second example wouldn't be active (i.e.,
couldn't match) when in start condition <code>example</code>. If we
just used <code>&lt;example&gt;</code> to qualify <code>bar</code>,
though, then it would only be active in <code>example</code> and not in
<code>INITIAL</code>, while in the first example it's active in both,
because in the first example the <code>example</code> startion condition
is an <em>inclusive</em> <code>(%s)</code> start condition.

<p>Also note that the special start-condition specifier
<code>&lt;*&gt;</code> matches every start condition. Thus, the above
example could also have been written;

<pre><code>
    %x example
    %%

    &lt;example&gt;foo   do_something();

    &lt;*&gt;bar    something_else();
</code></pre>

<p>The default rule (to <code>YY_ECHO</code> any unmatched character)
remains active in start conditions. It is equivalent to:

<pre><code>
    &lt;*&gt;.|\n     YY_ECHO;
</code></pre>

<p><code>YY_SET_START_STATE(0)</code> returns to the original state where only the
rules with no start conditions are active. This state can also be referred
to as the start-condition "INITIAL", so <code>YY_SET_START_STATE(INITIAL)</code> is
equivalent to <code>YY_SET_START_STATE(0)</code>.

<p><code>YY_SET_START_STATE</code> actions can also be given as indented code
at the beginning of the rules section. For example, the
<a href="test/begin-special.lex">following</a>
will cause the scanner to enter the "SPECIAL" start condition
whenever <code>yy_lex()</code> is called and the global variable
<code>enter_special</code> is true:

<pre><!-- BEGIN example: "yy-set-start-state-special.lex" fragment=true indent=4 --><code>
                    int enter_special;

    %x SPECIAL
    %%
                    if (enter_special) {
                      YY_SET_START_STATE(SPECIAL);
                    }

    &lt;SPECIAL&gt;token  {      /* ... etc. ... */
</code><!-- END example --></pre>

<p>To illustrate the uses of start conditions,
<a href="test/expect-floats.lex">here</a> is a scanner which
provides two different interpretations of a string like "123.456". By
default it will treat it as three tokens, the integer "123", a dot ('.'),
and the integer "456". But if the string is preceded earlier in the
line by the string "expect-floats" it will treat it as a single token,
the floating-point number 123.456:

<pre><!-- BEGIN example: "expect-floats.lex" fragment=true indent=4 --><code>
    %{
    #include &lt;math.h&gt;            /* atof */
    #include &lt;stdlib.h&gt;          /* atoi */
    %}
    %s expect

    %%
    expect-floats       YY_SET_START_STATE(expect);

    &lt;expect&gt;[0-9]+"."[0-9]+  {
                          printf("found a float: %f\n", atof(yytext));
                        }
    &lt;expect&gt;\n          {
                          /* That's the end of the line, so we need another
                           * "expect-floats" before we'll recognize any more
                           * floats. */
                          YY_SET_START_STATE(INITIAL);
                        }

    [0-9]+              {
                          printf("found an integer: %d\n", atoi(yytext));
                        }

    "."                 printf("found a dot\n");
</code><!-- END example --></pre>

<p><a href="test/discard-c-comments.lex">Here</a> is a scanner which
recognizes (and discards) C comments while
maintaining a count of the current input line.

<pre><!-- BEGIN example: "discard-c-comments.lex" fragment=true indent=4 --><code>
    %x comment
                            int line_num = 1;
    %%
    "/*"                    YY_SET_START_STATE(comment);
    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
    &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;"*"+"/"        YY_SET_START_STATE(INITIAL);
</code><!-- END example --></pre>

<p>This scanner goes to a bit of trouble to match as much text as possible
with each rule. In general, when attempting to write a high-speed scanner
try to match as much possible in each rule, as it's a big win.

<p>Note that start-conditions names are really integer values and can
be stored as such. Thus, the above could be extended in the
<a href="test/discard-c-comments2.lex">following</a>
fashion:

<pre><!-- BEGIN example: "discard-c-comments2.lex" fragment=true indent=4 --><code>
    %x comment foo
                            int line_num = 1;
                            int comment_caller = INITIAL;
    %%
    "/*"                    {
                              comment_caller = INITIAL;
                              YY_SET_START_STATE(comment);
                            }

    &lt;foo&gt;"/*"               {
                              comment_caller = foo;
                              YY_SET_START_STATE(comment);
                            }

    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
    &lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;"*"+"/"        YY_SET_START_STATE(comment_caller);
</code><!-- END example --></pre>

<p>Furthermore, you can access the current start condition using the
integer-valued <code>YY_GET_START_STATE()</code> macro. For example, the above
assignments to <code>comment_caller</code> could instead be written

<pre><code>
    comment_caller = YY_GET_START_STATE();
</code></pre>

<p>Beware that start conditions do not have their own name-space;
<code>%s</code>'s and <code>%x</code>'s declare names in the same
fashion as <code>#define</code>'s.

<p>Finally, <a href="test/gather-c-string.lex">here</a>'s an example
of how to match C-style quoted string literals
using exclusive start conditions, including expanded escape sequences
(but not including checking for a string that's too long):

<pre><!-- BEGIN example: "gather-c-string.lex" fragment=true indent=4 --><code>
    %x str
            char string_buf[MAX_STR_LITERAL_LEN];
            char *string_buf_ptr;
    %%
    \"      string_buf_ptr = string_buf; YY_SET_START_STATE(str);

    &lt;str&gt;\"        { /* saw closing quote - all done */
              YY_SET_START_STATE(INITIAL);
              *string_buf_ptr = '\0';

              /* Inform caller that we saw and interpreted a string literal.
               * The caller can collect it from 'string_buf'. */
              return TOK_STR_LITERAL;
            }

    &lt;str&gt;\n        {
              printf("unterminated string literal\n");
              YY_SET_START_STATE(INITIAL);     /* Recover from the error. */
            }

    &lt;str&gt;\\[0-7]{1,3} {
              /* Octal escape sequence. */
              int result = (int)strtol(yytext+1, NULL /*endp*/, 8 /*base*/);
              assert(0 &lt;= result &amp;&amp; result &lt;= 0xFF);
              *string_buf_ptr++ = result;
            }

    &lt;str&gt;\\[0-9]+ {
              /* generate error - bad escape sequence; something
               * like '\48' or '\0777777' */
              printf("bad escape sequence: \"%s\"\n", yytext);
            }

    &lt;str&gt;\\n  *string_buf_ptr++ = '\n';
    &lt;str&gt;\\t  *string_buf_ptr++ = '\t';
    &lt;str&gt;\\r  *string_buf_ptr++ = '\r';
    &lt;str&gt;\\b  *string_buf_ptr++ = '\b';
    &lt;str&gt;\\f  *string_buf_ptr++ = '\f';

    &lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];

    &lt;str&gt;[^\\\n\"]+        {
              char *p = yytext;
              while (*p) {
                *string_buf_ptr++ = *p++;
              }
            }
</code><!-- END example --></pre>

<p>Often, such as in some of the examples above, you wind up writing a
whole bunch of rules all preceded by the same start condition(s). <code>smflex</code>
makes this a little easier and cleaner by introducing a notion of start
condition <em>scope</em>. A start condition scope is begun with:

<pre><code>
    &lt;SCs&gt;{
</code></pre>

<p>where <code>SCs</code> is a list of one or more start
conditions. Inside the start condition scope, every rule automatically has
the prefix <code>&lt;SCs&gt;</code> applied to it, until a <code>'}'</code>
which matches the initial <code>'{'</code>. So, for example,

<pre><code>
    &lt;ESC&gt;{
        "\\n"   return '\n';
        "\\r"   return '\r';
        "\\f"   return '\f';
        "\\0"   return '\0';
    }
</code></pre>

<p>is equivalent to:

<pre><code>
    &lt;ESC&gt;"\\n"  return '\n';
    &lt;ESC&gt;"\\r"  return '\r';
    &lt;ESC&gt;"\\f"  return '\f';
    &lt;ESC&gt;"\\0"  return '\0';
</code></pre>

<p><a href="test/gather-c-string2.lex"><code>test/gather-c-string2.lex</code></a>
is a complete example demonstrating start condition scopes.

<p>Start condition scopes may be nested.


<h2 id="start-state-stack">Start State Stack</h2>

<p>If <a href="#option-stack"><code>%option stack</code></a> is set,
there is a stack of start
states that allows the scanner to enter a new state while remembering
where it came from.  This is useful when there is one language embedded
inside another and they require different lexing rules.  Three routines
are available for manipulating the stack of start conditions:

<dl>

<dt id="yy_push_state"><code>void yy_push_state(yy_lexer_t *yy_lexer, int new_state);</code>

    <dd><p>Push the current start condition onto the top of the start
    condition stack and switch to <code>new_state</code> as though you had
    used
    <a href="#yy_set_start_state"><code>yy_set_start_state(yy_lexer, new_state)</code></a>.

<dt id="yy_pop_state"><code>void yy_pop_state(yy_lexer_t *yy_lexer);</code>

    <dd><p>Pop the top of the stack and switch to it via
    <code>yy_set_start_state</code>.

<dt id="yy_top_state"><code>int yy_top_state(yy_lexer_t *yy_lexer);</code>

    <dd><p>Return the top of the stack without altering the stack's contents.

    <p>Use of this function requires <code>%option yy_top_state</code>.

</dl>

<p>The start condition stack grows dynamically and so has no built-in
size limitation. If memory is exhausted,
<a href="#yy_error_function"><code>yy_error_function</code></a> is called.

<p><a href="test/discard-ml-comments.lex">Here</a> is an example that
demonstrates the start condition stack, as well as start condition
scopes, by using them to keep track of nested comments in ML:

<pre><!-- BEGIN example: "discard-ml-comments.lex" fragment=true indent=4 --><code>
    %option stack
    %x comment foo
    %%
    &lt;*&gt;"(*"                 yy_push_state(yy_lexer, comment);
    &lt;comment&gt;{
      [^*(]+                /* eat anything that's not a '*' or '(' */
      "*"+/[^)]             /* eat '*'s not followed by ')' */
      "("/[^*]              /* eat '(' not followed by '*' */
      "*"+")"               yy_pop_state(yy_lexer);
    }
</code><!-- END example --></pre>


<!-- ======================================================= -->
<h1 id="multiple-input-buffers">MULTIPLE INPUT BUFFERS</h1>

<p>Some scanners (such as those which support "include" files) require
reading from several input streams. As <code>smflex</code> scanners do a
large amount of buffering, one cannot control where the next input will
be read from by simply writing a
<a href="#yy_read_input_function"><code>yy_read_input_function</code></a>
which is sensitive
to the scanning context. <code>yy_read_input_function</code> is only called when the
scanner reaches the end of its buffer, which may be a long time after
scanning a statement such as an "include" which requires switching the
input source.

<p>To negotiate these sorts of problems, <code>smflex</code> provides a
mechanism for creating and switching between multiple input buffers. An
input buffer is created by using:

<pre><code>
    yy_buffer_state_t *yy_create_buffer(yy_lexer_t *yy_lexer, FILE *file, int size)
</code></pre>

<p>which takes a <code>FILE</code> pointer
(TODO: It really accepts <code>yy_input_stream_t *</code>)
and a size and creates a buffer
associated with the given file and large enough to hold <code>size</code>
characters; a <code>size</code> of 0 means to use a reasonable default size. It
returns a <code>yy_buffer_state_t*</code>, pointer which may then be
passed to other routines (see below).

<p>The <code>FILE</code>
pointer in the call to <code>yy_create_buffer</code> is used to set
the value of <code>yyin</code> while that buffer is the active
input source.  Within the generated code,
<code>yyin</code> is only used by <code>yy_read_input_function</code>; if you
redefine <code>yy_read_input_function</code> so it no longer uses <code>yyin</code>,
then you can safely pass <code>NULL</code> as the <code>FILE</code> pointer.
However, you may want to use
<code>yyin</code> yourself, for example (as shown in the example
below) to close the file.

<p id="yy_switch_to_buffer">
You select a particular buffer to be the active input source with:

<pre><code>
    void yy_switch_to_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *new_buffer)
</code></pre>

<p>This switches the scanner's input buffer so subsequent tokens will come
from <code>new_buffer</code>.  <code>yy_switch_to_buffer()</code>
may be used by <code>yy_wrap_function()</code> to set things up for continued scanning instead
of opening a new file and pointing <code>yyin</code> at it.  Calling
this function does <em>not</em> change the start condition.

<p>When finished scanning from a buffer, call:

<pre><code>
    void yy_delete_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *buffer)
</code></pre>

<p>to reclaim the storage associated with it.  If <code>buffer</code> is
<code>NULL</code>, this function does nothing.

<p id="yy_flush_buffer">To discard data that has already been read and buffered from a
particular source, call:

<pre><code>
    void yy_flush_buffer(yy_lexer_t *yy_lexer, yy_buffer_state_t *buffer)
</code></pre>

<p>After calling this function, the next time the
scanner attempts to read data from the buffer, it will first fill
the buffer anew using <code>yy_read_input_function</code>.

<p>Finally, the <code>YY_CURRENT_BUFFER</code> macro returns a
<code>yy_buffer_state_t*</code> pointer to the current buffer.

<p>Here is an <a href="test/input-buffers.lex">example</a>
of using these features for writing a scanner which
expands include files (the <code>&lt;&lt;EOF&gt;&gt;</code> feature is
explained in <a href="#end-of-file-rules">End-of-File Rules</a>):

<pre><!-- BEGIN example: "input-buffers.lex" fragment=true indent=4 --><code>
    /* The "incl" state is used for picking up the name of an include file. */
    %x incl

    %{
    #define MAX_INCLUDE_DEPTH 10
    yy_buffer_state_t *include_stack[MAX_INCLUDE_DEPTH];
    int include_stack_len = 0;
    %}

    %%
    include[ ]+         YY_SET_START_STATE(incl);

    [a-z]+              YY_ECHO;
    [^a-z\n]*\n?        YY_ECHO;

    &lt;incl&gt;[^\n]+      { /* got the include file name */
              yy_buffer_state_t *newbuf;

              FILE *fp = fopen(yytext, "r");
              if (!fp) {
                fprintf(stderr, "Cannot open include file: \"%s\".\n", yytext);
                exit(2);
              }

              if (include_stack_len &gt;= MAX_INCLUDE_DEPTH) {
                fprintf(stderr, "Includes nested too deeply.\n");
                exit(2);
              }
              include_stack[include_stack_len++] = YY_CURRENT_BUFFER;

              newbuf = yy_create_buffer(yy_lexer, fp, 0 /*size*/);
              yy_switch_to_buffer(yy_lexer, newbuf);

              /* Start condition for processing the new file. */
              YY_SET_START_STATE(INITIAL);
            }

    &lt;&lt;EOF&gt;&gt; {
              /* We are done with the current buffer. */
              if (include_stack_len &gt;= 1) {
                /* The current buffer is one we made, so clean it up. */
                yy_delete_buffer(yy_lexer, YY_CURRENT_BUFFER);
                fclose(yyin);

                /* Return to the buffer on the top of the stack.  Note
                 * that this sets 'yyin'. */
                yy_switch_to_buffer(yy_lexer, include_stack[--include_stack_len]);
              }

              else {
                /* All done. */
                yyterminate();
              }
            }
</code><!-- END example --></pre>

<p>Three routines are available for setting up input buffers for
scanning in-memory strings instead of files. All of them create a
new input buffer for scanning the string, and return a corresponding
<code>yy_buffer_state_t*</code> pointer (which you should delete with
<code>yy_delete_buffer()</code> when done with it). They also switch
to the new buffer using <code>yy_switch_to_buffer()</code>, so the next
call to <code>yy_lex()</code> will start scanning the string.

<dl>

<dt><code>yy_scan_string(yy_lexer_t *yy_lexer, const char *str)</code>

<dd><p>scans a NUL-terminated string.

    <p>Use of this function requires <code>%option yy_scan_string</code>.

<dt><code>yy_scan_bytes(yy_lexer_t *yy_lexer, const char *bytes, int len)</code>

<dd><p>scans <code>len</code> bytes (including possibly NUL's) starting at
    location <code>bytes</code>.

    <p>Use of this function requires <code>%option yy_scan_bytes</code>.

</dl>

<p>Note that both of these functions create and scan a <em>copy</em> of
the string or bytes. (This may be desirable, since <code>yy_lex()</code>
modifies the contents of the buffer it is scanning.) You can avoid the
copy by using:

<dl>

<dt><code>yy_scan_buffer(yy_lexer_t *yy_lexer, char *base, size_t size)</code>

<dd><p>scans in place the buffer starting at <code>base</code>, consisting
    of <code>size</code> bytes, the last two bytes of which <em>must</em> be
    <code>YY_END_OF_BUFFER_CHAR</code> (ASCII NUL). These last two bytes
    are not scanned; thus, scanning consists of <code>base[0]</code> through
    <code>base[size-2]</code>, inclusive.

<p>If you fail to set up <code>base</code> in this manner (i.e.,
forget the final two <code>YY_END_OF_BUFFER_CHAR</code> bytes), then
<code>yy_scan_buffer()</code> returns a <code>NULL</code> pointer instead of creating
a new input buffer.

    <p>Use of this function requires <code>%option yy_scan_buffer</code>.

</dl>

<p>See <a href="test/scan-string-etc.lex"><code>test/scan-string-etc.lex</code></a>
for an example demonstrating each of these functions.


<!-- ======================================================= -->
<h1 id="end-of-file-rules">END-OF-FILE RULES</h1>

<p>The special rule "<code>&lt;&lt;EOF&gt;&gt;</code>" indicates actions which are to
be taken when an end-of-file is encountered and <code>yy_wrap_function()</code> returns non-zero
(i.e., indicates no further files to process). The action must finish
by doing one of four things:

<ul>

<li><p>assigning <code>yyin</code> to a new input file;

<li><p>executing a <code>return</code> statement;

<li><p>executing the special <code>yyterminate()</code> action;

<li><p>or, switching to a new buffer using <code>yy_switch_to_buffer()</code>
    as shown in the example in
    <a href="#multiple-input-buffers">Multiple Input Buffers</a>.

</ul>

<p><code>&lt;&lt;EOF&gt;&gt;</code> rules may not be used with other patterns; they
may only be qualified with a list of start conditions. If an unqualified
<code>&lt;&lt;EOF&gt;&gt;</code> rule is given, it applies to <em>all</em> start
conditions which do not already have <code>&lt;&lt;EOF&gt;&gt;</code> actions. To
specify an <code>&lt;&lt;EOF&gt;&gt;</code> rule for only the initial start condition,
use:

<pre><code>
    &lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;
</code></pre>

<p>These rules are useful for catching things like unclosed comments and
strings.  For example:

<pre><code>
    %x quote
    %%

    ...other rules for dealing with quotes...

    &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
               error("unterminated quote");
               yyterminate();
             }
    &lt;&lt;EOF&gt;&gt;  {
               if (*++filelist)
                 yyin = fopen(*filelist, "r");
               else
                 yyterminate();
             }
</code></pre>


<!-- ======================================================= -->
<h1 id="miscellaneous-macros">MISCELLANEOUS MACROS</h1>

<dl>

<dt><code>YY_USER_ACTION</code>

<dd>
<p>The macro <code>YY_USER_ACTION</code> can be defined to provide an
action which is always executed prior to the matched rule's action. For
example, it could be <code>#define</code>d to call a routine to convert <code>yytext</code> to
lower-case. When <code>YY_USER_ACTION</code> is invoked, the variable
<code>yy_act</code> gives the number of the matched rule; rules are numbered
starting with 1. Suppose you want to profile how often each of your
rules is matched. The following would do the trick:

<pre><code>
    #define YY_USER_ACTION ++ctr[yy_act];
</code></pre>

<p>where <code>ctr</code> is an array to hold the counts for the different
rules. The macro <code>YY_NUM_RULES</code> gives the
total number of rules (including the default rule, even if you use
<code>-s</code>), so a correct declaration for <code>ctr</code> is:

<pre><code>
    int ctr[YY_NUM_RULES+1];     /* Entry 0 not used here. */
</code></pre>

<p>See <a href="test/count-actions.lex"><code>test/count-actions.lex</code></a>
for a complete example.

<dt><code>YY_USER_INIT</code>

<dd>
<p>The macro <code>YY_USER_INIT</code> may be defined to provide an
action which is always executed before the first scan (and before the
scanner's internal initializations are done). For example, it could be
used to call a routine to read in a data table or open a logging file.

<dt><code>yy_set_interactive(yy_lexer_t *yy_lexer, int is_interactive)</code>

<dd>
<p>The function <code id="yy_set_interactive">yy_set_interactive</code>
can be used to control whether the current buffer is considered
<em>interactive</em>. An interactive buffer is processed much more
slowly (around 10x) due to reading one character at a time, but must be
used when the scanner's input source is indeed
interactive to avoid problems due to waiting to fill buffers. A non-zero argument
marks the buffer as interactive, a zero value as
non-interactive.  This function should only be used when the scanner is
built with the <a href="#interactive-option"><code>-I</code></a> flag
because otherwise lazy action evaluation due to the default <a
href="#batch-option"><code>-B</code></a> option will cause poor
interactive performance even when reading one character at a time.

<p>
<code>yy_set_interactive()</code> must be invoked
prior to beginning to scan the buffer that is (or is not) to be considered
interactive, as demonstrated by
<a href="test/c-int-interactive-set-int-isatty.lex"><code>test/c-int-interactive-set-int-isatty.lex</code></a>:

<pre><!-- BEGIN example: "c-int-interactive-set-int-isatty.lex" fragment=true indent=2 --><code>
    lexer.yy_input_stream = stdin;
    yy_set_interactive(&amp;lexer, isatty(fileno(stdin)) &gt; 0);
    while (yy_lex(&amp;lexer))
      {}
</code><!-- END example --></pre>

<dt><code>yy_set_bol(yy_lexer_t *yy_lexer, int at_bol)</code>

<dd>
<p>The function <code>yy_set_bol</code> can be used to control
whether the current buffer's scanning context for the next token match
is done as though at the beginning of a line. A non-zero macro argument
makes rules anchored with
<code>^</code> active, while a zero argument makes <code>^</code> rules inactive.

<dt id="YY_GET_BOL-macro"><code>YY_GET_BOL()</code>

<dd>
<p>The macro <code>YY_GET_BOL()</code> returns true if the next token
scanned from the current buffer will have <code>^</code> rules active, false
otherwise.

<p>See <a href="test/set-bol.lex"><code>test/set-bol.lex</code></a>
for an example with <code>yy_set_bol</code> and <code>YY_GET_BOL</code>.

<dt><code>YY_BREAK</code>

<dd>
<p>In the generated scanner, the actions are all gathered in one large
switch statement, with each case terminated with the
<code>YY_BREAK</code> macro, which expands to "<code>break;</code>" by
default.  This may be redefined.

</dl>


<!-- ======================================================= -->
<h1 id="values-available-to-the-user">VALUES AVAILABLE TO THE USER</h1>

<p>This section summarizes the various values available to the user in
the rule actions.

<ul>

<li><p><code>char *yytext</code> holds the text of the current token. It may
    be modified but not lengthened (you cannot append characters to the end).

<li><p><code>int yyleng</code>
    holds the length of the current token.

<li><p><code>FILE *yyin</code>
    is the file which by default <code>smflex</code> reads from. It may be
    redefined but doing so only makes sense before scanning begins or
    after an EOF has been encountered. Changing it in the midst of
    scanning will have unexpected results since <code>smflex</code>
    buffers its input; use <code>yy_restart()</code> instead. Once
    scanning terminates because an end-of-file has been seen, you can
    assign <code>yyin</code> at the new input file and then call the
    scanner again to continue scanning.

<li><p id="yy_restart"><code>void yy_restart(FILE *new_file)</code>
    may be called to point <code>yyin</code> at the new input file. The
    switch-over to the new file is immediate (any previously buffered-up
    input is lost). Note that calling <code>yy_restart()</code> with
    <code>yyin</code> as an argument thus throws away the current input
    buffer and continues scanning the same input file.

<li><p><code>FILE *yyout</code>
    is the file to which <code>YY_ECHO</code> actions are done. It can be
    reassigned by the user.

<li><p><code>YY_CURRENT_BUFFER</code>
    returns a <code>yy_buffer_state_t*</code> pointer to the current
    buffer.

<li><p><code>YY_GET_START_STATE()</code>
    returns an integer value corresponding to the current start
    condition. You can subsequently use this value with
    <code>YY_SET_START_STATE</code> to return to that start condition.

</ul>


<!-- ======================================================= -->
<h1 id="interfacing-with-yacc">INTERFACING WITH YACC</h1>

<p>One of the main uses of <code>smflex</code> is as a companion to
the <code>yacc</code> parser-generator. <code>yacc</code> parsers expect
to call a routine named <code>yy_lex()</code> to find the next
input token. The routine is supposed to return the type of the
next token as well as putting any associated value in the global
<code>yylval</code>. To use <code>smflex</code> with <code>yacc</code>, one
specifies the <code>-d</code> option to <code>yacc</code> to instruct it to
generate the file <code>y.tab.h</code> containing definitions of all
the <code>%tokens</code> appearing in the <code>yacc</code> input. This
file is then included in the <code>smflex</code> scanner. For example,
if one of the tokens is "TOK_NUMBER", part of the scanner might look like:

<pre><code>
    %{
    #include "y.tab.h"
    %}

    %%

    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
</code></pre>


<!-- ======================================================= -->
<h1 id="options">OPTIONS</h1>

<p><code>smflex</code> has the following options:

<dl>

<dt><code>-b</code>

<dd><p>Generate backing-up information to <code>lex.backup</code>. This is a list
    of scanner states which require backing up and the input characters on
    which they do so. By adding rules one can remove backing-up states. If
    <em>all</em> backing-up states are eliminated and <code>-Cf</code>
    or <code>-CJ</code> is used, the generated scanner will run faster
    (see the <code>-p</code> flag). Only users who wish to squeeze every
    last cycle out of their scanners need worry about this option. (See the
    section <a href="#performance-considerations">Performance Considerations</a>.)

<dt><code>-d</code>

<dd><p>Generate a scanner with the
    <a href="#yy_flex_debug"><code>yy_flex_debug</code></a> field.

<dt><code>--flex-compat</code>

<dd><p>Activate some aliases in section 2 (rules) that provide partial
    compatibility with <code>flex</code>:

    <table>
      <tr>
        <th>Compatibility alias
        <th>New name
      <tr>
        <td><code>ECHO</code>
        <td><code>YY_ECHO</code>
      <tr>
        <td><code>yyless</code>
        <td><code>YY_LESS_TEXT</code>
      <tr>
        <td><code>input</code>
        <td><code>YY_READ_CHARACTER</code>
      <tr>
        <td><code>yyinput</code>
        <td><code>YY_READ_CHARACTER</code>
      <tr>
        <td><code>unput</code>
        <td><code>YY_UNREAD_CHARACTER</code>
    </table>

    <p>Additionally, this option adds to to the generated header file the
    following typedef, which is used in <code>flex</code> to access the
    <a href="#multiple-input-buffers">Multiple Input Buffers</a>
    functions:

    <pre><code>
        typedef yy_buffer_state_t *YY_BUFFER_STATE;
    </code></pre>

    <p>The intent of this option is to make it a bit easier to experiment
    with <code>smflex</code> during a transition period, rather than
    to use it indefinitely.

<dt><code>-h</code>

<dd><p>Print a "help" summary of <code>smflex</code>'s options to
    <code>stdout</code> and then exit. <code>-?</code> and <code>--help</code>
    are synonyms for <code>-h</code>.

<dt><code>-i</code>

<dd><p>Generate a <em>case-insensitive</em>
    scanner. The case of letters given in the <code>smflex</code> input patterns
    will be ignored, and tokens in the input will be matched regardless
    of case. The matched text given in <code>yytext</code> will have the
    preserved case (i.e., it will not be folded).

<dt><code>-n</code>

<dd><p>Write output files using platform native line endings.  The
    default behavior is to always use LF (ASCII 10) line endings.

<dt id="performance-report"><code>-p</code>

<dd><p>Print a performance report to <code>stderr</code>. The report consists of
    comments regarding features of the <code>smflex</code> input file which
    will cause a serious loss of performance in the resulting scanner. If
    you give the flag twice, you will also get comments regarding features
    that lead to minor performance losses.

<dt><code>-s</code>

<dd><p>Suppress the <em>default rule</em> that unmatched scanner input is
    echoed to <code>stdout</code>. If the scanner encounters
    input that does not match any of its rules, it aborts with an error. This
    option is useful for finding holes in a scanner's rule set.

<dt><code>-v</code>

<dd><p>Print to <code>stderr</code>
    a summary of statistics regarding the scanner it generates. Most of
    the statistics are meaningless to the casual <code>smflex</code> user,
    but the first line identifies the version of <code>smflex</code> (same
    as reported by <code>-V</code>), and the next line the flags used when
    generating the scanner, including those that are on by default.

<dt><code>-w</code>

<dd><p>Suppress warning messages.

<dt id="batch-option"><code>-B</code>

<dd><p>Generate a <em>batch</em> scanner, the
    opposite of <em>interactive</em> scanners generated by <code>-I</code>
    (see below).  This is the default.

    <p>In this mode, the generated scanner uses <em>lazy</em> action execution,
    meaning it always waits to see one character beyond the text matched
    by an action before executing that action, even when seeing the
    lookahead character is not necessary for disambiguation.  Lazy
    action execution is faster, but works poorly for interactive use;
    for example, when a user types a newline, it is not recognized as
    such until they enter <em>another</em> character.  (Furthermore, if
    the terminal is configured to use the default "cooked" input mode,
    that character will itself not be seen until another newline is
    typed.)

<dt id="interactive-option"><code>-I</code>

<dd><p>Generate an <em>interactive</em>
    scanner.  An interactive scanner is one that executes actions
    eagerly, only looking ahead to decide
    what token has been matched if it absolutely must.  Furthermore,
    an interactive scanner by default reads its input source one
    character at a time, although you can override that by calling
    <a href="#yy_set_interactive"><code>yy_set_interactive()</code></a>.

    <p>This option is not compatible with the <code>-Cf</code> or
    <code>-CJ</code> options.

<dt><code>-L</code>

<dd><p>Do not generate <code>#line</code>
    directives. Without this option, <code>smflex</code> peppers the generated
    scanner with <code>#line</code> directives so error messages in the actions will be
    correctly located with respect to either the original <code>smflex</code>
    input file (if the errors are due to code in the input file), or
    <code>lex.yy.c</code> (if the errors are <code>smflex</code>'s fault &mdash;
    you should report these sorts of errors to the <code>smflex</code>
    maintainers).

<dt><code>-T</code>

<dd><p>Run the scanner generator in <em>trace</em> mode.  This will generate a
    lot of messages to <code>stderr</code> concerning the form of the input and
    the resultant non-deterministic and deterministic finite automata. This
    option is mostly for use in maintaining <code>smflex</code>.

<dt><code>-V</code>

<dd><p>Print the version number to <code>stdout</code> and
    exit. <code>--version</code> is a synonym for <code>-V</code>.

<dt><code>-7</code>

<dd><p>Generate a 7-bit scanner, i.e., one
    which can only recognize 7-bit characters in its input. The advantage of
    using <code>-7</code> is that the scanner's tables can be up to half the
    size of those generated using the <code>-8</code> option (see below). The
    disadvantage is that such scanners can hang or crash if their input
    contains an 8-bit character.

    <p>smcpeak: Hangs and crashes!  What does that mean?  First, with
    <code>-7</code>, the scanner uses all 8 bits of each character to
    index into its tables, but the tables only have 128 elements, so a
    high bit will cause an out-of-bounds read.  However, most often this
    just reads a value in an adjacent state, which is logically
    nonsensical but not by itself terribly dangerous.  I have not seen
    any hangs or crashes in my testing, but I can't rule it out either,
    especially with the large space of table compression options.  Also,
    I tried adding a 7-bit mask to the inner loop to avoid the bounds
    problem; it made the scanner I was testing slow down by about 1.5%.
    I have not decided whether to go ahead and make that an option too.

    <p>Unless you generate your scanner using the
    <code>-Cf</code> or <code>-CJ</code> table compression options, use of
    <code>-7</code> will save only a small amount of table space, and make
    your scanner considerably less portable. <code>smflex</code>'s default behavior
    is to generate an 8-bit scanner unless you use the <code>-Cf</code> or
    <code>-CJ</code>, in which case <code>smflex</code> defaults to generating
    7-bit scanner. You can tell
    whether <code>smflex</code> generated a 7-bit or an 8-bit scanner by inspecting the
    flag summary in the <code>-v</code> output as described above.

    <p>If you use <code>-Cfe</code> or <code>-CJe</code> (those
    table compression options, but also using equivalence classes as discussed
    below), <code>smflex</code> still defaults to generating an 8-bit scanner, since
    usually with these compression options full 8-bit tables are not much
    more expensive than 7-bit tables.

<dt><code>-8</code>

<dd><p>Generate an 8-bit scanner, i.e.,
    one which can recognize 8-bit characters. This flag is only needed
    for scanners generated using <code>-Cf</code> or <code>-CJ</code>
    (and not <code>-Ce</code> also),
    as otherwise <code>smflex</code> defaults to generating an 8-bit scanner anyway.

    <p>See the discussion of <code>-7</code> above for <code>smflex</code>'s default behavior
    and the tradeoffs between 7-bit and 8-bit scanners.

<dt><code>-+</code>

<dd><p>Generate a scanner with a C++ rather than C interface. See
    <a href="#generating-cpp-scanners">Generating C++ Scanners</a>
    for details.

<dt><code>-C[aefFmr]*</code>

<dd><p>Specify the kind of table compression to use.
    <code>-C</code> can be followed by a string of the following letters:

    <dl>


    <dt><code>-Ca</code> ("align")

    <dd><p>Attempt to ensure all table accesses are aligned for
    efficient memory access and computation.  This can speed up
    scanning on some RISC architectures, but also
    can double (or more) the size of the tables used by your scanner,
    depending on the ratio of <code>sizeof(long)</code> to
    <code>sizeof(short)</code>.


    <dt><code>-Ce</code> ("equivalence")

    <dd><p>Construct <em>equivalence
    classes</em>, i.e., sets of characters which have identical lexical
    properties (for example, if the only appearance of digits in the
    <code>smflex</code> input is in the character class "[0-9]" then the
    digits '0', '1', ..., '9' will all be put in the same equivalence
    class). Equivalence classes usually give dramatic reductions in the final
    table/object file sizes (typically a factor of 2-5) and are pretty cheap
    performance-wise (one array look-up per character scanned).


    <dt><code>-Cf</code> ("full")

    <dd><p>Generate "full", uncompressed scanner tables.


    <dt><code>-CJ</code> ("Jacobson")

    <dd><p>Use the "Jacobson" scanner table representation.
    This representation is about as fast as the
    "full" table representation (<code>-Cf</code>), and may be smaller,
    particularly when the number of functionally distinct input
    characters is relatively small.  For example,
    if the pattern set contains both explicitly enumerated "keywords" and a
    catch-all, "identifier" rule, such as in the set:

    <pre><code>
        "case"    return TOK_CASE;
        "switch"  return TOK_SWITCH;
        ...
        "default" return TOK_DEFAULT;
        [a-z]+    return TOK_ID;
</code></pre>

    <p>then there will be many functionally distinct characters, so
    you're better off using the full table representation (<code>-Cf</code>).
    If only
    the "identifier" rule is present and you then use a hash table or some
    such to detect the keywords, then the characters will have greater
    functional similarity, and hence the Jacobson approach may be
    better.

    <p>The option is named after Guy Jacobson whose work on
    "succinct" data structures was evidently the inspiration for
    the representation implemented here.


    <dt><code>-Cm</code> ("meta")

    <dd><p>Construct
    <em>meta-equivalence classes</em>, which are sets of equivalence classes
    (or characters, if equivalence classes are not being used) that are
    commonly used together. Meta-equivalence classes are often a big win
    when using compressed tables, but they have a moderate performance impact
    (one or two "if" tests and one array look-up per character scanned).


    <dt><code>-Cr</code> ("read")

    <dd><p>Cause the generated scanner to <em>bypass</em>
    use of the standard I/O library (stdio) for input. Instead of calling
    the C library function <code>fread()</code>, the scanner will use the
    underlying <code>read()</code> system call.  See
    <a href="#input-read-method">Input Read Method</a> for a discussion
    of the performance effect.  Using
    <code>-Cr</code> can cause strange behavior if, for example, you read from
    <code>yyin</code> using stdio prior to calling the scanner (because the
    scanner will miss whatever text your previous reads left in the stdio
    input buffer).

    <code>-Cr</code> has no effect if you change
    <a href="#yy_read_input_function"><code>yy_read_input_function</code></a>.

    Using <code>-Cr</code> introduces a compile-time dependency on
    <code>unistd.h</code> and a link-time dependency on <code>read</code>.

    </dl>


    <p>The options <code>-Cf</code> or <code>-CJ</code> and <code>-Cm</code>
    do not make sense together &mdash; there is no opportunity for meta-equivalence
    classes if the table is not being compressed. Otherwise the options may
    be freely mixed, and are cumulative.

    <p>A lone <code>-C</code> specifies that the scanner tables should be
    compressed but neither equivalence classes nor meta-equivalence classes
    should be used.

    <p>The default setting is <code>-Cem</code>, which specifies
    that <code>smflex</code> should generate equivalence classes and
    meta-equivalence classes. This setting provides the highest degree of
    table compression. You can trade off faster-executing scanners at the
    cost of larger tables with the following generally being true:

    <pre><code>
        slowest &amp; smallest
              -Cem
              -Cm
              -Ce
              -C
              -C{f,J}e
              -C{f,J}
              -C{f,J}a
        fastest &amp; largest
</code></pre>

    <p>See <a href="#table-compression-options">Table Compression Options</a>
    for an empirical analysis of the performance effect of these
    options.

    <p>Scanners with the smallest tables are usually generated
    and compiled the quickest, so during development you will usually want
    to use the default, maximal compression.

    <p><code>-Cfe</code> is often a good compromise between speed and size
    for production scanners.

<dt><code>-ooutput</code>

<dd><p>Write the scanner to the file <code>output</code>
    instead of <code>lex.yy.c</code>.  When using <code>-+</code>,
    the generated header file is written to the same name, except its
    extension is replaced with <code>.h</code> (if there is no
    extension, <code>.h</code> is appended).

<dt id="prefix-option"><code>-Pprefix</code>

<dd><p>Change the default <code>yy</code> prefix used by <code>smflex</code>
    for all globally-visible variable and function names to instead be
    <code>prefix</code>. For example, <code>-Pfoo</code> changes the name
    of <code>yy_lex</code> to <code>foo_lex</code>. It also changes
    the name of the output file froms
    <code>lex.yy.c</code> and <code>lex.yy.h</code> to
    <code>lex.foo.c</code> and <code>lex.foo.h</code>
    (unless <code>-o</code> is also specified).

    <p>
    The "yy" to "prefix" transformation is applied to all names that
    are placed into the global namespace by the generated header file.
    That includes all of the names the names with external linkage
    in the generated scanner file.  Consequently, you can use this to
    link together multiple <code>smflex</code>
    scanners into the same executable.

    <p>The prefix transformation affects those names both as seen from
    external modules, and as seen from within your own scanner.

    <p><strong>Recommendation</strong>: Always use <code>-P</code>
    or its equivalent <code>%option prefix</code>.  You never know
    when you (or someone else) will want to combine two scanners in
    one program, and renaming afterward can be a hassle.

</dl>

<p><code>smflex</code> also provides a mechanism for controlling
options within the scanner specification itself, rather than from
the <code>smflex</code> command line. This is done by including <code>%option</code>
directives in the first section of the scanner specification. You can
specify multiple options with a single <code>%option</code> directive,
and multiple directives in the first section of your <code>smflex</code> input file.

<p><strong>Warning</strong>: Unlike most other programs, in
<code>smflex</code>, options specified within the input file take
precedence over those specified on the command line.  The only
exception is the output file name, where the
command line option <code>-o</code> takes precedence over the input
file <code>%option outfile</code>.  TODO: Make all command line options
take precedence.

<p>Most options are given simply as names, optionally preceded by the
word "no" (with no intervening whitespace) to negate their meaning. A
number are equivalent to <code>smflex</code> flags or their negation:

<pre><code>
    7bit                           -7 option
    8bit                           -8 option
    align                          -Ca option
    backup                         -b option
    batch                          -B option
    c++                            -+ option
    caseful or case-sensitive      opposite of -i (default)
    caseless or case-insensitive   -i option
    <span id="debug-option">debug                          -d option</span>
    default                        opposite of -s option
    ecs                            -Ce option
    flex-compat                    --flex-compat option
    full                           -Cf option
    interactive                    -I option
    jacobson                       -CJ option
    meta-ecs                       -Cm option
    perf-report                    -p option
    read                           -Cr option
    verbose                        -v option
    warn                           opposite of -w option
                                   (use "%option nowarn" for -w)
</code></pre>

<p>Some <code>%option</code>s provide features otherwise not available:

<dl>

<dt id="option-main"><code>main</code>

<dd><p>Provide a default <code>main()</code> program for the
    scanner.  Its definition is:

    <pre><code>
      int main()
      {
        /* Keep retrieving tokens and discarding them until EOF. */
        yy_lexer_t lexer;
        yy_construct(&amp;lexer);
        while (yy_lex(&amp;lexer) != 0)
          {} /* nothing */
        yy_destroy(&amp;lexer);

        return 0;
      }
    </code></pre>

<dt><code>reject</code>

<dd><p>
    Enable support for <code>REJECT</code> even if <code>smflex</code>
    does not see any uses of it among the actions.  Conversely,
    <code>noreject</code> disables <code>REJECT</code> even when it
    seems to be used.

<dt id="option-stack"><code>stack</code>

<dd><p>Enable the use of start condition stacks
    (see <a href="#start-conditions">Start Conditions</a>).

<dt><code>yylineno</code>

<dd><p>Generate a scanner that has
    <a href="#yy_lineno"><code>yy_lineno</code></a>.

<dt><code>yymore</code>

<dd><p>Enable <code>yymore()</code> even if <code>smflex</code> does not
    see any uses of it among the actions.  Conversely,
    <code>noyymore</code> disables <code>yymore()</code> even if it
    seems to be used.

</dl>

<p>Three options take string-delimited values, offset with '=':

<pre><code>
    %option outfile="ABC"
</code></pre>

<p>is equivalent to <code>-oABC</code>, and

<pre><code>
    %option prefix="XYZ"
</code></pre>

<p>is equivalent to <code>-PXYZ</code>. Finally,

<pre><code>
    %option yyclass="foo"
</code></pre>

<p>only applies when generating a C++-interface scanner (<code>-+</code>
option). It informs <code>smflex</code> that you have derived
<code>foo</code> as a subclass of <code>yyFlexLexer</code>, so
<code>smflex</code> will place your actions in the member function
<code>foo::yym_lex()</code> instead of <code>yyFlexLexer::yym_lex()</code>.
See
<a href="#generating-cpp-scanners">Generating C++ Scanners</a>
for additional information.

<p>Certain <code>smflex</code> functions are only generated if their
corresponding option is set.  These are:

<pre><code>
    yy_read_character
    yy_scan_string
    yy_scan_bytes
    yy_scan_buffer
    <span id="option-yy_top_state">yy_top_state           # Only has effect with %option stack.</span>
    yy_unread_character
</code></pre>


<!-- ======================================================= -->
<h1 id="performance-considerations">PERFORMANCE CONSIDERATIONS</h1>

<p>The main design goal of <code>smflex</code> is that it generate
high-performance scanners.  It has been optimized for dealing well with
large sets of rules.  This section has guidance on how to best use its
features to get high performance.

<p>When first looking to optimize a scanner, be sure to run
<code>smflex</code> with the
<a href="#performance-report"><code>-p -p</code></a> options (the same
option repeated) in order to get the "performance report".  This
will warn you of obvious potential issues with the configuration.


<h2 id="input-read-method">Input Read Method</h2>

<p>
Before diving into the scanner guts, make sure the method being used
to read the input is efficient.  In particular:

<ul>

<li><p>Be sure you are using the <code>-B</code> /
    <code>%option batch</code> option.  Reading input one character at
    a time is around <em>10 times</em> slower than reading a block at a time.

<li><p>Ensure that input is being read in <em>binary</em> mode, not
    text mode, if the distinction is relevant for your platform(s)
    (mainly Windows).  Text mode reading, even when the line endings
    do not need translation, is almost twice as slow as binary reading.
    Toward that end, explicitly open all input files rather than
    reading from standard input so you can set the read mode.

<li><p>Some systems can be sensitive to the size of the
    read buffer.  The default value of <code>YY_READ_BUF_SIZE</code>,
    0x2000 (8 KiB), works reasonably well on all systems tested.  But consider this anecdote:
    on MinGW using <code>fread</code>, any size that is not a multiple of
    0x800 entails a 10-20% performance loss.

<li><p>Meanwhile, substantially increasing the buffer size can lead to
    significant gains.  For example, a size of 0x10000 (64 KiB) gains
    about 20% over the default (with returns diminishing rapidly after
    that).  To use that size, add
    <code>#define YY_READ_BUF_SIZE 0x10000</code> to the top of the
    <code>smflex</code> input file.

<li><p>There are three methods <code>smflex</code> can use to read the
    input: <code>fread</code>, <code>read</code>, and <code>iostream</code>.
    On MinGW at least, they all perform about the same (with the
    default buffer size), but other platforms may be different.

</ul>

<p>
In the <code>smflex</code> sources, the program
<a href="test/readfile.c"><code>test/readfile.c</code></a> can be
used to experiment with your target platforms.  When I ran this program
on MinGW (Windows 10, gcc-5.4.0) against a corpus consisting of all of the
<code>smflex</code> source files concatenated together (about 470KB),
using an iteration count of 1000 and 5 runs,
I observed these key data points (the first is the baseline, the
rest vary one aspect, shown in <strong>bold</strong>;
&sigma; is standard deviation):

<table>
  <tr>
    <th>Time (ms)
    <th>2&sigma; (ms)
    <th>RelTime
    <th>Compiler
    <th>Method
    <th>Bufsize (bytes)
    <th>Mode

  <tr>
    <td class="numeric">655
    <td class="numeric">&plusmn; 20
    <td class="numeric">
    <td>C
    <td>fread
    <td class="numeric">0x2000
    <td>binary

  <tr>
    <td class="numeric">658
    <td class="numeric">&plusmn; 37
    <td class="numeric">0
    <td><strong>C++</strong>
    <td>fread
    <td class="numeric">0x2000
    <td>binary

  <tr>
    <td class="numeric">1110
    <td class="numeric">&plusmn; 13
    <td class="numeric">+69%
    <td>C
    <td>fread
    <td class="numeric">0x2000
    <td><strong>text</strong>

  <tr>
    <td class="numeric">661
    <td class="numeric">&plusmn; 11
    <td class="numeric">0
    <td>C
    <td><strong>read</strong>
    <td class="numeric">0x2000
    <td>binary

  <tr>
    <td class="numeric">661
    <td class="numeric">&plusmn; 21
    <td class="numeric">0
    <td>C++
    <td><strong>iostream</strong>
    <td class="numeric">0x2000
    <td>binary

  <tr>
    <td class="numeric">791
    <td class="numeric">&plusmn; 32
    <td class="numeric">+20%
    <td>C
    <td>fread
    <td class="numeric"><strong>0x2010</strong>
    <td>binary

  <tr>
    <td class="numeric">534
    <td class="numeric">&plusmn; 16
    <td class="numeric">-18%
    <td>C
    <td>fread
    <td class="numeric"><strong>0x10000</strong>
    <td>binary

</table>

<p>Of course, the numbers in the table above are measuring only the
cost of reading the data, without any significant computation being
performed, so practical gains in the context of a scanner will be
less.


<h2 id="table-compression-options">Table Compression Options</h2>

<p>
There are six flags that affect scanner speed in a potentially
beneficial way:
<code>-Ca -Ce -Cm -Cf -CJ -8</code>.  Naively, that is 64 combinations
to test, but there are three rules that limit that:

<ol>
<li><code>-Cf</code> and <code>-CJ</code> cannot be combined.
<li><code>-Cm</code> cannot be combined with <code>-Cf</code> or
    <code>-CJ</code>.
<li><code>-8</code> can only be added when <code>-Cf</code> or
    <code>-CJ</code> is present but <code>-Ce</code> is not
    (because it is already active in the other configurations).
</ol>

<p>That leaves us with 20 combinations to test, as shown in the tables
below.

<p>
I first applied these combinations to
<a href="test/c-lexer1.lex"><code>c-lexer1.lex</code></a>.  This
is a realistic scanner for a C/C++ that does <em>not</em> explicitly
enumerate all of the keywords.  I used <code>smflex</code> to generate
both a C-interface and C++-interface scanner.  It
was run on MinGW/Windows x86_64, compiled with gcc-5.4.0 at
optimization level -O2, and performed 1000 scans of the concatenation
of all <code>smflex</code> source code (~470 KB) in the time shown.
Each experiment was run 5 times.  For completeness, I used
commit <code>d1610d385b</code>.  I also measured
<code>flex-2.5.4</code> and <code>flex-2.6.4</code> (the latest) and
the results were essentially the same (for the entries they can generate;
those versions do not allow <code>-CJ</code> (called <code>-CF</code> by
them) and <code>-+</code> at the
same time), so I have not included that data.

<p>The following table reports the median time in milliseconds and the
<a href="https://en.wikipedia.org/wiki/Interquartile_range">interquartile range</a>.
Sizes are in bytes as reported by the <code>size</code> utility.
The <span class="highlight">highlighted</span> cells are those that
use <code>-Cf</code> or <code>-CJ</code> (since the others are about
half the speed), and where no other cell is both smaller and faster.

<table>
  <tr>
    <th>
    <th>
    <th colspan="3">C interface
    <th colspan="3">C++ interface
    <th>

  <tr>
    <th class="row2">Configuration
    <th class="row2">Switches
    <th class="row2">Size
    <th class="row2">Time
    <th class="row2">IQR
    <th class="row2">Size
    <th class="row2">Time
    <th class="row2">IQR
    <th class="row2">Notes

  <tr>
    <td>compr
    <td><code>-C</code>
    <td class="numeric">37808
    <td class="numeric">3657
    <td class="numeric">&plusmn; 24
    <td class="numeric">68252
    <td class="numeric">3230
    <td class="numeric">&plusmn; 13
    <td>

  <tr>
    <td>align
    <td><code>-Ca</code>
    <td class="numeric">52912
    <td class="numeric">3634
    <td class="numeric">&plusmn; 28
    <td class="numeric">83404
    <td class="numeric">3198
    <td class="numeric">&plusmn; 12
    <td>

  <tr>
    <td>equiv
    <td><code>-Ce</code>
    <td class="numeric">26964
    <td class="numeric">3722
    <td class="numeric">&plusmn; 13
    <td class="numeric">57392
    <td class="numeric">3295
    <td class="numeric">&plusmn; 38
    <td>

  <tr>
    <td>meta
    <td><code>-Cm</code>
    <td class="numeric">29248
    <td class="numeric">3795
    <td class="numeric">&plusmn; 31
    <td class="numeric">59752
    <td class="numeric">3403
    <td class="numeric">&plusmn; 28
    <td>

  <tr>
    <td>align_equiv
    <td><code>-Cae</code>
    <td class="numeric">30484
    <td class="numeric">3933
    <td class="numeric">&plusmn; 8
    <td class="numeric">60848
    <td class="numeric">3313
    <td class="numeric">&plusmn; 9
    <td>

  <tr>
    <td>equiv_meta
    <td><code>-Cem</code>
    <td class="numeric">25696
    <td class="numeric">4007
    <td class="numeric">&plusmn; 20
    <td class="numeric">56092
    <td class="numeric">3560
    <td class="numeric">&plusmn; 23
    <td>smallest; default

  <tr>
    <td>align_meta
    <td><code>-Cam</code>
    <td class="numeric">34688
    <td class="numeric">3886
    <td class="numeric">&plusmn; 28
    <td class="numeric">65160
    <td class="numeric">3451
    <td class="numeric">&plusmn; 10
    <td>

  <tr>
    <td>align_equiv_meta
    <td><code>-Caem</code>
    <td class="numeric">27776
    <td class="numeric">3915
    <td class="numeric">&plusmn; 16
    <td class="numeric">58172
    <td class="numeric">3482
    <td class="numeric">&plusmn; 12
    <td>

  <tr>
    <td>full
    <td><code>-Cf</code>
    <td class="numeric">52272
    <td class="numeric">1933
    <td class="numeric">&plusmn; 12
    <td class="numeric">82560
    <td class="numeric">1946
    <td class="numeric">&plusmn; 18
    <td>

  <tr>
    <td>full_8
    <td><code>-Cf -8</code>
    <td class="numeric">81456
    <td class="numeric">1919
    <td class="numeric">&plusmn; 9
    <td class="numeric">111744
    <td class="numeric">1946
    <td class="numeric">&plusmn; 18
    <td>

  <tr>
    <td>full_align
    <td><code>-Cfa</code>
    <td class="numeric highlight">81664
    <td class="numeric highlight">1904
    <td class="numeric">&plusmn; 17
    <td class="numeric">112016
    <td class="numeric">1946
    <td class="numeric">&plusmn; 17
    <td>C fastest

  <tr>
    <td>full_align_8
    <td><code>-Cfa -8</code>
    <td class="numeric">140032
    <td class="numeric">1905
    <td class="numeric">&plusmn; 5
    <td class="numeric">170384
    <td class="numeric">1936
    <td class="numeric">&plusmn; 14
    <td>

  <tr>
    <td>full_equiv
    <td><code>-Cfe</code>
    <td class="numeric">33712
    <td class="numeric">2110
    <td class="numeric">&plusmn; 6
    <td class="numeric">63988
    <td class="numeric">2123
    <td class="numeric">&plusmn; 11
    <td>

  <tr>
    <td>full_align_equiv
    <td><code>-Cfae</code>
    <td class="numeric">43952
    <td class="numeric">2107
    <td class="numeric">&plusmn; 21
    <td class="numeric">74228
    <td class="numeric">2113
    <td class="numeric">&plusmn; 17
    <td>

  <tr>
    <td>Jaco
    <td><code>-CJ</code>
    <td class="numeric highlight">43176
    <td class="numeric highlight">1930
    <td class="numeric">&plusmn; 15
    <td class="numeric">73436
    <td class="numeric">2001
    <td class="numeric">&plusmn; 19
    <td>

  <tr>
    <td>Jaco_8
    <td><code>-CJ -8</code>
    <td class="numeric highlight">57304
    <td class="numeric highlight">1920
    <td class="numeric">&plusmn; 12
    <td class="numeric highlight">87788
    <td class="numeric highlight">1816
    <td class="numeric">&plusmn; 7
    <td>

  <tr>
    <td>Jaco_align
    <td><code>-CJa</code>
    <td class="numeric highlight">64152
    <td class="numeric highlight">1913
    <td class="numeric">&plusmn; 40
    <td class="numeric">94428
    <td class="numeric">1824
    <td class="numeric">&plusmn; 11
    <td>

  <tr>
    <td>Jaco_align_8
    <td><code>-CJa -8</code>
    <td class="numeric">92824
    <td class="numeric">1913
    <td class="numeric">&plusmn; 21
    <td class="numeric highlight">123100
    <td class="numeric highlight">1806
    <td class="numeric">&plusmn; 30
    <td>C++ fastest

  <tr>
    <td>Jaco_equiv
    <td><code>-CJe</code>
    <td class="numeric highlight">30616
    <td class="numeric highlight">1984
    <td class="numeric">&plusmn; 8
    <td class="numeric highlight">61056
    <td class="numeric highlight">1862
    <td class="numeric">&plusmn; 2
    <td>C &amp; C++ size &amp; speed

  <tr>
    <td>Jaco_align_equiv
    <td><code>-CJae</code>
    <td class="numeric highlight">38152
    <td class="numeric highlight">1967
    <td class="numeric">&plusmn; 16
    <td class="numeric highlight">68592
    <td class="numeric highlight">1849
    <td class="numeric">&plusmn; 13
    <td>

</table>

<p>
This experiment was run on the same hardware as that used to measure
<a href="#input-read-method">Input Read Method</a> effects.
Consequently, we can account for about 660 ms of time as the cost of
simply reading the input bytes.

<p>
Here is a plot of the C interface data for -Cf and -CJ:

<div class="center">
<img src="img-c-lexer1-both-1000.png" alt="Plot of c-lexer1.lex measurements">
</div>

<p>
We can make some observations based on this data:

<ul>

<li><p>
    If speed matters, it is important to use either <code>-Cf</code>
    ("full") or <code>-CJ</code> ("Jacobson"), as these methods about double
    the scanning speed compared to the alternatives.

<li><p>
    When using the C interface, <code>-CJe</code> (Jaco_equiv) has the
    best balance of size and speed.  <code>-CJ</code> (Jaco) is faster
    while being 33% larger.  <code>-Cfa</code> (full_align) is slightly
    faster still, but the difference is small and
    the size is doubled.

<li><p>
    When using the C++ interface, <code>-CJe</code> again seems to have
    the best size and speed combination, with a few others being
    slightly faster in exchange for larger sizes.  Surprisingly,
    most of the C++ Jacobson variants are a little faster than their
    C counterparts, while the "full" variants a little slower.  Since
    I found this hard to believe, I re-ran all the tests a second time
    and got nearly the same results.  I don't know what explains the
    differences between C and C++ here.

</ul>


<p>
As a second experiment, I used
<a href="test/elsa-lexer.lex"><code>elsa-lexer.lex</code></a>, a
full-featured C/C++ scanner that <em>does</em> enumerate all of the
keywords.  Otherwise the experimental conditions were the same as
above.

<table>
  <tr>
    <th>
    <th>
    <th colspan="3">C interface
    <th colspan="3">C++ interface
    <th>

  <tr>
    <th class="row2">Configuration
    <th class="row2">Switches
    <th class="row2">Size
    <th class="row2">Time
    <th class="row2">IQR
    <th class="row2">Size
    <th class="row2">Time
    <th class="row2">IQR
    <th class="row2">Notes

  <tr>
    <td>compr
    <td><code>-C</code>
    <td class="numeric">55756
    <td class="numeric">3731
    <td class="numeric">&plusmn; 25
    <td class="numeric">85484
    <td class="numeric">3372
    <td class="numeric">&plusmn; 19
    <td>

  <tr>
    <td>align
    <td><code>-Ca</code>
    <td class="numeric">80988
    <td class="numeric">3702
    <td class="numeric">&plusmn; 21
    <td class="numeric">110684
    <td class="numeric">3314
    <td class="numeric">&plusmn; 14
    <td>

  <tr>
    <td>equiv
    <td><code>-Ce</code>
    <td class="numeric">38476
    <td class="numeric">3802
    <td class="numeric">&plusmn; 24
    <td class="numeric">68384
    <td class="numeric">3446
    <td class="numeric">&plusmn; 19
    <td>

  <tr>
    <td>meta
    <td><code>-Cm</code>
    <td class="numeric">39964
    <td class="numeric">3957
    <td class="numeric">&plusmn; 12
    <td class="numeric">69624
    <td class="numeric">3551
    <td class="numeric">&plusmn; 8
    <td>

  <tr>
    <td>align_equiv
    <td><code>-Cae</code>
    <td class="numeric">47180
    <td class="numeric">4047
    <td class="numeric">&plusmn; 2
    <td class="numeric">77024
    <td class="numeric">3494
    <td class="numeric">&plusmn; 27
    <td>

  <tr>
    <td>equiv_meta
    <td><code>-Cem</code>
    <td class="numeric">36076
    <td class="numeric">4167
    <td class="numeric">&plusmn; 8
    <td class="numeric">65868
    <td class="numeric">3662
    <td class="numeric">&plusmn; 15
    <td>smallest; default

  <tr>
    <td>align_meta
    <td><code>-Cam</code>
    <td class="numeric">48316
    <td class="numeric">3960
    <td class="numeric">&plusmn; 5
    <td class="numeric">77976
    <td class="numeric">3541
    <td class="numeric">&plusmn; 20
    <td>

  <tr>
    <td>align_equiv_meta
    <td><code>-Caem</code>
    <td class="numeric">42092
    <td class="numeric">4191
    <td class="numeric">&plusmn; 28
    <td class="numeric">71916
    <td class="numeric">3624
    <td class="numeric">&plusmn; 15
    <td>

  <tr>
    <td>full
    <td><code>-Cf</code>
    <td class="numeric highlight">156704
    <td class="numeric highlight">1891
    <td class="numeric">&plusmn; 14
    <td class="numeric highlight">186556
    <td class="numeric highlight">1860
    <td class="numeric">&plusmn; 22
    <td>

  <tr>
    <td>full_8
    <td><code>-Cf -8</code>
    <td class="numeric">282144
    <td class="numeric">1915
    <td class="numeric">&plusmn; 8
    <td class="numeric">311996
    <td class="numeric">1860
    <td class="numeric">&plusmn; 8
    <td>

  <tr>
    <td>full_align
    <td><code>-Cfa</code>
    <td class="numeric highlight">283184
    <td class="numeric highlight">1862
    <td class="numeric">&plusmn; 12
    <td class="numeric highlight">312956
    <td class="numeric highlight">1851
    <td class="numeric">&plusmn; 16
    <td>C &amp; C++ fastest

  <tr>
    <td>full_align_8
    <td><code>-Cfa -8</code>
    <td class="numeric">534064
    <td class="numeric">1889
    <td class="numeric">&plusmn; 20
    <td class="numeric">563836
    <td class="numeric">1872
    <td class="numeric">&plusmn; 3
    <td>

  <tr>
    <td>full_equiv
    <td><code>-Cfe</code>
    <td class="numeric highlight">98000
    <td class="numeric highlight">2202
    <td class="numeric">&plusmn; 18
    <td class="numeric highlight">127888
    <td class="numeric highlight">2205
    <td class="numeric">&plusmn; 7
    <td>

  <tr>
    <td>full_align_equiv
    <td><code>-Cfae</code>
    <td class="numeric">166592
    <td class="numeric">2208
    <td class="numeric">&plusmn; 16
    <td class="numeric">196496
    <td class="numeric">2218
    <td class="numeric">&plusmn; 23
    <td>

  <tr>
    <td>Jaco
    <td><code>-CJ</code>
    <td class="numeric">327536
    <td class="numeric">2106
    <td class="numeric">&plusmn; 8
    <td class="numeric">357516
    <td class="numeric">2094
    <td class="numeric">&plusmn; 5
    <td>

  <tr>
    <td>Jaco_8
    <td><code>-CJ -8</code>
    <td class="numeric">366464
    <td class="numeric">1887
    <td class="numeric">&plusmn; 7
    <td class="numeric">396428
    <td class="numeric">1866
    <td class="numeric">&plusmn; 9
    <td>

  <tr>
    <td>Jaco_align
    <td><code>-CJa</code>
    <td class="numeric">327536
    <td class="numeric">1872
    <td class="numeric">&plusmn; 15
    <td class="numeric">357532
    <td class="numeric">1879
    <td class="numeric">&plusmn; 19
    <td>

  <tr>
    <td>Jaco_align_8
    <td><code>-CJa -8</code>
    <td class="numeric">366448
    <td class="numeric">1874
    <td class="numeric">&plusmn; 22
    <td class="numeric">396444
    <td class="numeric">1878
    <td class="numeric">&plusmn; 13
    <td>

  <tr>
    <td>Jaco_equiv
    <td><code>-CJe</code>
    <td class="numeric highlight">131664
    <td class="numeric highlight">1924
    <td class="numeric">&plusmn; 5
    <td class="numeric highlight">161660
    <td class="numeric highlight">1925
    <td class="numeric">&plusmn; 10
    <td>C &amp; C++ size &amp; speed

  <tr>
    <td>Jaco_align_equiv
    <td><code>-CJae</code>
    <td class="numeric">234032
    <td class="numeric">1924
    <td class="numeric">&plusmn; 14
    <td class="numeric">264028
    <td class="numeric">1926
    <td class="numeric">&plusmn; 16
    <td>

</table>

<p>
Plot of times for -Cf and -CJ:

<div class="center">
<img src="img-elsa-lexer-both-1000.png" alt="Plot of elsa-lexer.lex measurements">
</div>

<p>The main similarity with the previous table is that <code>-CJe</code>
continues to be a good balance of size and speed, with a few other
points being a bit faster but also larger.  The main difference is that,
this time, C and C++ are the same speed to within measurement error, as
one would expect.


<h2>Effect of Options Other Than Table Compression</h2>

<p>
<strong>Note</strong>: The information in this section is from the
original <code>flex-2.5.4</code> manual, but is suspect.  See next
section.

<p>
Aside from the effects on scanner speed of the
table compression <code>-C</code> options outlined above, there are a
number of options/actions which degrade performance. These are, from
most expensive to least:

<pre><code>
    REJECT
    %option yylineno
    arbitrary trailing context

    pattern sets that require backing up

    '^' beginning-of-line operator
    yymore()
</code></pre>

<p>with the first three all being quite expensive and the last two
being quite cheap. Note also that <code>YY_UNREAD_CHARACTER()</code> is implemented
as a routine call that potentially does quite a bit of work, while
<code>yyless()</code> is a quite-cheap macro; so if just putting back
some excess text you scanned, use <code>yyless()</code>.

<p><code>REJECT</code> should be avoided at all costs when performance
is important. It is a particularly expensive option.


<h2>Investigation of REJECT</h2>

<p>
The previous section claims that <code>REJECT</code> is very expensive,
so I built a performance test for it.  In the <code>smflex</code>
source tree, run:

<pre><code>
  $ cd test
  $ make perftest LEXER_NAME=noreject-frob    # baseline
  $ make perftest LEXER_NAME=reject-frob      # with REJECT
</code></pre>

<p>
On my Windows/MinGW machine, I get (100 iterations, median of 5):

<table>
  <tr>
    <th>Configuration
    <th>Baseline time (ms)
    <th>REJECT time (ms)

  <tr>
    <td>batch (<code>-B</code>)
    <td class="numeric">647
    <td class="numeric">677

  <tr>
    <td>meta (<code>-B -Cm</code>)
    <td class="numeric">641
    <td class="numeric">644

  <tr>
    <td>compr (<code>-B -C</code>)
    <td class="numeric">599
    <td class="numeric">628

  <tr>
    <td>full (<code>-Cf</code>)
    <td class="numeric">360
    <td>

  <tr>
    <td>Jaco (<code>-CJ</code>)
    <td class="numeric">404
    <td>

</table>

<p>
From this we can see that <code>REJECT</code> itself is not very
expensive, only adding a few percent to the run time.  However,
the fact that it is incompatible with <code>-Cf</code> and
<code>-CJ</code> <em>is</em> impactful, as either is about double
the speed of the default settings.


<h2>Investigation of yylineno</h2>

<p>
Similar to the preceding section, there are automated performance
tests of <code>%option yylineno</code> in the source:

<pre><code>
  $ cd test
  $ make perftest LEXER_NAME=noyylineno    # baseline
  $ make perftest LEXER_NAME=yylineno      # with yylineno
</code></pre>

<p>
The results are nearly identical.  The only significant impact is
the inability to use the faster tables.


<h2>Investigation of variable trailing context</h2>

<p>
Same story as the previous two.  Experiment:

<pre><code>
  $ cd test
  $ make perftest LEXER_NAME=notrailing-context    # baseline
  $ make perftest LEXER_NAME=trailing-context      # with trailing context
</code></pre>


<h2>Avoiding backing up</h2>

<p>Getting rid of backing up is messy and often may be an enormous amount
of work for a complicated scanner. In principal, one begins by using the
<code>-b</code> flag to generate a <code>lex.backup</code> file. For example,
on the input

<pre><code>
    %%
    foo        return TOK_KEYWORD;
    foobar     return TOK_KEYWORD;
</code></pre>

<p>the file looks like:

<pre><code>
    State #6 is non-accepting -
     associated rule line numbers:
           2       3
     out-transitions: [ o ]
     jam-transitions: EOF [ \001-n  p-\177 ]

    State #8 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ a ]
     jam-transitions: EOF [ \001-`  b-\177 ]

    State #9 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ r ]
     jam-transitions: EOF [ \001-q  s-\177 ]

    Compressed tables always back up.
</code></pre>

<p>The first few lines tell us that there's a scanner state in which
it can make a transition on an 'o' but not on any other character,
and that in that state the currently scanned text does not match any
rule. The state occurs when trying to match the rules found at lines 2
and 3 in the input file. If the scanner is in that state and then reads
something other than an 'o', it will have to back up to find a rule
which is matched. With a bit of headscratching one can see that this
must be the state it's in when it has seen "fo". When this has happened,
if anything other than another 'o' is seen, the scanner will have to
back up to simply match the 'f' (by the default rule).

<p>The comment regarding State #8 indicates there's a problem when "foob"
has been scanned. Indeed, on any character other than an 'a', the scanner
will have to back up to accept "foo". Similarly, the comment for State
#9 concerns when "fooba" has been scanned and an 'r' does not follow.

<p>The final comment reminds us that there's no point going to all
the trouble of removing backing up from the rules unless we're using
<code>-Cf</code> or <code>-CJ</code>, since there's no performance gain
doing so with compressed scanners.

<p>The way to remove the backing up is to add "error" rules:

<pre><code>
    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    fooba       |
    foob        |
    fo          {
                /* false alarm, not really a keyword */
                return TOK_ID;
                }
</code></pre>

<p>Eliminating backing up among a list of keywords can also be done
using a "catch-all" rule:

<pre><code>
    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    [a-z]+      return TOK_ID;
</code></pre>

<p>This is usually the best solution when appropriate.

<p>Backing up messages tend to cascade. With a complicated set of rules
it's not uncommon to get hundreds of messages. If one can decipher
them, though, it often only takes a dozen or so rules to eliminate the
backing up (though it's easy to make a mistake and have an error rule
accidentally match a valid token. A possible future <code>smflex</code>
feature will be to automatically add rules to eliminate backing up).

<p>It's important to keep in mind that you gain the benefits of
eliminating backing up only if you eliminate <em>every</em> instance of
backing up. Leaving just one means you gain nothing.


<h2>Trailing context</h2>

<p><em>Variable</em> trailing context (where both the leading and trailing
parts do not have a fixed length) entails almost the same performance loss
as <code>REJECT</code> (i.e., substantial). So when possible a rule like:

<pre><code>
    %%
    mouse|rat/(cat|dog)   run();
</code></pre>

<p>is better written:

<pre><code>
    %%
    mouse/cat|dog         run();
    rat/cat|dog           run();
</code></pre>

<p>or as

<pre><code>
    %%
    mouse|rat/cat         run();
    mouse|rat/dog         run();
</code></pre>

<p>Note that here the special '|' action does <em>not</em> provide any
savings, and can even make things worse (see
<a href="#deficiencies-n-bugs">Deficiencies / Bugs</a>).

<p>If there are any rules with variable trailing context, then the
<code>-Cf</code> and <code>-CJ</code> table compression flags cannot
be used.


<h2>Matching longer tokens</h2>

<p>Another area where the user can increase a scanner's performance (and
one that's easier to implement) arises from the fact that the longer the
tokens matched, the faster the scanner will run. This is because with long
tokens the processing of most input characters takes place in the (short)
inner scanning loop, and does not often have to go through the additional
work of setting up the scanning environment (e.g., <code>yytext</code>)
for the action. Recall the scanner for C comments:

<pre><code>
    %x comment
    %%
            int line_num = 1;

    "/*"         YY_SET_START_STATE(comment);

    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;"*"+[^*/\n]*
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;"*"+"/"        YY_SET_START_STATE(INITIAL);
</code></pre>

<p>This could be sped up by writing it as:

<pre><code>
    %x comment
    %%
            int line_num = 1;

    "/*"         YY_SET_START_STATE(comment);

    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;[^*\n]*\n      ++line_num;
    &lt;comment&gt;"*"+[^*/\n]*
    &lt;comment&gt;"*"+[^*/\n]*\n ++line_num;
    &lt;comment&gt;"*"+"/"        YY_SET_START_STATE(INITIAL);
</code></pre>

<p>Now instead of each newline requiring the processing of another action,
recognizing the newlines is "distributed" over the other rules to keep
the matched text as long as possible. Note that <em>adding</em> rules
does <em>not</em> slow down the scanner! The speed of the scanner is
independent of the number of rules or (modulo the considerations given
at the beginning of this section) how complicated the rules are with
regard to operators such as '*' and '|'.


<h2>Combining tokens with adjacent whitespace</h2>

<p>A final example in speeding up a scanner: suppose you want to scan
through a file containing identifiers and keywords, one per line and
with no other extraneous characters, and recognize all the keywords. A
natural first approach is:

<pre><code>
    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */

    .|\n     /* it's not a keyword */
</code></pre>

<p>To eliminate the back-tracking, introduce a catch-all rule:

<pre><code>
    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */

    [a-z]+   |
    .|\n     /* it's not a keyword */
</code></pre>

<p>Now, if it's guaranteed that there's exactly one word per line, then
we can reduce the total number of matches by a half by merging in the
recognition of newlines with that of the other tokens:

<pre><code>
    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */

    [a-z]+\n |
    .|\n     /* it's not a keyword */
</code></pre>

<p>One has to be careful here, as we have now reintroduced backing up into
the scanner. In particular, while <em>we</em> know that there will never
be any characters in the input stream other than letters or newlines,
<code>smflex</code> can't figure this out, and it will plan for possibly
needing to back up when it has scanned a token like "auto" and then the
next character is something other than a newline or a letter. Previously
it would then just match the "auto" rule and be done, but now it has no
"auto" rule, only a "auto\n" rule. To eliminate the possibility of backing
up, we could either duplicate all rules but without final newlines, or,
since we never expect to encounter such an input and therefore don't
how it's classified, we can introduce one more catch-all rule, this one
which doesn't include a newline:

<pre><code>
    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */

    [a-z]+\n |
    [a-z]+   |
    .|\n     /* it's not a keyword */
</code></pre>

<p>Compiled with <code>-Cf</code>, this is about as fast as one can get
a <code>smflex</code> scanner to go for this particular problem.


<h2>Miscellaneous</h2>

<p>A final note: <code>smflex</code> is slow when matching NUL's,
particularly when a token contains multiple NUL's. It's best to write
rules which match <em>short</em> amounts of text if it's anticipated
that the text will often include NUL's.

<p>Another final note regarding performance:
dynamically resizing <code>yytext</code>
to accommodate huge tokens is a slow process because it
requires that the (huge) token be rescanned from the beginning. Thus if
performance is vital, you should attempt to match "large" quantities of
text but not "huge" quantities, where the cutoff between the two is at
about 8K characters per token.


<!-- ======================================================= -->
<h1 id="generating-cpp-scanners">GENERATING C++ SCANNERS</h1>

<p><code>smflex</code> provides two different ways to generate scanners
for use with C++. The first way is to simply compile a C-interface scanner generated
by <code>smflex</code> using a C++ compiler instead of a C compiler. You
should not encounter any compilations errors (please report any you
find). You can
then use C++ code in your rule actions instead of C code.

<p>Alternatively, you can use <code>smflex</code> to generate a
C++-interface scanner class by using the <code>-+</code> option (or,
equivalently, <code>%option c++</code>).  When using this option,
<code>smflex</code> generates <em>two</em> output files, by default called
<code>lex.yy.h</code> and <code>lex.yy.cc</code>.  You can use
<code>-o</code> or <code>%option outfile</code> to change the name of
the <code>.cc</code> file; the <code>.h</code> file name then is computed
by replacing the former's extension with <code>.h</code>.

<p>The header file defines a C++ class, by default called
<code>yyFlexLexer</code>, that encapsulates the scanner state.  Among
other things, that means you can instantiate more than one scanner
instance at a time.  The name of the scanner class can be changed with
the <a href="#prefix-option"><code>-P</code></a> command line option or
the <code>%option prefix</code> input file option: a specified prefix
of <code>foo</code> generates a class called <code>fooFlexLexer</code>.
Furthermore, if you
use <code>%option yyclass</code>, then you can define a class that
inherits <code>yyFlexLexer</code> in order to add additional members.

<p>The C++ file implements the methods of the scanner class, the most
important being the <code>yym_lex()</code> method, which returns scanned
tokens one at a time.  When <code>option %yyclass</code> is used, the
<code>yym_lex()</code> method is a member of the derived class, so the
actions you write can access all of its members.

<p>The following scanner class methods manage the process of running the
scanner over input:

<dl>

<dt><code>yyFlexLexer(istream *arg_yyin = NULL, ostream *arg_yyout = NULL)</code>

<dd><p>constructs a <code>yyFlexLexer</code> object using the given
    streams for input and output. If not specified, the streams default to
    <code>cin</code> and <code>cout</code>, respectively.

<dt><code>int yym_lex()</code>

<dd><p>performs the same role as <code>yy_lex()</code> does for ordinary <code>smflex</code>
    scanners: it scans the input stream, consuming tokens, until a rule's
    action returns a value.

<dt><code>void yym_switch_streams(istream *new_in = NULL, ostream *new_out = NULL)</code>

<dd><p>reassigns <code>yyin</code> to <code>new_in</code> (if not NULL)
    and <code>yyout</code> to <code>new_out</code> (ditto), deleting the
    previous input buffer if <code>yyin</code> is reassigned.  However,
    while <code>smflex</code> manages allocation and deallocation its own
    buffer objects, it does <em>not</em> deallocate any stream objects,
    so you have to arrange for that yourself.

<dt><code>virtual int yym_wrap()</code>

<dd><p>This behaves like
    <a href="#yy_wrap_function"><code>yy_wrap_function</code></a>.

    <p>The default definition returns 1.  You have the option to
    override it in a derived class (whether or not you are using
    <code>%option yyclass</code>).

<dt><code>yym_switch_to_buffer()</code>,
    <code>yym_create_buffer()</code>,
    <code>yym_flush_buffer()</code>,
    <code>yym_delete_buffer()</code>, and
    <code>yym_restart()</code>

<dd><p>These work like their C-interface counterparts except that the
    data sources and sinks are <code>i/ostream</code> pointers rather
    than <code>FILE*</code>.

<dt><code>yym_read_character()</code> and
    <code>yym_unread_character()</code>

<dd><p>These also work like their C-interface counterparts.
    (<a href="test/yym-read-character.lexpp">Example.</a>)

<dt><code>yym_set_start_state()</code>,
    <code>yym_get_start_state()</code>,
    <code>yym_push_state()</code>,
    <code>yym_pop_state()</code>, and
    <code>yym_top_state()</code>

<dd><p>Same as the C interface.
    (<a href="test/discard-ml-comments-cpp.lexpp">Example.</a>)

<dt><code>static void yym_check_for_memory_leaks()</code>

    <dd><p>Same as
    <a href="#yy_check_for_memory_leaks"><code>yy_check_for_memory_leaks</code></a>.

</dl>

<p>When <code>yym_lex()</code> returns a non-zero value, these methods
can be used to inspect the token:

<dl>

<dt><code>const char *yym_text()</code>

<dd><p>returns the text of the most recently matched token, the equivalent
    of <code>yytext</code>.

<dt><code>int yym_leng()</code>

<dd><p>returns the length of the most recently matched token, the equivalent
    of <code>yyleng</code>.

<dt><code>int yym_lineno() const</code>

<dd><p>returns the current input line number.  This method only exists
    if <code>%option yylineno</code> has been used.

</dl>

<p>These methods support scanner debugging:

<dl>

<dt><code>void yym_set_flex_debug(int flag)</code>

<dd><p>sets the debugging flag for the scanner, equivalent to assigning to
    <code>yy_flex_debug</code>. Note that you must build the scanner using
    <a href="#debug-option"><code>%option debug</code></a> to include
    debugging information in it.

<dt><code>int yym_flex_debug() const</code>

<dd><p>returns the current setting of the debugging flag.

</dl>

<p>In addition, <code>yyFlexLexer</code> defines the following protected
virtual functions which you can redefine in derived classes to adjust
how the scanner gets access to its input.  By overriding these,
<code>yyin</code> and <code>yyout</code> can be bypassed entirely:

<dl>

<dt><code>virtual int yym_LexerInput(char *buf, int max_size)</code>

<dd><p>reads up to <code>max_size</code> characters into <code>buf</code> and
    returns the number of characters read. To indicate end-of-input, return 0
    characters.

    <p>The base class implementation tests
    <code>yy_current_buffer-&gt;yy_is_interactive</code>
    to decide whether to read input one character at a time.  If you
    override this method, you may wish to do likewise.

<dt><code>virtual void yym_LexerOutput(const char *buf, int size)</code>

<dd><p>writes out <code>size</code> characters from the buffer
    <code>buf</code>, which, while NUL-terminated, may also contain "internal"
    NUL's if the scanner's rules can match text with NUL's in them.

<dt><code>virtual void yym_LexerError(const char *msg)</code>

<dd><p>reports a fatal error message. The default version of this function
    writes the message to the stream <code>cerr</code> and exits.

</dl>

<p>Note that a <code>yyFlexLexer</code> object contains its
<em>entire</em> scanning state. Thus you can use such objects to create
reentrant scanners. You can instantiate multiple instances of the same
<code>yyFlexLexer</code> class, and you can also combine multiple C++
scanner classes together in the same program using the <code>-P</code>
option discussed above.

<p>Here is an <a href="test/cpp-manual-example.lexpp">example</a>
of a simple C++ scanner:

<pre><!-- BEGIN example: "cpp-manual-example.lexpp" indent=4 --><code>
        // An example of using the smflex C++ scanner class.

    %option c++
    %option prefix="Example"
    %option yy_read_character
    %option yy_unread_character

    %{
    int mylineno = 0;
    %}

    string  \"[^\n"]+\"

    ws      [ \t]+

    alpha   [A-Za-z]
    dig     [0-9]
    name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
    num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
    num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
    number  {num1}|{num2}

    %%

    {ws}    /* skip blanks and tabs */

    "/*"    {
            int c;

            while((c = YY_READ_CHARACTER()) != 0)
                {
                if(c == '\n')
                    ++mylineno;

                else if(c == '*')
                    {
                    if((c = YY_READ_CHARACTER()) == '/')
                        break;
                    else
                        YY_UNREAD_CHARACTER(c);
                    }
                }
            }

    {number}  std::cout &lt;&lt; "number " &lt;&lt; yym_text() &lt;&lt; '\n';

    \n        mylineno++;

    {name}    std::cout &lt;&lt; "name " &lt;&lt; yym_text() &lt;&lt; '\n';

    {string}  std::cout &lt;&lt; "string " &lt;&lt; yym_text() &lt;&lt; '\n';

    %%

    int main()
    {
        // Instantiate the scanner, which by default reads from cin (stdin).
        ExampleFlexLexer lexer;

        // Read tokens until EOF, doing only what the scanner actions do.
        while (lexer.yym_lex() != 0)
            {}

        return 0;
    }
</code><!-- END example --></pre>

<p>If you want to create multiple (different) lexer classes, use
the <code>-P</code> flag (or <code>%option prefix</code>) to rename
each <code>yyFlexLexer</code> to some other <code>xxFlexLexer</code>. You
then can freely include the generated header files in your other sources
without conflicts.

<p><strong>Recommendation</strong>: Use <code>%option prefix</code> in
every scanner definition from the start to save the hassle of renaming
things later.


<!-- ======================================================= -->
<h1 id="incompatibilities-with-flex">INCOMPATIBILITIES WITH FLEX</h1>

<p>This document describes <code>smflex</code>,
Scott McPeak's fork of <code>flex-2.5.4</code>.  I have made
a number of changes that introduce incompatibilities with
<code>flex-2.5.4</code>, listed below.  Although full compatibility with
<code>flex-2.5.4</code> is not among my goals, I want to enable users
to transition to <code>smflex</code>, and this list can help that.


<h2 id="changes-to-the-options-interface">Changes to the Options Interface</h2>

<p>The general theme of these changes is to simplify and clarify the
options interface, as well as removing some legacy features unlikely
to be of continued value.

<ul>

<li><p><code>flex-2.5.4</code> uses <code>-CF</code> and
    <code>%option fast</code> to mean to use Jacobson tables.
    In <code>smflex</code>, they has been renamed to <code>-CJ</code>
    and <code>%option jacobson</code>.

    <p>Rationale: The <code>-CF</code> flag was confusingly similar to
    <code>-Cf</code>, and the name "fast" descriptive of a desired
    property rather than a method of achieving it (and the "full" method
    was also aspirationally described as "fast" in places).  The method
    is evidently (based on a single comment in <code>main.h</code>!)
    based on Guy Jacobson's 1988 PhD thesis, "Succinct static data
    structures", so I used that as a basis for a new name.  I chose to
    keep the option ("J") letter capitalized as an aid when
    transitioning (since, in the old system, the fact that "F" was
    capitalized was its only distinguishing feature).

    <p>Replacement: Use <code>-CJ</code> and
    <code>%option jacobson</code> instead.

<li><p><code>flex-2.5.4</code> accepts <code>-f</code> and
    <code>-F</code> options as aliases for <code>-Cfr</code> and
    <code>-CJr</code>, respectively.  <code>smflex</code> does not
    accept them.

    <p>Rationale: The aliases are confusing and unnecessary, and
    interfere with being able to further untangle and clarify the
    options.

    <p>Replacement: Use <code>-Cfr</code> or <code>-CJr</code>.

<li><p>In <code>flex-2.5.4</code>, both <code>%option full</code>
    and <code>%option fast</code> (now called
    <code>%option jacobson</code>) implied <code>%option read</code>.
    That implication has been removed.

    <p>Rationale: I want options to be as orthogonal as possible.
    <a href="#table-compression-options">Table compression</a> is
    completely independent of
    <a href="#input-read-method">input read method</a>.

    <p>Replacement: Use <code>%option read</code> explicitly if desired.

<li><p><code>flex-2.5.4</code> accepts
    <code>%option always-interactive</code> and
    <code>%option never-interactive</code>, which influenced whether
    input was read one character at a time.  These options have been
    removed.  In <code>smflex</code>, there is only one switch
    that controls interactivity preferences, namely
    <a href="#interactive-option"><code>-I</code></a>
    (<code>%option interactive</code>), and it controls both aspects
    of interactivity, namely <em>scanner action eagerness</em> and
    <em>default input read behavior</em>.

    <p>Rationale: The effect of these switches was (IMO) surprising and
    inconsistent, as well as buggy in the case of C++, and the multitude
    of options and effects made it
    difficult for users to know what to select.  See <a
    href="historical/interactivity.txt">historical/interactivity.txt</a>
    for more details.  Now, there is one switch, and it behaves sensibly
    for both C-interface and C++-interface scanners.

    <p>Replacement: To change the input read behavior separately from
    the scanner action eagerness, call
    <a href="#yy_set_interactive"><code>yy_set_interactive()</code></a>.

<li><p>In <code>flex-2.5.4</code>, if neither
    <code>always-interactive</code> nor <code>never-interactive</code>
    were specified, then the C-interface scanner input file was read
    one character at a time if <code>isatty</code> said the input was
    a TTY, and one block at a time otherwise.  Now, the default behavior
    is determined by the <code>-I</code> flag, and <code>isatty</code>
    is not called.

    <p>Rationale: The call to <code>isatty</code> was a portability
    concern since it is not part of the standard C library (it is part
    of POSIX).  Furthermore, I think it is inappropriate for a text
    scanning engine to be in the business of making user interface
    decisions by querying interprocess communication mechanisms.

    <p>Replacement: If the old behavior is desirable, then call
    <a href="#yy_set_interactive"><code>yy_set_interactive(isatty)</code></a>.

<li><p><code>flex-2.5.4</code> defaults to generating an interactive
    scanner (<a href="#interactive-option"><code>-I</code></a> option)
    except when using <code>-Cf</code> or <code>-CJ</code>.
    <code>smflex</code> generates a batch scanner by default, independent
    of other options.

    <p>Rationale: First, I don't like defaults that depend on other
    options since that is confusing.  Second, most users do not want
    interactive scanners, but interactive scanning is about 10x
    slower due to reading one character at a time.
    In <code>flex-2.5.4</code> this was not as large a problem because
    the input read behavior was controlled separately and the default
    used <code>isatty</code> (when not using <code>%option c++</code>).
    After straightening out those aspects, making non-interactive the
    default is necessary.

    <p>Replacement: Use <code>-I</code> explicitly if desired.

<li><p><code>flex-2.5.4</code> accepts <code>%option array</code>,
    which tells it to declare <code>yytext</code> as a static array
    and copy scanned tokens into it, rather than it being a pointer
    into the read buffer.  This option has been removed, along with
    <code>%option pointer</code>, which was its opposite (and the
    default).

    <p>Rationale: Its primary purposes was compatibility with
    <code>lex</code>, which is not among my goals; it was just
    dead weight to me.

    <p>Replacement: None in <code>smflex</code>.  If this feature is
    essential to your scanner, you will have to stick with
    <code>flex</code>.  I'd like to hear about such cases.

<li><p><code>flex-2.5.4</code> accepts <code>-l</code> and
    <code>lex-compat</code>, both meaning to enable compatibility
    with <code>lex</code>. These have been removed.

    <p>Rationale: Again, I do not care about <code>lex</code>
    compatibility, and want to shed unneeded code.  Moreover,
    I already broke it by removing <code>%option array</code>;
    this just finishes the job.

    <p>Replacement: None.

<li><p><code>flex-2.5.4</code> accepted and ignored the <code>-c</code>
    command line option.  This option is no longer accepted.

    <p>Rationale: The original behavior was for compatibility with
    POSIX, which I do not care about, and I want to remove
    anything unnecessary in order to ease further maintenance.

    <p>Replacement: Do not pass the <code>-c</code> option.

<li><p><code>flex-2.5.4</code> accepted and ignored the <code>-n</code>
    command line option.  Now, <code>-n</code> means to use platform
    native line endings.

    <p>As with <code>-c</code>, I do not care about POSIX compatibility.
    And since I needed an option letter, and "n" is a natural choice for
    this, and its behavior is fairly harmless if used unintentionally, I
    chose to reuse it.

    <p>Replacement: Do not pass <code>-n</code> if you want it ignored.

<li><p><code>flex-2.5.4</code> accepted the <code>-t</code> command line
    option, and the input file <code>%option stdout</code>, to specify
    that output be written to stdout instead of a file.  These options
    are no longer accepted.

    <p>Rationale: I want to have <code>smflex</code> write <em>two</em>
    files, a C or C++ implementation file and an accompanying header
    file.  It would then be weird to continue allowing one of those
    files to be written to stdout; I prefer the uniformity of both going
    to files.

    <p>Replacement: Arrange to receive the output in files.

<li><p><code>flex-2.5.4</code> is willing to read its input from
    standard input if no input files are specified, and from multiple
    input files (effectively concatenating them) if multiple are
    specified.  <code>smflex</code> insists there be exactly one
    input file.

    <p>Rationale: I want to derive the default output file and
    prefix name from the input file, in part to ensure people use
    prefix names from the start, but that requires there be at
    least one file.  Multiple input files are weird, and also cause
    a problem for naming because the first input file might not have
    a distinguishing name (e.g., if it is boilerplate).

    <p>Replacement: Put the input into a named file, concatenating
    multiple files beforehand if necessary.

<li><p><code>flex-2.5.4</code> accepted the <code>-S</code> option to
    specify an alternate scanner implementation skeleton file.  That
    option has been removed.

    <p>Rationale: The documentation explained the option was only for
    the use of maintainers, but as a maintainer, I never saw any need
    for it.  Additionally, now that there are sometimes two output
    files, I would have to add another option to keep the full
    functionality.

    <p>Replacement: Change <code>generated-scanner.skl</code> and
    recompile.

<li id="option-yywrap-removed"><p><code>flex-2.5.4</code> accepted
    <code>%option yywrap</code> (with default value true),
    meaning the user must define <code>yywrap()</code>, and
    <code>%option noyywrap</code> to not require that definition.
    These option
    have been removed in favor of the <code>yy_wrap_function()</code>
    function pointer member.

    <p>Rationale: A function pointer is more flexible, as it can be set
    at run time.  (And this function is called infrequently, so there is
    no performance concern.)  This also lets me remove one
    <code>smflex</code> option, simplifying the testing matrix.

    <p>Replacement for <code>%option noyywrap</code>: None needed;
    just remove it.

    <p>Replacement for <code>%option yywrap</code>:
    Set <code>yy_wrap_function</code> like
    <a href="test/username-yywrap.lex">this</a>:

    <pre><!-- BEGIN example: "username-yywrap.lex" fragment=true indent=8 --><code>
        int main()
        {
          yy_lexer_t lexer;
          yy_construct(&amp;lexer);

          /* This line is the replacement for the old "%option yywrap". */
          lexer.yy_wrap_function = &amp;yywrap;

          while (yy_lex(&amp;lexer))
            {}
          yy_destroy(&amp;lexer);
          return 0;
        }
    </code><!-- END example --></pre>

<li><p><code>flex-2.5.4</code> accepted
    <code>%option noyy_push_state</code> and
    <code>%option noyy_pop_state</code> in order to suppress the
    definitions of <code>yy_push_state</code> and
    <code>yy_pop_state</code>.  These options are no longer accepted.

    <p>Rationale: They were useless.  Those functions are only emitted
    if <code>%option stack</code> is used, in which case both
    <code>push</code> and <code>pop</code> will be used; it is
    nonsensical to use only one of them.

    <p>Replacement: Do not set <code>option %stack</code> if you are
    not using these functions.

<li><p>In <code>flex-2.5.4</code>, the default value for
    <code>%option</code>s
    <code>yy_top_state</code>,
    <code>yy_scan_string</code>,
    <code>yy_scan_bytes</code>, and
    <code>yy_scan_buffer</code>
    were <code>true</code>; they are now <code>false</code>.

    <p>Rationale: In the old system, optional functions were
    generated by default.  Since that could cause unneeded code bloat
    and compiler warnings when the functions were not used, the user
    could turn them off one by one with options like
    <code>noyy_top_state</code>.  This is an annoying thing to have to
    do.  It is also a forward compatibility problem because if a new
    optional function is added following the existing pattern, it would
    be generated by default, thus causing warnings when previously there
    were none.  In the new system, nothing optional is generated unless
    the user explicitly requests it.  This way, the user need mention
    only things they actually know and care about, and new optional
    features can be introduced without causing new warnings.

    <p>Replacement: Explicitly set the options if you use the
    respective functions.

<li><p>In <code>flex-2.5.4</code>, the <code>input()</code> macro
    (or its C++ counterpart, <code>yyinput()</code>) was available by
    default due to <code>%option input</code> being true by default.
    In <code>smflex</code>, <code>%option input</code> has been
    renamed to <code>%option yy_read_character</code>, which is false
    by default.

    <p>Rationale: Changing the default to false follows the same
    principles as the previous bullet.  Renaming the option follows
    renaming of the macros, which is explained below.

    <p>Replacement: If you have <code>%option noinput</code> (which
    would have been to silence compiler warnings), remove it.  If
    you have <code>%option input</code>, change it to
    <code>%option yy_read_character</code>.

<li><p>In <code>flex-2.5.4</code>, the <code>unput()</code> macro
    was available by default due to <code>%option unput</code>
    being true by default.
    In <code>smflex</code>, <code>%option unput</code> has been
    renamed to <code>%option yy_unread_character</code>, which is false
    by default.

    <p>Rationale: Same as in preceding bullet.

    <p>Replacement: If you have <code>%option nounput</code> (which
    would have been to silence compiler warnings), remove it.  If
    you have <code>%option unput</code>, change it to
    <code>%option yy_unread_character</code>.

<li><p>In <code>flex-2.5.4</code>, the <code>-P</code> or
    <code>%option prefix</code> transformation would leave "yy"
    aliases available for use within the scanner input file.  In
    <code>smflex</code>, only the transformed names (with the prefix
    applied) are available.

    <p>Rationale: Aliases are confusing.  They would also prevent one
    scanner's definition from using another scanner's exported API.

    <p>Replacement: In a scanner definition using a prefix, always
    use the prefixed name for externally visible symbols.  (TODO: How
    do users easily tell which names are external?  Can I make it so
    external names are all lowercase, and non-external are uppercase?)

    <p>Discussion: I believe the reason for their original inclusion
    (aside from being a side effect of the implementation technique) is
    the historical tendency for people to not use prefixes initially,
    and only specify one when forced to due to linking constraints.
    Thus, to minimize renaming hassle, both names were left.  In
    <code>smflex</code>, I want to strongly encourage using prefixes
    from the start (and may mandate that, or perhaps merely provide a
    warning).  If that is done, then there is little need for the
    aliases.

<li><p><code>flex-2.5.4</code> accepts
    <code>%option stdinit</code>, which means to statically initialize
    <code>yyin</code> and <code>yyout</code> to <code>stdin</code>
    and <code>stdout</code>.  <code>smflex</code> does not accept this
    option.

    <p>Rationale: <code>yyin</code> and <code>yyout</code> are no
    longer global variables, so cannot be statically initialized.
    (And, as noted in the option description, doing so was not
    valid ANSI C anyway.)

    <p>Replacement: None.

</ul>


<h2 id="removal-of-libfl-a">Removal of libfl.a</h2>

<p>
<code>flex-2.5.4</code> included <code>libfl.a</code>, an optional
run-time support library.  That has been removed as detailed below.

<ul>

<li><p>In <code>flex-2.5.4</code>, the <code>main()</code>
    function generated with
    <a href="#option-main"><code>%option main</code></a>
    called <code>yy_lex()</code> (then called <code>yylex()</code>
    just once.  Now it calls
    <code>yy_lex()</code> in a loop until it returns 0.

    <p>Rationale: The old behavior was useful only in the case of a
    scanner that never returned any token codes, instead only executing
    actions and continuing to scan.  Additionally, the new behavior
    matches what the old <code>libfl.a</code> contained, allowing me to
    eliminate <code>libfl.a</code> without losing functionality.

    <p>Replacement: Remove <code>%option main</code> and provide an
    explicit definition: <code>int main() { yy_lex(); return 0; }</code>.

<li><p><code>flex-2.5.4</code> provided <code>libfl.a</code>, which
    contained definitions of <code>main()</code> (which called
    <code>yylex()</code> in a loop) and <code>yywrap()</code> (which returned 1).
    I have removed <code>libfl.a</code> entirely.

    <p>Rationale: The existence of a library compiled on the build
    machine but that executes on the host machine is a significant
    annoyance when cross-compiling and when dealing with the many
    varieties of C/C++ implementations on Windows.  With this change,
    the generated scanner consists entirely of source code that does
    not depend on anything except the standard C or C++ libraries.

    <p>Replacement: Set <code>%option main</code> to get an equivalent
    <code>main()</code> emitted into the generated scanner.
    <code>%option yywrap</code> has been removed in favor of
    <a href="#yy_wrap_function"><code>yy_wrap_function</code></a>, so
    there is no need for a definition of <code>yywrap()</code>.

</ul>


<h2 id="removed-features">Removed Features</h2>

<p>Some features have been removed:

<ul>

<li><p><code>YY_DECL</code>: In <code>flex-2.5.4</code>, you could
    <code>#define YY_DECL</code> to change the name and signature of the
    generated lexer function.  This is no longer possible.

    <p>Rationale: For re-entrancy, this had to break at least a little,
    because the lexer must accept a <code>yy_lexer_t*</code> parameter.
    Furthermore, crudely replacing the declaration like that does not
    work when <code>smflex</code> also wants to generate a header file
    with the scanner's API.

    <p>Replacement: To rename the lexer function, use the
    <code>-P</code> (prefix) option.  To make additional data
    available within actions (which previously would have been done
    by adding parameters), set the <code>yy_client_data</code> field
    of the <code>yy_lexer_t</code> object.

<li><p><code>yy_new_buffer</code>: <code>flex-2.5.4</code> defined
    <code>yy_new_buffer</code> as an alias for
    <code>yy_create_buffer</code>.  That alias has been removed.

    <p>Rationale: The explanation in the <code>flex</code> manual for
    the existence of this function was: "compatibility with the C++ use
    of <code>new</code> and <code>delete</code> for creating and
    destroying dynamic objects".  I find that a very weak justification
    for adding a redundant name to the name space.  The fact that a
    function has "new" it its name does nothing to make it similar
    to <code>new</code> and <code>delete</code> semantically.

    <p>Replacement: Use <code>yy_create_buffer</code>.

<li><p><code>YYSTATE</code>: <code>flex-2.5.4</code> accepted
    <code>YYSTATE</code> as an alias for <code>YY_GET_START_STATE</code>.
    That alias has been removed.

    <p>Rationale: The reason given for <code>YYSTATE</code> was
    compatibility with AT&amp;T <code>lex</code>, which I do not
    care about.

    <p>Replacement: Use <code>YY_GET_START_STATE</code>.

<li><p><code>struct yy_buffer_state</code>: The <code>flex-2.5.4</code>
    manual advertised that if you want to declare a pointer to a buffer
    from some external file, you should declare it as a pointer to
    <code>struct yy_buffer_state</code>.  This type has been removed.
    (Really it has been renamed, but it is no longer part of the public
    API.)

    <p>Rationale: Conjuring type declarations for foreign APIs out of
    thin air is fragile.

    <p>Replacement: Include the generated header file.  It declares all
    of the types needed to use the API, as well as the API functions
    themselves (which also would have needed to have been conjured when
    using <code>flex-2.5.4</code>).

</ul>


<h2 id="renamed-entities">Renamed Entities</h2>

<p>Several entities have been renamed:

<ul>

<li><p>The <code>yyrestart</code> and
    <code>yylex</code> functions have been renamed to
    <code>yy_restart</code> and
    <code>yy_lex</code>, respectively.

    <p>Rationale: I want to encourage the use of <code>-P</code>
    (prefix).  That option only produces good-looking names if there
    is an underscore separating the "yy" from the rest of the name
    (and the prefix cannot end with an underscore, because that would
    produce identifiers with two underscores in a row, which are
    reserved in C++).
    This also makes these functions consistent with the rest.

<li><p>The <code>input()</code> and <code>yyinput()</code> macros have
    been renamed to <code>YY_READ_CHARACTER()</code>.

    <p>Rationale: The old name <code>input()</code> was inconsistent due to not using the
    "yy" prefix.  It was also strange because it would be called
    <code>yyinput()</code> when generating a C++ interface, causing a
    needless difference between the two.  The latter was then easily
    confused with <code>YY_INPUT</code>, a completely different macro.
    The new name uses the "YY_"
    prefix for forward compatibility and has a clearer, more unique name.

    <p>However, <code>%option flex-compat</code> will introduce both
    <code>input</code> and <code>yyinput</code> as aliases for
    <code>YY_READ_CHARACTER</code>.

<li><p>The <code>yywrap</code> function has been replaced by
    <a href="#yy_wrap_function"><code>yy_wrap_function</code></a>.

    <p>See the discussion of the removal of
    <a href="#option-yywrap-removed"><code>%option yywrap</code></a>.

<li><p>The <code>unput()</code> macro has
    been renamed to <code>YY_UNREAD_CHARACTER()</code>.

    <p>Rationale: Similar to the preceding.  Plus, "unput" is a weird
    name because it does not "undo put"; instead it is more like
    "undo input", with needlessly confusing contraction.

    <p>With <code>%option flex-compat</code>, <code>unput()</code> is
    available as an alias for <code>YY_UNREAD_CHARACTER()</code>.

<li><p>The <code>ECHO</code> macro has been renamed to
    <code>YY_ECHO</code>.

    <p>Rationale: This is a continuation of the theme of adding "YY_"
    to all names.

    <p>With <code>%option flex-compat</code>, <code>ECHO</code> is
    available as an alias for <code>YY_ECHO</code>.

<li><p>The <code>yyless</code> macro has been renamed to
    <code>YY_LESS_TEXT</code>.

    <p>Rationale: In addition to adding "YY_" to and capitalizing all
    macro names, I added "_TEXT" to clarify what we are getting less of.

    <p>With <code>%option flex-compat</code>, <code>yyless</code> is
    available as an alias for <code>YY_LESS_TEXT</code>.

<li><p>The <code>BEGIN</code> macro has been renamed to
    <a href="#YY_SET_START_STATE-macro"><code>YY_SET_START_STATE</code></a>.
    Additionally, it now requires a parenthesized argument, whereas in
    <code>flex</code> it is legal to write "<code>BEGIN s;</code>" to
    change to start condition <code>s</code>

    <p>Rationale: The new name adheres to my naming convention and
    has a clearer purpose.  In particular, it is weird how the old
    name uses "BEGIN" for both the act of entering and leaving a
    special parsing mode.  The new name does not imply there is a
    "leave" counterpart.

    <p>The old name is available with
    <code>%option flex-compat</code>.

<li><p>The <code>YY_START</code> macro has been replaced by
    <a href="#YY_GET_START_STATE-macro"><code>YY_GET_START_STATE()</code></a>.
    Note that the old macro was used without parentheses, while the new
    one requires them.

    <p>Rationale: The old name was a bit terse, and I wanted something
    parallel with the new <code>YY_SET_START_STATE</code>.  The old
    lack of parentheses clashes with my intended parallel use of
    <a href="#yy_get_start_state"><code>yy_get_start_state</code></a>.

    <p>The old name, which is used without parentheses, is available with
    <code>%option flex-compat</code>.

<li><p>The <code>YY_INPUT</code> macro has been replaced by
    <a href="#yy_read_input_function"><code>yy_read_input_function</code></a>.

    <p>Rationale: Using macros to configure the scanner is somewhat
    fragile (due to C syntax quirks) and limited (it can only access
    what is in scope where it is used), and it requires modifying the
    scanner and recompiling.  A function pointer is much more flexible.

<li><p>The <code>YY_FATAL_ERROR</code> macro has been replaced by
    <a href="#yy_error_function"><code>yy_error_function</code></a>.

    <p>Rationale: Function pointers are more flexible than macros.

<li><p>The <code>YY_BUFFER_STATE</code> type (implicitly a pointer) has
    been renamed to <code>yy_buffer_state_t*</code> (explicitly a
    pointer).

    <p>Rationale: Making the pointerness implicit offers no additional
    flexibility, while slightly increasing the potential for confusion.
    More importantly, I am trying to organize the names so that
    lowercase names are consistently exported as part of the external
    API, while uppercase names are those only usable from within the
    scanner definition file.  This type is meant for external use, so
    that means it should be lowercase.

<li><p><code>YY_FLUSH_BUFFER</code> has been renamed to
    <code>YY_FLUSH_CURRENT_BUFFER</code>.

    <p>Rationale: I have the function
    <a href="#yy_flush_buffer"><code>yy_flush_buffer</code></a>, but
    that requires a specific buffer object.  Since the behavior of the
    macro acts on the current buffer only, the name ought to reflect
    that.

    <p>There is no compatibility alias for this one.  According to my
    naming conventions, if it existed, <code>YY_FLUSH_BUFFER</code>
    should be the same as <code>yy_flush_buffer(yy_lexer)</code>, but an
    alias would violate that.

<li><p><code>YY_AT_BOL</code> has been renamed to <code>YY_GET_BOL</code>.

    <p>Rationale: Everywhere else I use "GET", so "AT" is irregular.

    <p>The old name is available with
    <code>%option flex-compat</code>.

</ul>

<p>
Renaming summary:

<table>
  <tr>
    <th>Old name
    <th>New name
    <th>Notes
  <tr>
    <td><code>yylex</code>
    <td><code>yy_lex</code>
    <td>Now requires a <code>yy_lexer_t*</code> parameter.
  <tr>
    <td><code>yyrestart</code>
    <td><code>yy_restart</code>
    <td>Now requires a <code>yy_lexer_t*</code> parameter.
  <tr>
    <td><code>yywrap</code>
    <td><a href="#yy_wrap_function"><code>yy_wrap_function</code></a>
    <td>Replacement rather than rename.
  <tr>
    <td><code>input</code>
    <td><code>YY_READ_CHARACTER</code>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>yyinput</code>
    <td><code>YY_READ_CHARACTER</code>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>unput</code>
    <td><code>YY_UNREAD_CHARACTER</code>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>ECHO</code>
    <td><code>YY_ECHO</code>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>yyless</code>
    <td><a href="#YY_LESS_TEXT-macro"><code>YY_LESS_TEXT</code></a>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>BEGIN</code>
    <td><a href="#YY_SET_START_STATE-macro"><code>YY_SET_START_STATE</code></a>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>YY_BUFFER_STATE</code>
    <td><code>yy_buffer_state_t*</code>
    <td>Old name available with <code>%option flex-compat</code>.
  <tr>
    <td><code>YY_INPUT</code>
    <td><a href="#yy_read_input_function"><code>yy_read_input_function</code></a>
    <td>Replacement rather than rename.
  <tr>
    <td><code>YY_FATAL_ERROR</code>
    <td><a href="#yy_error_function"><code>yy_error_function</code></a>
    <td>Replacement rather than rename.
  <tr>
    <td><code>YY_FLUSH_BUFFER</code>
    <td><code>YY_FLUSH_CURRENT_BUFFER</code>
    <td>Old name is not defined, and there is no alias.
  <tr>
    <td><code>YY_AT_BOL</code>
    <td><code>YY_GET_BOL</code>
    <td>Old name available with <code>%option flex-compat</code>.
</table>


<h2 id="changed-function-signatures">Changed Function Signatures</h2>

<p>In addition to the signatures changed as part of renaming, above,
   the following functions all take an additional
   <code>yy_lexer_t*</code> parameter in order to support having
   multiple scanner state instances:

<ul>
<li><code>yy_create_buffer</code>
<li><code>yy_switch_to_buffer</code>
<li><code>yy_delete_buffer</code>
<li><code>yy_flush_buffer</code>
<li><code>yy_scan_string</code>
<li><code>yy_scan_bytes</code>
<li><code>yy_scan_buffer</code>
<li><code>yy_push_state</code>
<li><code>yy_pop_state</code>
<li><code>yy_top_state</code>
<li><code>yy_set_interactive</code>
<li><code>yy_set_bol</code>
</ul>


<h2 id="functions-that-were-macros">Functions that Were Macros</h2>

<p>Although it should not matter, a few functions in
<code>smflex</code> were defined as macros in older <code>flex</code>.
They were changed due to internal engineering reasons and listed here
only for completeness:

<ul>
<li><code>yy_set_interactive</code>
<li><code>yy_set_bol</code>
</ul>


<h2 id="changes-to-the-cpp-interface">Changes to the C++ Interface</h2>

<p>There are several changes to the C++ interface
compared to <code>flex-2.5.4</code>:

<ul>

<li><p>The separate <code>FlexLexer</code> abstract base class is gone.

    <p>Rationale:
    It was not very useful (since a client would have no way of knowing
    what the token codes meant), and interferes with being able to easily
    combine multiple scanners in one program (since the cleanest way to
    do that would be to emit <em>two</em> headers, which is undesirable).

    <p>Replacement: None.  If there is a compelling case for such an
    interface, let me know and I'll consider re-adding it.

<li><p>The single <code>FlexLexer.h</code> header has been replaced
    by generating a different header for every scanner class.

    <p>Rationale: The old method was clumsy and not entirely
    effective, depending on the project's <code>#include</code>
    structure.  It was also sometimes annoying to retrieve that
    header from a system include directory.  The new way keeps all
    scanners cleanly separated and there is no dependence on
    system includes.

    <p>Replacement: Replace all uses of <code>FlexLexer.h</code>
    with <code>lex.yy.h</code> or the whatever name you have
    selected with <code>-o</code> or <code>%option outfile</code>.

<li><p>Previously it was possible to select C++ mode by invoking
    <code>flex</code> as <code>flex++</code>; that sensitivity to
    the program name has been removed.

    <p>Rationale: I dislike the idea that a program's behavior
    depends on its name.

    <p>Replacement: Use <code>%option c++</code> or the
    <code>-+</code> command line option.

<li><p>All members <code>yyFlexLexer</code> have been renamed to use the
    prefix "yym_" instead.  For example, the main lexing method is called
    <code>yym_lex()</code> rather than <code>yylex()</code>.

    <p>Rationale: Under the previous naming scheme, methods shared names
    with global functions with which they could be easily confused, both
    during maintenance and by <code>smflex</code> users.  It also causes
    problems in the generated code, where a "::" qualifier would be
    needed to call the functions when the C++ interface is active, which
    is annoying and adds a lot of clutter.  The older design relied on
    that collision since it only emitted C <em>or</em> C++; but in
    <code>smflex</code>, the C++ is a wrapper around the C, so
    collisions between them are undesirable.

    <p>There were also some members, like <code>switch_streams</code>,
    that had no prefix.  These are a problem for compatibility between
    versions since they can collide with user-defined members of a
    derived class.

<li><p>The <code>int yylex(istream *new_in, ostream *new_out = 0)</code>
    method is gone.

    <p>Rationale: It was not very useful, and created an overload
    of an important method, which is confusing.

    <p>Replacement: The replacement for <code>yylex(i,o)</code> is
    to call <code>yym_switch_streams(i,o)</code> and then
    <code>yym_lex()</code>, which is precisely what the old method
    did.

<li><p>The methods <code>LexerInput</code>, <code>LexerOutput</code>,
    and <code>LexerError</code>
    have been renamed to <code>yym_read_input</code>,
    <code>yym_write_output</code>, and
    <code>yym_error</code>.

    <p>Rationale: The new names follow the method naming convention I
    have established generally, match the corresponding names from the
    C API (which did not exist when the old names were created), and
    are (a little) more descriptive.

<li><p>Several protected members that were not part of the documented
    API have been removed.  For example,
    <code>yy_load_buffer_state</code> was present as a protected member
    but its behavior was not documented since it was an implementation
    detail that ought to have been <code>private</code>.

</ul>


<p>Here is a table summarizing the changes to <code>yyFlexLexer</code>
members:

<table>
  <tr>
    <th>Old name
    <th>New name
  <tr>
    <td><code>yylex</code>
    <td><code>yym_lex</code>
  <tr>
    <td><code>switch_streams</code>
    <td><code>yym_switch_streams</code>
  <tr>
    <td><code>yywrap</code>
    <td><code>yym_wrap</code>
  <tr>
    <td><code>yy_switch_to_buffer</code>
    <td><code>yym_switch_to_buffer</code>
  <tr>
    <td><code>yy_create_buffer</code>
    <td><code>yym_create_buffer</code>
  <tr>
    <td><code>yy_delete_buffer</code>
    <td><code>yym_delete_buffer</code>
  <tr>
    <td><code>yy_restart</code>
    <td><code>yym_restart</code>
  <tr>
    <td><code>YYText</code>
    <td><code>yym_text</code>
  <tr>
    <td><code>YYLeng</code>
    <td><code>yym_leng</code>
  <tr>
    <td><code>lineno</code>
    <td><code>yym_lineno</code>
  <tr>
    <td><code>debug</code>
    <td><code>yym_flex_debug</code>
  <tr>
    <td><code>set_debug</code>
    <td><code>yym_set_flex_debug</code>
  <tr>
    <td><code>LexerInput</code>
    <td><code>yym_read_input</code>
  <tr>
    <td><code>LexerOutput</code>
    <td><code>yym_write_output</code>
  <tr>
    <td><code>LexerError</code>
    <td><code>yym_error</code>
  <tr>
    <td><code>yyunput</code>
    <td><code>yym_unread_character</code>
  <tr>
    <td><code>yyinput</code>
    <td><code>yym_read_character</code>
  <tr>
    <td><code>yy_load_buffer_state</code>
    <td>(removed)
  <tr>
    <td><code>yy_init_buffer</code>
    <td>(removed)
  <tr>
    <td><code>yy_flush_buffer</code>
    <td><code>yym_flush_buffer</code>
  <tr>
    <td><code>yy_push_state</code>
    <td><code>yym_push_state</code>
  <tr>
    <td><code>yy_pop_state</code>
    <td><code>yym_pop_state</code>
  <tr>
    <td><code>yy_top_state</code>
    <td><code>yym_top_state</code>
  <tr>
    <td><code>yy_get_previous_state</code>
    <td>(removed)
  <tr>
    <td><code>yy_try_NUL_trans</code>
    <td>(removed)
  <tr>
    <td><code>yy_get_next_buffer</code>
    <td>(removed)
</table>


<h2 id="new-features">New Features</h2>

<p>
There is are a few new features:

<ul>

<li><p>
    <code>flex-2.5.4</code> did not allow <code>%option c++</code> to be
    used with the <code>-CJ</code> (called <code>-CF</code> by that
    version) table compression option.  That limitation has been
    removed; the C++ interface now supports all of the same options as
    the C interface.  The key change making that possible is the
    change to emit a per-scanner header file rather than forcing all
    scanners to share the same one.

<li><p>
    <code>flex-2.5.4</code> did not allow <code>%option c++</code> to be
    used with <code>yy_scan_string</code>, <code>yy_scan_bytes</code>,
    or <code>yy_scan_byffer</code>.  Arguably this was not a major
    limitation because the C++ scanner reads from <code>istream</code>,
    which can read from memory, but it was a needless discrepancy.
    These are now all compatible.

</ul>


<h2 id="fixed-bugs">Fixed Bugs</h2>

<p>
I have also found and fixed a few pre-existing bugs:

<ul>

<li><p>
    <code>flex-2.5.4</code> did not emit <code>#line</code> directives
    very accurately.  In particular, the user's action code is
    interspersed with <code>flex</code> bookkeeping, but the latter
    had no <code>#line</code> directives, misattributing it as if it
    came from the user.  Now, all lines are properly attributed.  This
    property is automatically checked for all of my tests using
    <a href="test/check-line-directives.py">check-line-directives.py</a>.
    The commits with the fixes are: <code>1fb0feabe6</code>,
    <code>b0de9b4f2b</code>, <code>be4e9bfcab</code>,
    <code>9e843c70aa</code>, <code>efae82fd18</code>,
    <code>623d6901e9</code>.

<li><p>
    In <code>flex-2.5.4</code>, C++-interface scanners
    based their decision on whether to read the <em>input</em>
    interactively on whether the <em>scanner actions</em> were
    specified as interactive.  This was contrary to the behavior of
    C-interface scanners.  Commit <code>57c3f75272</code> has the
    fix.  However, later changes have rendered this fix moot, since I
    unified all the interactivity aspects under one flag.

<li><p>
    In <code>flex-2.5.4</code>, using a C++-interface scanner, it might
    misclassify an input error reported by <code>yyin->fail()</code> as
    EOF, thus silently swallowing the error.  Now, the error will be
    reported like other input errors.  (Currently, that means exiting
    with a fatal error message, which isn't great, but is better than
    silence.)  Commit <code>6908f0604c</code> has the fix.

<li><p>
    In <code>flex-2.5.4</code>, using a C++-interface scanner with
    <code>%option main</code> did not work because the generated
    <code>main()</code> function used the C interface.  Commit
    <code>0e4eb70de3</code> has the fix.

<li><p>
    In <code>flex-2.5.4</code>, using a C++-interface scanner with
    <code>%option debug</code> did not work as described in the manual
    because <code>yy_flex_debug</code> was set to 0 initially.  The
    one-line fix is in commit <code>d7106b2da2</code>, although that
    commit has many other changes too.

<li><p>
    In <code>flex-2.5.4</code>, creating a very deep stack of start
    states with <code>yy_push_state</code> caused quadratic run time
    due to inefficient allocation size growth.  The fix is to allocate
    using exponentially growing sizes.  Commit <code>0b2a7c04a6</code>
    contains the fix.

<li><p>
    In <code>flex-2.5.4</code>, when using <code>%option stack</code>, a
    scanner that pushes anything onto the state stack would experience a
    memory leak because the stack was never freed.  However, this
    arguably only affected the C++ API because, in that version, the C
    API only allowed one scanner instance.  Commit
    <code>e689b34d32</code> contains the fix.

<li><p>
    <code>flex-2.5.4</code> has some memory leaks in error cases.
    It also has a wrong arithmetic overflow check that has undefined
    behavior.
    Commits with fixes: <code>d8038d0185</code>,
    <code>4cc7be815f</code>,
    <code>6c3fd6a39f</code>

</ul>


<!-- ======================================================= -->
<h1 id="incompatibilities-with-lex-and-posix">INCOMPATIBILITIES WITH LEX AND POSIX</h1>

<p><strong>NOTE</strong>: This is Scott McPeak's fork of
<code>flex-2.5.4</code>.  Compatibility with <code>lex</code> and
POSIX is not among my goals, so I have made no attempt at that, nor
to catalogue the ways in which it is incompatible.
Therefore, from a user's perspective,
you should regard my <code>smflex</code> as
<strong>100% incompatible</strong> with <code>lex</code> and POSIX.
That's perhaps too extreme a statement now, but will only become more
true over time.

<p>Consequently, I have removed the contents of this section that
accompanied <code>flex-2.5.4</code>.  They are available in the
revision history before 2021-04-30.


<!-- ======================================================= -->
<h1 id="diagnostics">DIAGNOSTICS</h1>


<p>The following messages might be printed while <code>smflex</code>
runs:

<dl>

<dt><p><code>warning, rule cannot be matched</code>

<dd>indicates that the given
rule cannot be matched because it follows other rules that will always
match the same text as it. For example, in the following "foo" cannot
be matched because it comes after an identifier "catch-all" rule:

<pre><code>
    [a-z]+    got_identifier();
    foo       got_foo();
</code></pre>

Using <code>REJECT</code> in a scanner suppresses this warning.

<dt><p><code>warning, -s option given but default rule can be matched</code>

<dd>means that it is possible (perhaps only in a particular
start condition) that the default rule (match any single character) is
the only one that will match a particular input. Since <code>-s</code>
was given, presumably this is not intended.

<dt><p><code>scanner requires -8 flag to use the character 'x'</code>

<dd>Your scanner specification includes recognizing the 8-bit
character <code>'x'</code> and you did not specify the -8 flag, and your
scanner defaulted to 7-bit because you used the <code>-Cf</code> or
<code>-CJ</code> table compression options. See the discussion of the
<code>-7</code> flag for details.

<dt><p><code>too many start conditions in &lt;&gt; construct!</code>

<dd>you listed
more start conditions in a &lt;&gt; construct than exist (so you must
have listed at least one of them twice).

</dl>


<p>These messages might be printed by the compiler while compiling the
generated scanner:

<dl>

<dt><p><code>reject_used_but_not_detected undefined</code> or
    <code>yymore_used_but_not_detected undefined</code>

<dd>These indicate that the scanner uses <code>REJECT</code>
or <code>yymore()</code> but that <code>smflex</code> failed to notice the
fact, meaning that <code>smflex</code> scanned the first two sections
looking for occurrences of these actions and failed to find any,
but somehow you snuck some in (via a #include file, for example). Use
<code>%option reject</code> or <code>%option yymore</code> to indicate
to <code>smflex</code> that you really do use these features.

</dl>


<p id="yy_error_code_t">These are the error code enumerators of type
<code>yy_error_code_t</code> that can be reported to
<a href="#yy_error_function"><code>yy_error_function</code></a>
while the generated scanner is running:

<dl>

<dt id="yy_err_internal_error"><code>yy_err_internal_error</code>:

    <dd><p>
    Something went wrong with the scanner internal logic.  Either there
    is a bug in <code>smflex</code> or the API was misused (but that was
    not detected directly).

<dt id="yy_err_api_misuse"><code>yy_err_api_misuse</code>:

    <dd><p>
    The API was misused by passing data that violates its constraints or
    invoking functions in an invalid sequence.

<dt id="yy_err_input_error"><code>yy_err_input_error</code>:

    <dd><p>
    An attempt to read from the input source failed; that is,
    <a href="#yy_read_input_function"><code>yy_read_input_function</code></a>
    returned -1.

<dt id="yy_err_input_buffer_cannot_expand"><code>yy_err_input_buffer_cannot_expand</code>:

    <dd><p>
    The scanner was working on matching an extremely large token and
    needed to expand the input buffer. This doesn't work with scanners
    that use <code>REJECT</code>.

<dt id="yy_err_input_buffer_at_max_size"><code>yy_err_input_buffer_at_max_size</code>:

    <dd><p>
    A single token was larger than the size of the input buffer, and it
    cannot be expanded because the new size would not be representable
    with <code>size_t</code>.

<dt id="yy_err_no_rule_matches"><code>yy_err_no_rule_matches</code>:

    <dd><p>
    The scanner was compiled with <code>-s</code> and has encountered an
    input string which wasn't matched by any of its rules.

    <p>Older <code>flex</code> reports this condition as
    "scanner jammed".

<dt id="yy_err_out_of_memory"><code>yy_err_out_of_memory</code>:

    <dd><p>
    The scanner failed to allocate more memory when needed.

<dt id="yy_err_unread_overflow"><code>yy_err_unread_overflow</code>:

    <dd><p>
    You used <code>YY_UNREAD_CHARACTER()</code> to push back so much
    text that the scanner's buffer could not hold both the pushed-back
    text and the current token in <code>yytext</code>. Ideally the
    scanner should dynamically resize the buffer in this case, but at
    present it does not.

<dt id="yy_err_state_stack_overflow"><code>yy_err_state_stack_overflow</code>:

    <dd><p>
    When using <a href="#yy_push_state"><code>yy_push_state</code></a>,
    the start-state stack has hit its maximum size.  The exact size
    depends on configuration parameters, but is usually at least one
    billion <code>(INT_MAX/2)</code>.

</dl>


<!-- ======================================================= -->
<h1 id="deficiencies-n-bugs">DEFICIENCIES / BUGS</h1>

<p>Some trailing context patterns cannot be properly matched and generate
warning messages ("dangerous trailing context"). These are patterns
where the ending of the first part of the rule matches the beginning
of the second part, such as "zx*/xy*", where the 'x*' matches the 'x'
at the beginning of the trailing context. (Note that the POSIX draft
states that the text matched by such patterns is undefined.)

<p>For some trailing context rules, parts which are actually fixed-length
are not recognized as such, leading to the abovementioned performance
loss. In particular, parts using '|' or {n} (such as "foo{3}") are always
considered variable-length.

<p>Combining trailing context with the special '|' action can result
in <em>fixed</em> trailing context being turned into the more expensive
<em>variable</em> trailing context. For example, in the following:

<pre><code>
    %%
    abc      |
    xyz/def
</code></pre>

<p>Use of <code>YY_UNREAD_CHARACTER()</code> invalidates yytext and yyleng.

<p>Pattern-matching of NUL's is substantially slower than matching
other characters.

<p>Dynamic resizing of the input buffer is slow, as it entails rescanning
all the text matched so far by the current (generally huge) token.

<p>Due to both buffering of input and read-ahead, you cannot
intermix calls to &lt;stdio.h&gt; routines, such as, for example,
<code>getchar()</code>, with <code>smflex</code> rules and expect it to
work. Call <code>input()</code> instead.

<p>The total table entries listed by the <code>-v</code> flag excludes
the number of table entries needed to determine what rule has been
matched. The number of entries is equal to the number of DFA states if
the scanner does not use <code>REJECT</code>, and somewhat greater than
the number of states if it does.

<p><code>REJECT</code> cannot be used with the <code>-Cf</code> or
<code>-CJ</code> options.

<p>The <code>smflex</code> internal algorithms need documentation.


<!-- ======================================================= -->
<h1 id="see-also">SEE ALSO</h1>

<p>lex(1), yacc(1), sed(1), awk(1).

<p>John Levine, Tony Mason, and Doug Brown, <em>Lex &amp; Yacc</em>,
O'Reilly and Associates. Be sure to get the 2nd edition.

<p>M. E. Lesk and E. Schmidt, <em>LEX - Lexical Analyzer Generator</em>

<p>Alfred Aho, Ravi Sethi and Jeffrey Ullman, <em>Compilers: Principles,
Techniques and Tools</em>, Addison-Wesley (1986). Describes the
pattern-matching techniques used by <code>smflex</code> (deterministic
finite automata).


<!-- ======================================================= -->
<h1 id="author">AUTHOR</h1>

<p>This document describes Scott McPeak's fork of
Vern Paxson's <code>flex-2.5.4</code>.  I plan to post this on github
and accept issue reports there, and when that is done I will put a
link here.

<p>
Below is the text of the Author section that accompanied
<code>flex-2.5.4</code>.

<p>Vern Paxson, with the help of many ideas and much inspiration
from Van Jacobson. Original version by Jef Poskanzer. The fast table
representation is a partial implementation of a design done by Van
Jacobson. The implementation was done by Kevin Gong and Vern Paxson.

<p>Thanks to the many <code>flex</code> beta-testers, feedbackers, and
contributors, especially Francois Pinard, Casey Leedom, Robert Abramovitz,
Stan Adermann, Terry Allen, David Barker-Plummer, John Basrai, Neal
Becker, Nelson H.F. Beebe, benson@odi.com, Karl Berry, Peter A. Bigot,
Simon Blanchard, Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho,
Nick Christopher, Brian Clapper, J.T. Conklin, Jason Coughlin, Bill Cox,
Nick Cropper, Dave Curtis, Scott David Daniels, Chris G. Demetriou,
Theo Deraadt, Mike Donahue, Chuck Doucette, Tom Epperly, Leo Eskin,
Chris Faylor, Chris Flatters, Jon Forrest, Jeffrey Friedl, Joe Gayda,
Kaveh R. Ghazi, Wolfgang Glunz, Eric Goldman, Christopher M. Gould,
Ulrich Grepel, Peer Griebel, Jan Hajic, Charles Hemphill, NORO Hideo,
Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana Hudes, Eric Hughes,
John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari Jalovaara,
Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I. Kamens,
Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin B. Kenny, Steve
Kirsch, Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan
Lenard, Craig Leres, John Levine, Steve Liddle, David Loffredo, Mike Long,
Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt Martensson,
Chris Metcalf, Luke Mewburn, Jim Meyering, R. Alexander Milowski, Erik
Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard
Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero,
Gaumond Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha,
Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe
Rommel, Jim Roskind, Alberto Santini, Andreas Scherer, Darrell Schiebel,
Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas Schwab,
Larry Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist,
Mike Stump, Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt,
Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley,
Gerhard Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle,
David Zuhn, and those whose names have slipped my marginal mail-archiving
skills but whose contributions are appreciated all the same.

<p>Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore,
Craig Leres, John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, Rich
Salz, and Richard Stallman for help with various distribution headaches.

<p>Thanks to Esmond Pitt and Earle Horton for 8-bit character support;
to Benson Margulies and Fred Burke for C++ support; to Kent Williams and
Tom Epperly for C++ class support; to Ove Ewerlid for support of NUL's;
and to Eric Hughes for support of multiple buffers.

<p>This work was primarily done when I was with the Real Time Systems
Group at the Lawrence Berkeley Laboratory in Berkeley, CA. Many thanks
to all there for the support I received.

<p>Send comments to vern@ee.lbl.gov.
</body>
</html>
